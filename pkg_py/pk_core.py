# -*- coding: utf-8 -*-  # python 3.x 하위버전 호환을 위한코드
__author__ = 'pk_system'

from functools import lru_cache
from typing import TypeVar, List

T = TypeVar('T')
from pkg_py.pk_core_constants import PkFilter

import toml
from pathlib import Path

F_PK_CONFIG_TOML = rf'{str(Path(__file__).parent.parent.absolute())}/pkg_toml/pk_config.toml'
LOCAL_TEST_ACTIVATE = toml.load(F_PK_CONFIG_TOML)["LOCAL_TEST_ACTIVATE"]
LTA = LOCAL_TEST_ACTIVATE


def todo(id):
    from pkg_py.pk_colorful_cli_util import pk_print
    pk_print(f'''여기 할 차례입니다. at {id}. {'%%%FOO%%%' if LTA else ''}''', print_color="blue")
    raise


def is_internet_connected():
    from pkg_py.pk_colorful_cli_util import pk_print
    # if not ping(ip='google.com'):
    if not ping(ip='8.8.8.8'):
        pk_print(f'''internet not connected. {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        return 0
    return 1


def is_office_pc():
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PKG_TXT

    hostname = cmd_to_os("hostname")[0]
    hostname = get_str_url_decoded(hostname)
    pk_print(f"hostname={hostname}")
    token_hostname_a2z_galaxybook = get_token_from_f_txt(f_token=rf'{D_PKG_TXT}\token_hostname_a2z_galaxybook.txt', initial_str="")
    token_hostname_home_desktop = get_token_from_f_txt(f_token=rf'{D_PKG_TXT}\token_hostname_home_desktop.txt', initial_str="")

    if hostname == token_hostname_home_desktop:
        return 0
    elif hostname == token_hostname_a2z_galaxybook:
        return 1


# deep size 측정용 (optional, pip install pympler)
try:
    from pympler import asizeof

    have_pympler = True
except ImportError:
    have_pympler = False


def pk_measure_memory(func):
    import functools
    import os
    import sys
    from pkg_py.pk_colorful_cli_util import pk_print
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        proc = psutil.Process(os.getpid())
        # 강제 가비지 컬렉션 후 초기 메모리 측정 (선택)
        # import gc; gc.collect()
        before_rss = proc.memory_info().rss
        result = func(*args, **kwargs)
        # import gc; gc.collect()
        after_rss = proc.memory_info().rss
        delta_rss_mb = (after_rss - before_rss) / (1024 ** 2)

        # 반환 객체 크기 측정 (얕은 크기)
        shallow_bytes = sys.getsizeof(result)
        shallow_mb = shallow_bytes / (1024 ** 2)

        msg = (f"[{func.__name__}] RSS 증가: {delta_rss_mb:.2f} MiB, "
               f"반환 객체 얕은 크기: {shallow_mb:.2f} MiB")

        # deep 크기 측정 (가능한 경우)
        if have_pympler:
            deep_bytes = asizeof.asizeof(result)
            deep_mb = deep_bytes / (1024 ** 2)
            msg += f", 반환 객체 깊은 크기: {deep_mb:.2f} MiB"
        else:
            msg += " (deep 측정하려면 `pip install pympler`)"

        pk_print(msg, print_color="yellow")
        return result

    return wrapper


def pk_measure_seconds(func):
    from functools import wraps
    import inspect
    if not LTA:
        return func
    func_n = inspect.currentframe().f_code.co_name

    @wraps(func)
    def wrapper(*args, **kwargs):
        import time
        from pkg_py.pk_colorful_cli_util import pk_print
        from colorama import init as pk_colorama_init
        time_s = time.time()
        result = func(*args, **kwargs)  # 원래 함수 실행
        elapsed_seconds = time.time() - time_s
        pk_colorama_init(autoreset=True)
        pk_print(working_str=f"[ @{func_n} ] [ {func.__name__}() ]  elapsed_seconds={elapsed_seconds:.4f}", print_color='yellow')  # todo 'elapsed_seconds={elapsed_seconds:.4f}' 에 노랗게 해고 싶다.
        # todo : 파일에 기록되도록 한다.  추후에 통계를 한다.
        return result  # 원래 함수의 반환값 그대로 반환

    return wrapper


def gen_vpc_flash_image():
    pass


def get_key_public(**config_remote_os):
    import os.path
    local_ssh_public_key = config_remote_os['local_ssh_public_key']

    if not os.path.exists(local_ssh_public_key):
        raise FileNotFoundError(f"PUBLIC KEY NOT FOUND AT {local_ssh_public_key}")
    with open(local_ssh_public_key, "r") as f_obj:
        key_public = f_obj.read().strip()


def ensure_ssh_public_key_to_remote_os(**config_remote_os):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import STAMP_TRY_GUIDE
    import paramiko

    ip = config_remote_os['ip']
    port = config_remote_os['port']
    user_n = config_remote_os['user_n']
    pw = config_remote_os['pw']

    key_public = get_key_public(**config_remote_os)
    if check_ssh_server_public_key(key_public=key_public, **config_remote_os):
        pk_print("SSH PUBLIC KEY IS ALREADY REGISTERED")
        return
    else:
        pk_print(working_str="SSH PUBLIC KEY IS NOT REGISTERED", print_color='red')

    # Paramiko로 SSH 연결
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    try:
        ssh.connect(hostname=ip, port=port, username=user_n, password=pw)
        pk_print(f"{STAMP_TRY_GUIDE} ssh -p {port} {user_n}@{ip} ")

        add_public_key_to_remote_via_paramiko(ssh_paramiko=ssh, key_public=key_public)

    except paramiko.AuthenticationException as e:
        pk_print(f"Authentication failed. Please check your user_n and password: {e}", print_color='red')
        raise
    except paramiko.SSHException as e:
        pk_print(f"SSH connection error: {e}", print_color='red')
        raise
    except Exception as e:
        pk_print(f"An unexpected error occurred: {e}", print_color='red')
        raise
    finally:
        ssh.close()
        if LTA:
            pk_print("SSH connection closed.")


def add_public_key_to_remote_via_paramiko(ssh_paramiko, key_public):
    """원격 서버에 공개 키 추가 및 권한 설정"""
    cmd_list = [
        'mkdir -p ~/.ssh',
        'chmod 700 ~/.ssh',
        f'grep -qxF "{key_public}" ~/.ssh/authorized_keys || echo "{key_public}" >> ~/.ssh/authorized_keys',
        'chmod 600 ~/.ssh/authorized_keys'
    ]
    for cmd in cmd_list:
        stdin, stdout, stderr = ssh_paramiko.exec_command(cmd)
        stdout.channel.recv_exit_status()


def move_pnx_from_remote_os_to_local(pnx, d_dst=None, **config_remote_os):
    # todo
    from pkg_py.pk_core_constants import D_DOWNLOADS
    pnx = get_pnx_unix_style(pnx)
    ip = config_remote_os['ip']
    port = config_remote_os['port']
    user_n = config_remote_os['user_n']
    d_dst = d_dst or D_DOWNLOADS
    d_dst = get_pnx_unix_style(d_dst)
    cmd_to_os(cmd=f'scp -P {port} -r {user_n}@{ip}:"{pnx}" "{d_dst}"')
    pk_sleep(milliseconds=500)


def pk_chdir(d_dst):
    import os
    from pkg_py.pk_colorful_cli_util import pk_print
    d_before = os.getcwd()
    os.chdir(path=d_dst)
    d_after = os.getcwd()
    if d_before == d_after:
        pk_print(working_str=rf''' {'%%%FOO%%%' if LTA else ''}''', print_color='red')


def minimize_all_windows_callback(hwnd, lparam):
    import inspect
    import win32gui  # pywin32
    import win32con  # pywin32
    func_n = inspect.currentframe().f_code.co_name

    # 창이 보이는 상태일 때만 최소화
    if win32gui.IsWindowVisible(hwnd):
        win32gui.ShowWindow(hwnd, win32con.SW_MINIMIZE)  # 창을 최소화
        print(f"창 {win32gui.GetWindowText(hwnd)}를 최소화했습니다.")


def minimize_all_windows():
    import win32gui  # pywin32
    win32gui.EnumWindows(minimize_all_windows_callback, None)


def get_userprofile_via_cmd_exe():
    userprofile = cmd_to_os("echo %USERPROFILE%")[0]
    userprofile = get_str_url_decoded(userprofile)
    return userprofile


def get_text_dragged():
    from pkg_py.pk_colorful_cli_util import pk_print

    import inspect
    import clipboard
    func_n = inspect.currentframe().f_code.co_name

    # 클립보드 백업
    clipboard_current_contents = pk_paste()

    # 드래그된것 클립보드에 저장
    pk_press("ctrl", "c")

    # 클립보드에서 변수에 저장
    text_dragged = pk_paste()

    pk_print(working_str=rf'''text_dragged="{text_dragged}"  {'%%%FOO%%%' if LTA else ''}''')

    # 클립보드 복원
    clipboard.copy(clipboard_current_contents)

    return text_dragged


def kill_chrome_tab(url_to_close):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print

    func_n = inspect.currentframe().f_code.co_name

    window_titles = get_window_title_list()
    loop_limit = 50
    for window_title_seg in window_titles:
        if "chrome".lower() in window_title_seg.lower():
            pk_print(working_str=rf'''window_title="{window_title_seg}"  {'%%%FOO%%%' if LTA else ''}''')
            loop_cnt = 0
            while 1:
                ensure_window_to_front(window_title_seg=window_title_seg)
                if loop_cnt == loop_limit:
                    break
                loop_cnt = loop_cnt + 1
                pk_sleep(milliseconds=15)
                pk_press("ctrl", "l")
                pk_sleep(milliseconds=15)
                url_dragged = get_text_dragged()
                if url_dragged == url_to_close:
                    pk_print(working_str=rf'''url_to_close="{url_to_close}"  {'%%%FOO%%%' if LTA else ''}''')
                    pk_print(working_str=rf'''url_dragged="{url_dragged}"  {'%%%FOO%%%' if LTA else ''}''')
                    pk_press("ctrl", "w")
                    # restore_all_windows()
                    return


def refresh_chrome_tab(url_to_close):
    from pkg_py.pk_colorful_cli_util import pk_print

    import inspect
    func_n = inspect.currentframe().f_code.co_name

    # minimize_all_windows()
    # window_title_seg = get_window_title(window_title_seg="Chrome")
    window_titles = get_window_title_list()
    import time

    timeout_seconds = 10
    start_time = time.time()
    for window_title_seg in window_titles:
        if "chrome".lower() in window_title_seg.lower():
            if timeout_seconds == 50:
                pk_print(working_str=rf'''window_title="{window_title_seg}"  {'%%%FOO%%%' if LTA else ''}''')
            while 1:
                elapsed_time = time.time() - start_time
                if elapsed_time > timeout_seconds:
                    break
                ensure_window_to_front(window_title_seg=window_title_seg)
                pk_sleep(milliseconds=15)
                pk_press("ctrl", "l")
                pk_sleep(milliseconds=15)
                url_dragged = get_text_dragged()
                if url_dragged == url_to_close:
                    pk_print(working_str=rf'''url_to_close="{url_to_close}"  {'%%%FOO%%%' if LTA else ''}''')
                    pk_print(working_str=rf'''url_dragged="{url_dragged}"  {'%%%FOO%%%' if LTA else ''}''')
                    pk_press("f5")
                    # restore_all_windows()
                    return


def move_chrome_tab_by_url(url):
    # todo : test 버퍼 지워지는 것 같음.
    from pkg_py.pk_colorful_cli_util import pk_print

    minimize_all_windows()
    window_title_seg = get_window_title(window_title_seg="Chrome")
    window_titles = get_window_title_list()
    for window_title in window_titles:
        if "Chrome".lower() in window_title.lower():
            ensure_window_to_front(window_title_seg=window_title)
            loop_limit = 30
            loop_cnt = 0
            while 1:
                if loop_cnt == loop_limit:
                    return
                loop_cnt = loop_cnt + 1
                pk_sleep(milliseconds=15)
                pk_press("ctrl", "l")
                pk_sleep(milliseconds=15)
                url_dragged = get_text_dragged()
                if url_dragged == url:
                    pk_print(f'''url_to_move = "{url}"''')
                    pk_print(f'''url_dragged = "{url_dragged}"''')
                    break
                pass


def does_normal_tab_exist(driver_selenium, tab_title_negative):
    import random

    for window in driver_selenium.window_handles:  # 모든 탭 이동
        driver_selenium.switch_to.window(window)  # 각 탭으로 전환
        pk_sleep(milliseconds=random.randint(22, 2222))
        if tab_title_negative not in driver_selenium.title:  # 탭 제목 확인
            return 1
    return 0


def classify_pnxs_to_pkg_document(pnx, without_walking=True):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_DB_YAML, F_SUCCESS_LOG, F_LOCAL_PKG_CACHE

    import inspect
    func_n = inspect.currentframe().f_code.co_name

    # target_pnx가 유효한 _d_인지 확인
    if is_f(pnx=pnx):
        pk_print(f"{pnx} 는 정리할 수 있는 _d_가 아닙니다")
        return

    # f과 _d_ get
    txt_to_exclude_list = [
        F_DB_YAML,
        F_SUCCESS_LOG,
        F_LOCAL_PKG_CACHE,
    ]
    if without_walking == False:
        dir_pnxs, file_pnxs = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list)
    else:
        dir_pnxs, file_pnxs = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list, without_walking=0)

    # f 처리
    x_allowed = [".txt", '.ximind', '.pdf', '.xls']
    x_allowed = x_allowed + get_list_replaced_element_from_str_to_upper_case(working_list=x_allowed)
    pnx = get_pn(pnx)
    dst = rf"{pnx}\pkg_document"
    for file_pnx in file_pnxs:
        file_pnx = file_pnx[0]
        file_p = get_p(file_pnx)
        file_x = get_x(file_pnx).replace(".", "")  # 확장자에서 점(.) remove
        if file_x in [ext.replace(".", "") for ext in x_allowed]:  # x_allowed의 확장자와 비교
            ensure_pnx_made(dst, mode="d")
            move_pnx(pnx=file_pnx, d_dst=dst)
            pk_print(working_str=rf'''file_pnx="{file_pnx}"  {'%%%FOO%%%' if LTA else ''}''')
    pk_print(working_str=rf'''dst="{dst}"  {'%%%FOO%%%' if LTA else ''}''')


def classify_pnxs_to_pk_image(pnx, without_walking=True):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_DB_YAML, F_SUCCESS_LOG, F_LOCAL_PKG_CACHE

    import inspect
    func_n = inspect.currentframe().f_code.co_name

    # target_pnx가 유효한 _d_인지 확인
    if is_f(pnx=pnx):
        pk_print(f"{pnx} 는 정리할 수 있는 _d_가 아닙니다")
        return

    # f과 _d_ get
    txt_to_exclude_list = [
        F_DB_YAML,
        F_SUCCESS_LOG,
        F_LOCAL_PKG_CACHE,
    ]
    if without_walking == False:
        dir_pnxs, file_pnxs = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list)
    else:
        dir_pnxs, file_pnxs = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list, without_walking=0)

    # f 처리
    x_allowed = [".png", '.jpg', '.jpeg', '.jfif', '.webp']
    x_allowed = x_allowed + get_list_replaced_element_from_str_to_upper_case(working_list=x_allowed)
    pnx = get_pn(pnx)
    dst = rf"{pnx}\pk_image"
    for file_pnx in file_pnxs:
        file_pnx = file_pnx[0]
        file_p = get_p(file_pnx)
        file_x = get_x(file_pnx).replace(".", "")  # 확장자에서 점(.) remove
        if file_x in [ext.replace(".", "") for ext in x_allowed]:  # x_allowed의 확장자와 비교
            ensure_pnx_made(dst, mode="d")
            move_pnx(pnx=file_pnx, d_dst=dst)
            pk_print(working_str=rf'''file_pnx="{file_pnx}"  {'%%%FOO%%%' if LTA else ''}''')
    pk_print(working_str=rf'''dst="{dst}"  {'%%%FOO%%%' if LTA else ''}''')


def classify_pnxs_to_pkg_video(pnx, without_walking=True):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_DB_YAML, F_SUCCESS_LOG, F_LOCAL_PKG_CACHE

    import inspect
    func_n = inspect.currentframe().f_code.co_name

    # target_pnx가 유효한 _d_인지 확인
    if is_f(pnx=pnx):
        pk_print(f"{pnx} 는 정리할 수 있는 _d_가 아닙니다")
        return

    # f과 _d_ get
    txt_to_exclude_list = [
        F_DB_YAML,
        F_SUCCESS_LOG,
        F_LOCAL_PKG_CACHE,
    ]
    if without_walking == False:
        dir_pnxs, file_pnxs = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list)
    else:
        dir_pnxs, file_pnxs = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list, without_walking=0)

    # f 처리
    x_allowed = [".mp4", '.avi', '.mkv', '.webm', '.mpg', '.flv', '.wmv']
    x_allowed = x_allowed + get_list_replaced_element_from_str_to_upper_case(working_list=x_allowed)
    pnx = get_pn(pnx)
    dst = rf"{pnx}\pkg_video"
    file_pnx = None
    for file_pnx in file_pnxs:
        file_pnx = file_pnx[0]
        file_p = get_p(file_pnx)
        file_x = get_x(file_pnx).replace(".", "")  # 확장자에서 점(.) remove
        if file_x in [ext.replace(".", "") for ext in x_allowed]:  # x_allowed의 확장자와 비교
            ensure_pnx_made(pnx=dst, mode="d")
            move_pnx(pnx=file_pnx, d_dst=dst)
            pk_print(working_str=rf'''file_pnx="{file_pnx}"  {'%%%FOO%%%' if LTA else ''}''')
    pk_print(working_str=rf'''dst="{dst}"  {'%%%FOO%%%' if LTA else ''}''')


def classify_pnxs_to_pkg_soundtrack(pnx, without_walking=True):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_DB_YAML, F_SUCCESS_LOG, F_LOCAL_PKG_CACHE

    import inspect
    func_n = inspect.currentframe().f_code.co_name

    # 유효_d_ 확인
    if is_f(pnx=pnx):
        pk_print(f"{pnx} 는 정리할 수 있는 _d_가 아닙니다")
        return

    # f과 _d_ get
    txt_to_exclude_list = [
        F_DB_YAML,
        F_SUCCESS_LOG,
        F_LOCAL_PKG_CACHE,
    ]
    if without_walking == False:
        dir_pnxs, file_pnxs = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list)
    else:
        dir_pnxs, file_pnxs = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list, without_walking=0)

    # f 처리
    x_allowed = [".mp3", '.flac', '.wav']
    x_allowed = x_allowed + get_list_replaced_element_from_str_to_upper_case(working_list=x_allowed)
    pnx = get_pn(pnx)
    dst = rf"{pnx}\pkg_soundtrack"
    for file_pnx in file_pnxs:
        file_pnx = file_pnx[0]
        file_p = get_p(file_pnx)
        file_x = get_x(file_pnx).replace(".", "")  # 확장자에서 점(.) remove
        if file_x in [ext.replace(".", "") for ext in x_allowed]:  # x_allowed의 확장자와 비교
            ensure_pnx_made(dst, mode="d")
            move_pnx(pnx=file_pnx, d_dst=dst)
            pk_print(working_str=rf'''file_pnx="{file_pnx}"  {'%%%FOO%%%' if LTA else ''}''')
    pk_print(working_str=rf'''dst="{dst}"  {'%%%FOO%%%' if LTA else ''}''')


def classify_pnxs_to_pkg_compressed(src, without_walking=1):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_DB_YAML, F_SUCCESS_LOG, F_LOCAL_PKG_CACHE

    import inspect
    func_n = inspect.currentframe().f_code.co_name

    # _d_ 유효성 확인
    if is_f(pnx=src):
        pk_print(f"{src}  {'%%%FOO%%%' if LTA else ''}")
        return

    # f과 _d_ get
    txt_to_exclude_list = [
        F_DB_YAML,
        F_SUCCESS_LOG,
        F_LOCAL_PKG_CACHE,
    ]

    if without_walking == 0:
        dir_pnxs, file_pnxs = get_sub_pnx_list(pnx=src, txt_to_exclude_list=txt_to_exclude_list)
    else:
        dir_pnxs, file_pnxs = get_sub_pnx_list(pnx=src, txt_to_exclude_list=txt_to_exclude_list, with_walking=1)

    # f 처리
    x_allowed = [".zip", '.tar']
    x_allowed = x_allowed + get_list_replaced_element_from_str_to_upper_case(working_list=x_allowed)
    src = get_pn(src)
    dst = rf"{src}\pkg_compressed"
    for file_pnx in file_pnxs:
        file_pnx = file_pnx[0]
        file_p = get_p(file_pnx)
        file_x = get_x(file_pnx).replace(".", "")  # 확장자에서 점(.) remove
        if file_x in [ext.replace(".", "") for ext in x_allowed]:  # x_allowed의 확장자와 비교
            ensure_pnx_made(dst, mode="d")
            move_pnx(pnx=file_pnx, d_dst=dst)
            pk_print(working_str=rf'''file_new="{file_pnx}"  {'%%%FOO%%%' if LTA else ''}''')
    pk_print(working_str=rf'''dst="{dst}"  {'%%%FOO%%%' if LTA else ''}''')


def get_f_n_moved_pattern(pattern, pnx_working, mode_front):
    import re
    match = re.search(pattern=pattern, string=pnx_working)
    n = get_n(pnx_working)
    p = get_p(pnx_working)
    x = get_x(pnx_working)
    if match:
        pattern = match.group(1)
        if mode_front:
            pnx_working_new = rf"{p}\{pattern}_{n.replace(pattern, '')}{x}"
        else:
            pnx_working_new = rf"{p}\{n.replace(pattern, '')}_{pattern}{x}"
        return pnx_working_new
    else:
        # 패턴이 없으면 원래 f명 반환
        return pnx_working


def save_all_drive_pnxs_to_text_file2():  # 루프 수정필요 # 이 함수는 거의 필요 없을 것 같다. 관심_d_만 확인하는 것으로 충분해 보인다.
    import os.path
    import string
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PROJECT, D_PKG_TXT
    import os

    import inspect

    func_n = inspect.currentframe().f_code.co_name

    f_func_n_txt = rf'{D_PROJECT}\pkg_txt\{func_n}.txt'
    ensure_pnx_made(pnx=f_func_n_txt, mode="item")

    # if not is_window_open(window_title=f_func_n_txt):
    #     run_pnx_via_explorer_exe(f_func_n_txt, debug_mode=False)

    # 1. 특정 경로를 제외할 텍스트 f에서 경로 읽어오기
    def load_pnxs_exclude(file_path):

        import inspect
        func_n = inspect.currentframe().f_code.co_name

        exclude_paths = set()
        try:
            with open(file_path, 'r', encoding='utf-8') as file:
                for line in file:
                    exclude_paths.add(line.strip())
        except PermissionError as e:
            print(f"PermissionError: {e}. Check if the item is accessible and you have the right permissions.")
        except Exception as e:
            print(f"Error opening item {file_path}: {e}")
        return exclude_paths

    # 2. 모든 드라이브에서 f 목록 가져오기
    def get_drives_connected():

        import inspect
        func_n = inspect.currentframe().f_code.co_name

        drives = []
        for letter in string.ascii_uppercase:
            drive = f"{letter}:\\"
            if os.path.exists(drive):
                drives.append(drive)
        pk_print(working_str=rf'''drives="{drives}"  {'%%%FOO%%%' if LTA else ''}''')
        return drives

    # 3. 드라이브에서 f 검색하고 처리하기
    def list_files_in_drives(exclude_paths_txt):
        import inspect
        func_n = inspect.currentframe().f_code.co_name

        exclude_paths = load_pnxs_exclude(exclude_paths_txt)
        drives = get_drives_connected()
        cnt = 0
        pnxs = []
        limit = 10000
        cnt_files = limit
        cnt_txt_files = 0
        temp = set()
        # 모든 드라이브에서 f 탐색
        for drive in drives:
            pk_print(working_str=rf'''drive="{drive}"  {'%%%FOO%%%' if LTA else ''}''')
            for foldername, subfolders, filenames in os.walk(drive):
                for filename in filenames:
                    file_pnx = os.path.join(foldername, filename)
                    # pk_print(string = rf'''file_pnx="{file_pnx}"  {'%%%FOO%%%' if LTA else ''}''')
                    cnt_files = cnt_files - 1
                    pnxs.append(file_pnx)
                    if cnt_files == 0:
                        # pk_print(string = rf'''file_pnx="{file_pnx}"  {'%%%FOO%%%' if LTA else ''}''')
                        cnt_files = limit
                        cnt_txt_files = cnt_txt_files + 1
                        # pk_print(string = rf'''cnt_txt_files="{cnt_txt_files}"  {'%%%FOO%%%' if LTA else ''}''')
                        output_pnx_txt_before = rf"{D_PKG_TXT}\{func_n}_{cnt_txt_files - 1}.txt"
                        temp = get_list_from_f(f=output_pnx_txt_before)
                        if None != temp:
                            if 0 == len(temp):
                                cnt_txt_files = cnt_txt_files - 1

                        output_pnx_txt = rf"{D_PKG_TXT}\{func_n}_{cnt_txt_files}.txt"
                        # pk_print(string = rf'''output_pnx_txt="{output_pnx_txt}"  {'%%%FOO%%%' if LTA else ''}''')
                        # if any(exclude_path in file_pnx for exclude_path in exclude_paths):
                        #     continue
                        with open(output_pnx_txt, 'w', encoding='utf-8') as f:
                            for pnx in pnxs:
                                cnt = cnt + 1
                                # temp.add(rf"{pnx.split("\\")[0]}\{pnx.split("\\")[1]}")
                                # print(temp)
                                for exclude_path in exclude_paths:
                                    if exclude_path in pnx:
                                        break
                                else:
                                    if not pnx.strip() == "":
                                        f.write(f'{pnx}\n')
                                        pk_print(working_str=rf'''cnt="{cnt}" pnxs="{pnx}" output_pnx_txt="{output_pnx_txt}"  {'%%%FOO%%%' if LTA else ''}''')
                                    else:
                                        pk_print(f'''없다''')
        pk_print(working_str=rf'''temp="{temp}"  {'%%%FOO%%%' if LTA else ''}''')

    # exec 
    exclude_paths_txt = rf'{D_PKG_TXT}\{func_n}_exclude_paths.txt'
    ensure_pnx_made(pnx=exclude_paths_txt, mode='item')
    list_files_in_drives(exclude_paths_txt)


def make_pnx_interested_list_to_txt_f_x(pnx_interested_list=None, string_exclude=None):
    from pkg_py.pk_core_constants import D_PKG_TXT, D_HOME, D_DOWNLOADS
    import inspect

    # todo f 내용 초기화 되어야 한다.
    func_n = inspect.currentframe().f_code.co_name

    # pnx_interested_list = []
    if pnx_interested_list is None:
        pnx_interested_list = [
            rf'{D_DOWNLOADS}',
            rf'{D_HOME}\AppData\Roaming\bittorrent',

            rf'D:\\',
            rf'E:\\',
            rf'F:\\',
        ]
    if string_exclude is None:
        string_exclude = [
            rf'{D_DOWNLOADS}\[]\docker_image_maker\venv',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\ios',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\macos',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\windows',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\web',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\linux',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\lib',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\build',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\asset',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\android',

            rf'D:\$RECYCLE.BIN',
            rf'D:\System Volume Information',

            rf'E:\$RECYCLE.BIN',
            rf'E:\System Volume Information',

            rf'F:\$RECYCLE.BIN',
            rf'F:\System Volume Information',

            rf'deprecated',
            rf'[ARCHIVED]',
            rf'.git',
            rf'.idea',
            rf'venv',
            rf'node_modules',
            rf'test_flutter',
            rf'pkg_font',
            rf'telegram memo export by static web',
            rf'docker_image_maker',
            rf'e-magazine',
            rf'netlify-web',
        ]
    pnx_processed_list = []
    file_cnt = 0
    write_cnt = 0
    write_cnt_limit = 1000000
    for pnx_interested in pnx_interested_list:
        pnxs_with_walking = get_pnx_list(d_working=pnx_interested, mode="f", with_walking=1)

        # 'pnxs_exclude'를 set으로 변경하여 'in' 연산을 최적화
        func_n_file_cnt_txt = None
        for pnx_with_walking in pnxs_with_walking:
            # 빠른 'in' 연산을 위해 set으로 변환된 pnxs_exclude 활용
            if any(pnx_exclude in pnx_with_walking for pnx_exclude in string_exclude):
                continue  # 'pnx_exclude'에 포함되면 건너뛰기
            # 'exclude' 목록에 포함되지 않으면 'pnx_processed_list'에 추가
            pnx_processed_list.append(pnx_with_walking)
            # pk_print(str_working=rf'''len(pnx_processed_list)="{len(pnx_processed_list)}"  {'%%%FOO%%%' if LTA else ''}''')
            if write_cnt == write_cnt_limit % 2 == 0:
                file_cnt = file_cnt + 1
                print_iterable_as_vertical(item_iterable=pnx_processed_list, item_iterable_n="pnx_processed_list")
                # func_n_file_cnt_txt = rf"{D_PKG_TXT}\{func_n}_{file_cnt}.txt"
                # write_list_to_file(texts=pnx_processed_list, pnx=func_n_file_cnt_txt, mode="w")
            func_n_file_cnt_txt = rf"{D_PKG_TXT}\{func_n}_{file_cnt}.txt"
            # pk_print(str_working=rf'''write_cnt="{write_cnt}"  {'%%%FOO%%%' if LTA else ''}''')
            write_str_to_f(txt=f"{pnx_with_walking}\n", f=func_n_file_cnt_txt, mode="a")
            write_cnt = write_cnt + 1
            if write_cnt == write_cnt_limit % 2 == 0:
                window_title = rf"{func_n}_{file_cnt}"
                # if not is_window_open(window_title_seg=window_title):
                #     open_pnx(pnx=func_n_file_cnt_txt)


def make_pnx_interested_list_to_txt_f(pnx_interested_list=None, string_exclude=None):
    from pkg_py.pk_core_constants import D_PKG_TXT, D_HOME, D_DOWNLOADS

    import inspect
    func_n = inspect.currentframe().f_code.co_name

    # pnx_interested_list = []
    if pnx_interested_list is None:
        pnx_interested_list = [
            rf'{D_DOWNLOADS}',
            rf'{D_HOME}\AppData\Roaming\bittorrent',

            rf'D:\\',
            rf'E:\\',
            rf'F:\\',
        ]
    # pnxs_exclude = []
    if pnx_interested_list is None:
        string_exclude = [
            rf'{D_DOWNLOADS}\[]\docker_image_maker\venv',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\ios',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\macos',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\windows',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\web',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\linux',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\lib',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\build',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\asset',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\android',

            rf'D:\$RECYCLE.BIN',
            rf'D:\System Volume Information',

            rf'E:\$RECYCLE.BIN',
            rf'E:\System Volume Information',

            rf'F:\$RECYCLE.BIN',
            rf'F:\System Volume Information',

            rf'deprecated',
            rf'[ARCHIVED]',
            rf'.git',
            rf'.idea',
            rf'venv',
            rf'node_modules',
            rf'test_flutter',
            rf'pkg_font',
            rf'telegram memo export by static web',
            rf'docker_image_maker',
            rf'e-magazine',
            rf'netlify-web',
        ]

    pnx_processed_list = []
    f_func_n_txt = rf"{D_PKG_TXT}\{func_n}.txt"
    write_str_to_f(txt=f"", f=f_func_n_txt, mode="w")  # 내용 초기화
    for pnx_interested in pnx_interested_list:
        pnxs_with_walking = get_pnx_list(d_working=pnx_interested, mode="f", with_walking=1)
        for pnx_with_walking in pnxs_with_walking:
            if any(pnx_exclude in pnx_with_walking for pnx_exclude in string_exclude):
                continue
            pnx_processed_list.append(pnx_with_walking)
            write_str_to_f(txt=f"{pnx_with_walking}\n", f=f_func_n_txt, mode="a")


def get_center_of_bounding_box(bounding_box):
    import inspect
    func_n = inspect.currentframe().f_code.co_name

    """
    바운딩 박스 좌표를 받아서, 그 중심 좌표를 반환하는 함수.

    :param bounding_box: 바운딩 박스 좌표 [(x1, y1), (x2, y2), (x3, y3), (x4, y4)]
    :return: 중심 좌표 (x, y)
    """
    # 네 점의 x, y 좌표를 각각 합산
    if bounding_box is None:
        return None
    x_coords = [point[0] for point in bounding_box]
    y_coords = [point[1] for point in bounding_box]

    # x, y 평균값을 구하여 중심 좌표 계산
    center_x = sum(x_coords) / 4
    center_y = sum(y_coords) / 4

    return center_x, center_y


def get_text_coordinates_via_easy_ocr(string):  # 한글인식 잘 안되는 듯하다
    import string
    from pkg_py.pk_colorful_cli_util import pk_print

    # 화면 캡처
    screenshot = get_screenshot()

    # EsayOCR을 통해 모든텍스트 바운딩박스좌표 추출
    # coordinates_bounding_box = get_all_text_with_coordinates_via_easy_ocr(screenshot)
    # print_list_as_vertical(working_list=coordinates_bounding_box, items_name="coordinates_bounding_box")

    # EsayOCR을 통해 특정텍스트 바운딩박스좌표 추출
    coordinates_bounding_box = get_coordinates_bounding_box(image=screenshot, str_working=string)
    # print_list_as_vertical(working_list=coordinates_bounding_box, items_name="coordinates_bounding_box")

    # 중심 좌표 구하기
    if get_center_of_bounding_box(coordinates_bounding_box) is not None:
        center_x, center_y = get_center_of_bounding_box(coordinates_bounding_box)
        # pk_print(string = rf'''center_x="{center_x}"  {'%%%FOO%%%' if LTA else ''}''')
        # pk_print(string = rf'''center_y="{center_y}"  {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''"text_coordinates = ({center_x}, {center_y})"''')
        return center_x, center_y
    return None


def reconnect_to_qcy_h3_anc_headset_via_bluetooth():  # toogle_to_qcy_h3_anc_headset_via_bluetooth 이게 더 작명이 나은것..
    from pkg_py.pk_colorful_cli_util import pk_print

    import time
    import inspect

    func_n = inspect.currentframe().f_code.co_name

    # Bluetooth 설정창 띄우기
    cmd = 'start ms-settings:bluetooth'
    cmd_to_os_like_person_as_admin(cmd=cmd)
    window_title_seg = "설정"
    timeout = 10
    start_time = time.time()
    while 1:
        if not is_window_opened(window_title_seg=window_title_seg):
            ensure_window_to_front(window_title_seg=window_title_seg)
        else:
            break
        pk_print(working_str=time.time() - start_time)
        if time.time() - start_time > timeout:
            break
        pk_sleep(seconds=0.5)

    # string 더블 클릭
    click_string(string="QCY H3 ANC HEADSET", doubleclick_mode=True)

    # string 더블 클릭
    import asyncio
    asyncio.run(shoot_custom_screenshot_via_asyncio())
    # click_img_via_autogui()

    # string 더블 클릭
    # click_string(string="연결", doubleclick_mode=True)
    pass


def kill_chrome_tab_duplicated():
    from pkg_py.pk_colorful_cli_util import pk_print

    chrome_tab_urls_processed = []  # 이미 처리된 URL을 저장하는 리스트
    loop_limit = 10
    loop_out_cnt = 0

    while 1:
        window_title = "Chrome"
        if is_window_opened(window_title_seg=window_title):
            ensure_window_to_front(window_title_seg=window_title)

        pk_print(working_str=rf'''loop_out_cnt="{loop_out_cnt}"  {'%%%FOO%%%' if LTA else ''}''')
        pk_print(working_str=rf'''loop_limit="{loop_limit}"  {'%%%FOO%%%' if LTA else ''}''')

        # 탭을 전환하고 URL을 가져옵니다.
        pk_press("ctrl", "l")
        pk_sleep(milliseconds=5)
        url_dragged = get_text_dragged()

        # 중복 여부 확인
        if url_dragged in chrome_tab_urls_processed:
            pk_print(working_str=rf'''URL already processed: "{url_dragged}"  {'%%%FOO%%%' if LTA else ''}''')
            pk_press("ctrl", "tab")  # 다음 탭으로 이동
            loop_out_cnt += 1
            if loop_out_cnt >= loop_limit:
                break
            continue

        # 다음 탭으로 전환 후 URL 가져오기
        pk_press("ctrl", "tab")
        pk_sleep(milliseconds=5)
        pk_press("ctrl", "l")
        pk_sleep(milliseconds=5)
        url_dragged_new = get_text_dragged()

        pk_print(working_str=rf'''url_dragged="{url_dragged}"  {'%%%FOO%%%' if LTA else ''}''')
        pk_print(working_str=rf'''url_dragged_new="{url_dragged_new}"  {'%%%FOO%%%' if LTA else ''}''')

        # 중복된 URL이면 탭 닫기
        if url_dragged == url_dragged_new:
            pk_print(working_str=rf'''Closing duplicate tab for URL: "{url_dragged}"  {'%%%FOO%%%' if LTA else ''}''')
            pk_press("ctrl", "w")  # 탭 닫기
            continue

        # 처리된 URL을 리스트에 추가
        chrome_tab_urls_processed.append(url_dragged)
        pk_print(working_str=rf'''chrome_tab_urls_processed="{chrome_tab_urls_processed}"  {'%%%FOO%%%' if LTA else ''}''')

        # 최대 반복 횟수 초과 시 종료
        loop_out_cnt += 1
        if loop_out_cnt >= loop_limit:
            break


def get_list_element_duplicated(working_list):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    items_duplicated = []
    seen = set()  # 이미 본 요소를 추적할 집합
    for item in working_list:
        if item in seen and item not in items_duplicated:
            items_duplicated.append(item)
        else:
            seen.add(item)
    return items_duplicated


def encode_via_pk_system(text_plain):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    text_plain = text_plain.replace("8", "2")
    text_plain = text_plain.replace("7", "3")
    text_plain = text_plain.replace("6", "4")
    text_plain = text_plain.replace("4", "6")
    text_plain = text_plain.replace("3", "7")
    text_plain = text_plain.replace("2", "8")
    return text_plain


def remove_block_hidden(driver):
    from pkg_py.pk_colorful_cli_util import pk_print

    from selenium.webdriver.common.by import By
    # driver.execute_script("""
    #     const backdrop = document.querySelector('.MuiBackdrop-root');
    #     if (backdrop) {
    #         backdrop.style.display = 'none';
    #     }
    # """)
    try:
        overlay = driver.find_element(By.CSS_SELECTOR, ".MuiModal-root")
        overlay.click()  # 가려진 요소 클릭으로 닫기
        pk_print(working_str="가려진 요소 닫기 성공")
    except Exception as e:
        print(f"가려진 요소 닫기 중 오류 발생: {e}")


def assist_to_analize_addup_issue():  # todo
    from pkg_py.pk_core_constants import D_PKG_TXT

    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_DOWNLOADS
    import inspect
    func_n = inspect.currentframe().f_code.co_name

    # 애드업 웹 로그인 및 검색
    # login_and_filter_and_export_addup(filter_vehicle_id_mode=True)

    # 파싱
    # parse_addup_from_issues_list_csv()

    def move_to_url(driver, url):
        expected_url = url
        while 1:
            current_url = driver.current_url
            pk_sleep(seconds=1)
            if current_url != expected_url:
                driver.get(url)
                print(f"URL 이동 성공 {url}")
            else:
                # 페이지 로딩 상태 확인
                try:
                    timeout = 10
                    WebDriverWait(driver, timeout).until(lambda d: d.execute_script("return document.readyState;") == "complete")
                    return
                except:
                    import inspect
                    import traceback
                    func_n = inspect.currentframe().f_code.co_name
                    stamp_func_n = rf'''[{func_n}()]'''
                    pk_print(f'''{stamp_func_n} {traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
                    pk_print(working_str="페이지 로딩에 실패", print_color='red')
                    return

    def write_user_input_by_tag_id(driver, tag_id, user_input):
        # dom 에서 확인
        wait = WebDriverWait(driver, 30)
        input_field = wait.until(
            EC.presence_of_element_located((By.ID, tag_id))  # 필드가 DOM에 존재하는지 확인
        )
        # 클릭 가능상태 확인
        WebDriverWait(driver, 30).until(
            EC.element_to_be_clickable((By.ID, tag_id))  # 클릭 가능 상태인지 확인
        )
        input_field.send_keys(user_input)

    def click_btn_by_btn_tag_text(driver, btn_text):
        # dom 에서 확인
        WebDriverWait(driver, 30).until(EC.presence_of_element_located((By.XPATH, f"//button[text()='{btn_text}']")))
        button = WebDriverWait(driver, 30).until(EC.element_to_be_clickable((By.XPATH, f"//button[text()='{btn_text}']")))
        button.click()

    def click_btn_by_tag_id(driver, tag_id):
        # dom 에서 확인
        WebDriverWait(driver, 30).until(EC.presence_of_element_located((By.ID, tag_id)))
        # 클릭 가능상태 확인
        dropdown_button = WebDriverWait(driver, 30).until(EC.element_to_be_clickable((By.ID, tag_id)))
        # dropdown_button = wait.until(EC.presence_of_element_located((By.ID, "targetModules")))
        # dropdown_button = driver.find_element(By.XPATH, "//div[@id='targetModules']")
        dropdown_button.click()

    # 애드업 웹 로그인 및 이슈검색 및 issue ? .csv 다운로드
    token_ip_addup_web = get_token_from_f_token(f_token=rf'{D_PKG_TXT}\token_ip_addup_web.txt', initial_str="")
    token_id_addup_web = get_token_from_f_token(f_token=rf'{D_PKG_TXT}\token_id_addup_web.txt', initial_str="")
    token_pw_addup_web = get_token_from_f_token(f_token=rf'{D_PKG_TXT}\token_pw_addup_web.txt', initial_str="")
    browser_debug_mode = True
    driver = get_driver_selenium(browser_debug_mode=browser_debug_mode)
    issues_list_csv = rf"{D_DOWNLOADS}/Issues_list.csv"

    # move to addup 웹 로그인
    move_to_url(driver, url=rf"http://{token_ip_addup_web}/login")
    write_user_input_by_tag_id(driver=driver, tag_id="userId", user_input=token_id_addup_web)
    write_user_input_by_tag_id(driver=driver, tag_id="password", user_input=token_pw_addup_web)
    click_btn_by_btn_tag_text(driver=driver, btn_text='LOGIN NOW')

    # Google 비밀번호저장 창 닫기 : fail
    # sleep(seconds=5)
    # window_title_seg = "ADDup - Chrome"
    # while 1:
    #     if not is_front_window_title(window_title_seg=window_title_seg):
    #         move_window_to_front(window_title_seg=window_title_seg)
    #     if is_front_window_title(window_title_seg=window_title_seg):
    #         break
    # press("shift", "tab")
    # press("shift", "tab")
    # press("enter", debug_mode=False)

    # Google 비밀번호저장 창 닫기 : fail
    # alert = driver.switch_to.alert
    # alert.dismiss()  # "취소" 버튼 클릭

    # Google 비밀번호저장 창 닫기 : fail
    # cancel_button = driver.find_element(By.XPATH, "//button[contains(text(), '취소')]")
    # cancel_button.click()

    # Google 비밀번호저장 창 닫기 : fail : selenium은 네이티브 팝업 제어 미지원, GPT 4.o
    # chrome_options.add_experimental_option("prefs", {
    #     "credentials_enable_service": False,  # 비밀번호 저장 서비스 비활성화
    #     "profile.password_manager_enabled": False  # 비밀번호 저장 팝업 비활성화
    # })

    # download Issues_list.csv
    move_to_url(driver, url=rf"http://{token_ip_addup_web}/issue")
    click_btn_by_btn_tag_text(driver=driver, btn_text='Show Filter')  # click Show Filter
    click_btn_by_tag_id(driver=driver, tag_id="targetModules")  # click 문제 모듈
    click_tag_by_tag_xpath(driver=driver, tag_name='li', tag_property='text', tag_property_value='영상')  # click 영상
    remove_block_hidden(driver)
    click_btn_by_tag_id(driver=driver, tag_id="resolutionStatuses")  # click 해결 여부
    click_tag_by_tag_xpath(driver=driver, tag_name='li', tag_property='text', tag_property_value='미해결')  # click 미해결
    remove_block_hidden(driver)
    click_tag_by_tag_xpath(driver=driver, tag_name='button', tag_property='text', tag_property_value='Search')  # click Search
    src_f = f'{D_DOWNLOADS}/Issues_list.csv'
    src_f = get_pnx_unix_style(src_f)
    if does_pnx_exist(pnx=src_f):
        # remove Issues_list.csv
        while 1:
            move_pnx_to_pk_recycle_bin(pnx=src_f)
            if not does_pnx_exist(pnx=src_f):
                break
    if not does_pnx_exist(pnx=src_f):
        while 1:
            # click Export
            if not does_pnx_exist(pnx=src_f):
                click_tag_by_tag_xpath(driver=driver, tag_name='button', tag_property='text', tag_property_value='Export')
            pk_sleep(milliseconds=500)
            if does_pnx_exist(pnx=src_f):
                break
    # todo : option : 필요 시 주석처리
    # driver.quit()

    open_pnx_by_ext(issues_list_csv)

    pk_print(working_str='line_order=', print_color='blue')
    line_order = input(":")
    issue_log_index_data = get_issue_log_index_data_from_f_csv(line_order=line_order, issues_list_csv=issues_list_csv)

    # 노션 이슈발생 템플릿
    print_template_for_notion_issue_reporting(line_order=line_order, issues_list_csv=issues_list_csv)

    # download the issue log
    pk_print(working_str=rf'''Could I proceed to download the issue log?  {'%%%FOO%%%' if LTA else ''}''', print_color='blue')
    input(f"{pk_get_colorful_working_str_with_stamp_enviromnet(func_n=func_n)} >")

    if isinstance(issue_log_index_data["_f_ 위치"], float):
        issue_log_index_data["_f_ 위치"] = ""
        # print_and_open_original_log_position(vehicle_id='58_SEJONG_APOLLO_900_2', area_id='09_Sejong', course_id='05_BRT_Osong')
        steering_date = input("주행일자를 yymmdd 형태로 입력하세요:")
        steering_date = steering_date.strip()
        print_and_open_original_log_position(vehicle_id=issue_log_index_data["차량"], area_id=issue_log_index_data["지역"], course_id=issue_log_index_data["코스"], steering_date=steering_date)
        download_issue_log_f(issue_log_index_data=issue_log_index_data, original_log=True)
    else:
        download_issue_log_f(issue_log_index_data=issue_log_index_data)

    # download issue log
    try:
        quit_autoa2z_drive()
    except:
        import ipdb
        ipdb.set_trace()

    # run
    try:
        run_and_login_acu_update_v3_exe_and_run_autoa2zdrive_release_exe(issue_log_index_data=issue_log_index_data)
    except:
        import ipdb
        ipdb.set_trace()

    run_autoa2z_drive()


def click_mouse_left_display_center():
    import pyautogui
    screen_w, screen_h = pyautogui.size()
    center_x = screen_w // 2
    center_y = screen_h // 2
    move_mouse(x_abs=center_x, y_abs=center_y)
    click_mouse_left_btn(x_abs=center_x, y_abs=center_y)


def click_tag_by_tag_xpath(driver, tag_name, tag_property, tag_property_value):
    from pkg_py.pk_colorful_cli_util import pk_print

    timeout = 10
    try:
        # Lazy Import (이 시점에 모듈을 불러옵니다)
        from selenium.webdriver.common.by import By
        from selenium.webdriver.support.ui import WebDriverWait
        from selenium.webdriver.support import expected_conditions as EC
        from selenium.common.exceptions import ElementClickInterceptedException

        # 페이지가 로딩될 때까지 대기
        WebDriverWait(driver, timeout).until(lambda d: d.execute_script('return document.readyState') == 'complete')

        # 태그가 DOM에 존재하고 표시될 때까지 대기
        tag = WebDriverWait(driver, timeout).until(EC.presence_of_element_located((By.XPATH, f"//{tag_name}[{tag_property}()='{tag_property_value}']")))

        # 태그가 클릭 가능할 때까지 대기
        tag = WebDriverWait(driver, timeout).until(EC.element_to_be_clickable((By.XPATH, f"//{tag_name}[{tag_property}()='{tag_property_value}']")))

        # 클릭을 방해하는 요소가 있을 경우, 배경을 클릭하거나 강제로 클릭을 시도
        try:
            tag.click()  # 클릭 시도
            print(f"태그 '{tag_name}' 속성 '{tag_property}={tag_property_value}' 클릭 완료.")
        except ElementClickInterceptedException:
            # 클릭 방해 요소가 있을 경우, 배경 요소 클릭 또는 배경 숨기기
            pk_print(working_str="클릭 방해 요소 발견, 배경을 클릭하거나 숨기려 시도합니다.")
            remove_block_hidden(driver=driver)
            # driver.execute_script("document.querySelector('.MuiBackdrop-root').style.display = 'none';")  # 배경 숨기기
            tag.click()  # 다시 클릭 시도
            print(f"태그 '{tag_name}' 속성 '{tag_property}={tag_property_value}' 클릭 완료.")

    except Exception as e:
        import traceback
        pk_print(f"{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}", print_color='red')
        print(f"태그 '{tag_name}' 속성 '{tag_property}={tag_property_value}' 클릭 실패.")


def parse_addup_from_issues_list_csv():  # todo
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_DOWNLOADS

    issues_list_csv = rf"{D_DOWNLOADS}/Issues_list.csv"
    f_csv = issues_list_csv
    f_csv = get_pnx_unix_style(f_csv)

    open_pnx_by_ext(f_csv)

    pk_print(working_str='line_order=', print_color='blue')
    line_order = input(":")
    issue_log_index_data = get_issue_log_index_data_from_f_csv(line_order=line_order, issues_list_csv=issues_list_csv)

    import ipdb
    ipdb.set_trace()

    # 노션 이슈발생 템플릿
    print_template_for_notion_issue_reporting(line_order=line_order, issues_list_csv=issues_list_csv)


def should_i_make_directory_for_a2z_with_timestamp_as_gui_v2():
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print

    import inspect
    from pkg_py.pk_interface_graphic_user import should_i_do

    func_n = inspect.currentframe().f_code.co_name

    try:
        work_n = None
        pnx = None
        txt_clicked = None
        function = None
        txt_written = None
        txt_clicked, function, txt_written = should_i_do(
            prompt="업무명을 입력해주세요",
            btn_list=["입력", "n"],
            function=None,
            auto_click_negative_btn_after_seconds=30,
            title=f"{func_n}()",
            input_box_mode=True,
        )
        if txt_clicked != "입력":
            return
        work_n = txt_written
        work_n = work_n.strip()
        work_n = work_n.replace("\"", "")
        pk_print(
            f'''[ {get_time_as_('now')} ] work_ns={work_n}  {'%%%FOO%%%' if LTA else ''}''')
        if work_n == "":
            pk_print(
                f'''[ {get_time_as_('now')} ] work_n가 입력되지 않았습니다  {'%%%FOO%%%' if LTA else ''}''')
            return

        from pkg_py.pk_interface_graphic_user import should_i_do
        txt_clicked, function, txt_written = should_i_do(
            prompt="어느 경로에 만들까요?",
            btn_list=["입력", "n"],
            function=None,
            auto_click_negative_btn_after_seconds=30,
            title=f"{func_n}()",
            input_box_mode=True,
        )
        if txt_clicked != "입력":
            return
        pnx = txt_written
        pnx = get_pnx_os_style(pnx)
        if is_pnx_required(pnx):
            return
        pk_print(working_str=rf'''pnx="{pnx}"  {'%%%FOO%%%' if LTA else ''}''')
        pk_print(working_str=rf'''work_n="{work_n}"  {'%%%FOO%%%' if LTA else ''}''')
        timestamp = get_time_as_("yyyy MM dd (weekday) HH mm")
        pnx_new = rf"{pnx}\{timestamp} {work_n}"
        pk_print(working_str=rf'''pnx_new="{pnx_new}"  {'%%%FOO%%%' if LTA else ''}''')
        ensure_pnx_made(pnx=pnx_new, mode="d")
        pnx = pnx_new
        cmd = rf'explorer "{pnx}"'
        cmd_to_os(cmd=cmd, mode="a")
        return
    except:
        pk_print(f"{traceback.format_exc()}")


# [def send]
# 이미 exec  중인 이벤트 루프에서 exec  가능하도록 설정
import nest_asyncio

nest_asyncio.apply()


async def move_f_via_telegram_bot(f):
    from pkg_py.pk_colorful_cli_util import pk_print
    import asyncio
    import traceback
    from telegram import Bot, Update
    from telegram.ext import Application, MessageHandler, filters, CallbackContext
    from pkg_py.pk_core_constants import D_PKG_TXT

    # @BotFather
    # /newbot
    # pk_system_t_bot
    # pk_system_bot
    # t.me/pk_bot
    # 76~yIXuSimQo~
    # /start
    # hello?

    # 텔레그램 토큰 로드
    token_telegram = get_token_from_f_token(f_token=rf'{D_PKG_TXT}\token_telegram.txt', initial_str="")

    # 채팅 ID f
    f_token = rf'{D_PKG_TXT}\token_telegram_chat_id.txt'
    token_telegram_chat_id = get_token_from_f_token(f_token=f_token, initial_str="")
    pk_print(f"token_telegram_chat_id={token_telegram_chat_id}")

    # Chat ID 저장 핸들러
    async def get_telegram_chat_id(update: Update, context: CallbackContext):
        nonlocal token_telegram_chat_id

        telegram_chat_id = str(update.message.chat_id)

        if not token_telegram_chat_id:
            token_telegram_chat_id = telegram_chat_id
            with open(f_token, "w") as f_obj:
                f_obj.write(token_telegram_chat_id)

            await update.message.reply_text(f" 당신의 CHAT_ID가 저장되었습니다: {token_telegram_chat_id}")
            print(f" 저장된 CHAT_ID: {token_telegram_chat_id}")
        else:
            await update.message.reply_text(f"📌 저장된 CHAT_ID: {token_telegram_chat_id}")

    # 텔레그램 봇 exec  (run_polling을 백그라운드에서 exec )
    async def start_telegram_bot():
        try:
            application = Application.builder().token(token_telegram).build()
            application.add_handler(MessageHandler(filters.TEXT | filters.COMMAND, get_telegram_chat_id))
            print("텔레그램 봇 exec  중...")

            # 🔹 run_polling을 백그라운드에서 exec 
            await application.run_polling()
        except Exception as e:
            pk_print(f" 텔레그램 봇 exec  중 오류 발생: {e}", print_color='red')
            traceback.print_exc()
            import sys
            traceback.print_exc(file=sys.stdout)

    # f 전송 함수
    async def move_f_to_telegram_chat(f):
        nonlocal token_telegram_chat_id
        if not token_telegram_chat_id:
            print("❌ CHAT_ID가 설정되지 않았습니다. 먼저 봇에게 메시지를 보내세요.")
            return

        bot = Bot(token=token_telegram)

        try:
            with open(f, "rb") as file:
                await bot.send_chat_action(chat_id=token_telegram_chat_id, action="upload_document")
                await bot.send_document(chat_id=token_telegram_chat_id, document=file)
            print(f"📤 f 전송 완료: {f}")
        except Exception as e:
            pk_print(f" f 전송 중 오류 발생: {e}", print_color='red')
            traceback.print_exc()
            import sys
            traceback.print_exc(file=sys.stdout)

    # 봇 exec 과 f 전송을 동시에 진행하도록 수정
    try:
        bot_task = asyncio.create_task(start_telegram_bot())  # 백그라운드 exec 
        await asyncio.sleep(3)  # 봇이 exec 될 시간을 줌
        await move_f_to_telegram_chat(f)  # f 전송
    except Exception as e:
        pk_print(f" 전체 exec  중 오류 발생: {e}", print_color='red')
        traceback.print_exc()
        import sys
        traceback.print_exc(file=sys.stdout)


async def move_f_via_telegram_bot_v3(f):
    import os
    import traceback
    from telethon import TelegramClient, events
    # telethon initial login
    # Please enter your phone (or bot token):
    # +821012345678 #ex
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PKG_TXT

    # [done] https://my.telegram.org에서 API ID 및 API Hash 발급

    async def get_telegram_chat_id(f_token, telegram_app_api_id, telegram_app_api_hash, telegram_session_name):
        from telethon import TelegramClient, events
        telegram_chat_id = None
        async with TelegramClient(telegram_session_name, telegram_app_api_id, telegram_app_api_hash) as client:
            print("Telegram 클라이언트 연결됨. 메시지를 기다리는 중...")

            # 사용자가 메시지를 보내면 chat_id 저장
            @client.on(events.NewMessage)
            async def handler(event):
                telegram_chat_id = str(event.chat_id)
                with open(f_token, "w") as f:
                    f.write(telegram_chat_id)
                print(f"새로운 CHAT_ID 저장됨: {telegram_chat_id}")
                await event.reply(f"CHAT_ID가 저장되었습니다: {telegram_chat_id}")

            await client.run_until_disconnected()
            return telegram_chat_id

    telegram_app_api_id = get_token_from_f_token(f_token=rf'{D_PKG_TXT}\token_telegram_app_api_id.txt', initial_str="24792591")  # App api_id
    telegram_app_api_hash = get_token_from_f_token(f_token=rf'{D_PKG_TXT}\token_telegram_app_api_hash.txt', initial_str="b5d509dcd30803fc27bd51ae573dd5cb")  # App api_hash
    telegram_session_name = get_token_from_f_token(f_token=rf'{D_PKG_TXT}\token_telegram_session_name.txt', initial_str="pk_telegram_bot_session")  # 세션명은 임의부여 가능
    f_token = rf"{D_PKG_TXT}\token_telegram_chat_id.txt"
    token_telegram_chat_id = get_token_from_f_token(f_token=f_token, initial_str="") or await get_telegram_chat_id(f_token=f_token, telegram_app_api_id=telegram_app_api_id, telegram_app_api_hash=telegram_app_api_hash, telegram_session_name=telegram_session_name)

    async with TelegramClient(telegram_session_name, telegram_app_api_id, telegram_app_api_hash) as client:
        # 처음 exec  시, telegram 을 통해서 token_telegram_chat_id 을 f_token 에 저장
        @client.on(events.NewMessage)
        async def handler(event):
            nonlocal token_telegram_chat_id
            if token_telegram_chat_id is None:
                token_telegram_chat_id = event.chat_id
                token_telegram_chat_id = get_token_from_f_token(f_token=rf"{D_PKG_TXT}\token_telegram_chat_id.txt", initial_str=token_telegram_chat_id)
                await event.reply(f"CHAT_ID가 저장되었습니다: {token_telegram_chat_id}")

        # f 전송
        if token_telegram_chat_id:
            try:
                f_size = os.path.getsize(f)
                pk_print(f"📂 전송할 f 크기: {f_size / (1024 * 1024):.2f}MB")

                # 2GB 초과 f은 전송 불가
                if f_size > 2 * 1024 * 1024 * 1024:
                    pk_print("❌ f 크기가 2GB를 초과하여 전송할 수 없습니다.", print_color='red')
                    return

                await client.send_file(token_telegram_chat_id, f)
                pk_print(f"📤 f 전송 완료: {f}")
            except Exception as e:
                pk_print(f"❌ f 전송 중 오류 발생: {e}", print_color='red')
                traceback.print_exc()
                import sys
                traceback.print_exc(file=sys.stdout)
        else:
            pk_print("⚠ 채팅 ID가 설정되지 않았습니다. 먼저 봇에게 메시지를 보내주세요.", print_color="yellow")

        await client.run_until_disconnected()


# [def compress]
def compress_pnx(src, dst, with_timestamp=1):
    return compress_pnx_via_rar(src=src, dst=dst, with_timestamp=with_timestamp)


def compress_pnx_via_rar(src, dst, with_timestamp=1):
    import os.path
    from datetime import datetime
    from pkg_py.pk_core_constants import Encoding
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import PK_BLANK
    import inspect

    # todo ensure wsl

    func_n = inspect.currentframe().f_code.co_name

    # 전처리
    # src = get_pnx_windows_style(pnx=src)
    src = get_pnx_unix_style(pnx=src)
    dst = get_pnx_unix_style(pnx=dst)

    # 정의
    d_working = get_d_working()

    pnx = src
    p = get_p(pnx)
    n = get_n(pnx)
    nx = get_nx(pnx)
    x = get_x(pnx)
    x = x.lstrip('.')  # 확장자에서 점 remove

    rar = "rar"  # via rar
    timestamp = ""
    if with_timestamp:
        timestamp = rf"{PK_BLANK}{datetime.now().strftime('%Y %m %d %H %M %S')}"
    pn_rar = rf"{p}/{n}.{rar}"
    dst_nx_rar = rf"{dst}/{n}.{rar}"
    dst_nx_timestamp_rar = rf"{dst}/{n}{timestamp}.{rar}"

    # 로깅
    # pk_print(str_working=rf'''dst="{dst}"  {'%%%FOO%%%' if LTA else ''}''')
    # pk_print(str_working=rf'''pnx="{pnx}"  {'%%%FOO%%%' if LTA else ''}''')
    # pk_print(str_working=rf'''p="{p}"  {'%%%FOO%%%' if LTA else ''}''')
    # pk_print(str_working=rf'''n="{n}"  {'%%%FOO%%%' if LTA else ''}''')
    # pk_print(str_working=rf'''nx="{nx}"  {'%%%FOO%%%' if LTA else ''}''')
    # pk_print(str_working=rf'''x="{x}"  {'%%%FOO%%%' if LTA else ''}''')
    # pk_print(str_working=rf'''dst_nx_rar="{dst_nx_rar}"  {'%%%FOO%%%' if LTA else ''}''')
    # pk_print(str_working=rf'''dst_nx_timestamp_rar="{dst_nx_timestamp_rar}"  {'%%%FOO%%%' if LTA else ''}''')
    # pk_print(string = rf'''dst_nx_timestamp_rar="{dst_nx_timestamp_rar}"  {'%%%FOO%%%' if LTA else ''}''')

    # 삭제
    move_pnx_to_pk_recycle_bin(pnx=pn_rar)

    # 생성
    ensure_pnx_made(pnx=dst, mode='d')

    # 이동
    os.chdir(p)

    # 압축
    wsl_pn_rar = get_pnx_wsl_unix_style(pnx=pn_rar)
    cmd = f'wsl rar a "{wsl_pn_rar}" "{nx}"'
    cmd_to_os(cmd, encoding=Encoding.CP949)

    # copy
    copy_pnx_with_overwrite(pnx=pn_rar, dst=dst)

    # rename
    rename_pnx(src=dst_nx_rar, pnx_new=dst_nx_timestamp_rar)

    pk_print(working_str=rf'''wsl_pn_rar="{wsl_pn_rar}"  {'%%%FOO%%%' if LTA else ''}''')
    dst_nx = rf"{dst}/{nx}"
    pk_print(working_str=rf'''desktop_nx="{dst_nx}"  {'%%%FOO%%%' if LTA else ''}''')

    # remove
    move_pnx_to_pk_recycle_bin(pnx=dst_nx)
    move_pnx_to_pk_recycle_bin(pnx=dst_nx_rar)

    # chdir
    os.chdir(d_working)

    # logging
    pk_print(working_str=rf'''dst_nx_rar="{dst_nx_rar}"  {'%%%FOO%%%' if LTA else ''}''')
    pk_print(working_str=rf'''[{func_n}] dst_nx_timestamp_rar="{dst_nx_timestamp_rar}"  {'%%%FOO%%%' if LTA else ''}''', print_color='green')

    return dst_nx_timestamp_rar


# [def copy]
# def copy_pnx_with_overwrite_deprecated(src, dst):  # 같은이름의 f이 이미 있으면 copy 하지 않음
#     import os.path
#     import shutil
#     import traceback
#     from pkg_py.pk_colorful_cli_util import pk_print, pk_print
#     from pkg_py.pk_core_constants import PROJECT_D
#
#     func_n = inspect.currentframe().f_code.co_name
#
#     try:
#         src = get_pnx_os_style(pnx=src)
#         src = src.replace("\"", "")
#         if src.strip() == "":
#             return
#         pnx_dirname = os.path.dirname(src)
#         pnx_basename = os.path.basename(src).split(".")[0]
#         pnx_zip = rf'{pnx_dirname}\{pnx_basename}.zip'
#         pnx_zip_new = rf"{dst}\{get_nx(pnx=pnx_zip)}"
#
#         # 로깅
#         pk_print(f"pnx : {src}")
#         pk_print(f"pnx_zip : {pnx_zip}")
#         pk_print(f"pnx_zip_new : {pnx_zip_new}")
#
#         # 삭제
#         if does_pnx_exist(pnx=pnx_zip_new):
#             move_pnx_to_trash_bin(src=pnx_zip_new)
#
#         # 압축
#         compress_pnx_via_zip(f_zip=pnx_zip, pnx=src)
#
#         # 이동
#         try:
#             shutil.move(src=pnx_zip, dst=dst)
#         except:
#             pk_print(f"{traceback.format_exc()}")
#
#         # 압축해제
#         decompress_pnx_via_zip(pnx=pnx_zip_new)
#
#         # 삭제
#         move_pnx_to_trash_bin(src=pnx_zip_new)
#     except:
#         pk_print(f"{traceback.format_exc()}")
#         os.chdir(PROJECT_D)


def copy_pnx_with_overwrite(pnx, dst):
    # 같은이름의 f이 이미 있으면 copy 하지 않음

    import shutil
    import traceback

    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PROJECT
    try:
        # shutil.copy2(pnx, dst)  # shutil.copy2 copies the file and metadata, overwrites if exists # 사용중인 f에 대해서는 권한문제있어서 복사불가한 방식
        # cmd=f'copy "{pnx}" "{dst}"' # d 복사안됨
        # cmd=f'xcopy /E /H /K /Y "{pnx}" "{dst}"'
        # cmd=f'robocopy "{pnx}" "{dst}" /E /Z /R:3 /W:5 /COPYALL /DCOPY:T'
        # cmd=f'robocopy "{pnx}" "{dst}" /E /Z /R:3 /W:5 /COPY:DATSOU /DCOPY:T'
        # cmd=f'runas /user:Administrator robocopy "{pnx}" "{dst}" /E /Z /R:3 /W:5 /COPY:DATSOU /DCOPY:T'
        # cmd=rf'powershell -cmd "Start-Process cmd -ArgumentList \'/c robocopy \"{pnx}\" \"{dst}\" /E /Z /R:3 /W:5 /COPY:DATSOU /DCOPY:T\' -Verb runAs"'
        # cmd=rf'powershell -cmd "Start-Process cmd -ArgumentList \'/c xcopy \\"{pnx}\\" \\"{dst}\\" "'
        # cmd=rf'powershell -cmd "Start-Process cmd -ArgumentList \'/c xcopy \\"{pnx}\\" \\"{dst}\\" /E /H /K /Y\' -Verb runAs"'
        # subprocess.run(cmd, shell=True, check=True)
        # press("enter", interval=0.6)
        pnx = get_pnx_os_style(pnx=pnx)
        pnx = pnx.replace("\"", "")
        if pnx.strip() == "":
            pk_print(working_str=rf''' {'%%%FOO%%%' if LTA else ''}''', print_color='red')
            return
        pnx_p = get_p(pnx)
        pnx_n = get_n(pnx)
        f_zip = rf'{pnx_p}/{pnx_n}.zip'
        f_zip = get_pnx_os_style(pnx=f_zip)
        f_zip_new = rf"{dst}/{get_nx(pnx=f_zip)}"
        f_zip_new = get_pnx_os_style(pnx=f_zip_new)

        # remove
        if does_pnx_exist(pnx=f_zip_new):
            move_pnx_to_pk_recycle_bin(pnx=f_zip_new)

        # compress
        compress_pnx_via_bz_exe(pnx=pnx, f_zip=f_zip)

        # move
        shutil.move(src=f_zip, dst=dst)

        # decompress
        pk_decompress_f_via_zip(f=f_zip_new)

        # remove
        move_pnx_to_pk_recycle_bin(pnx=f_zip_new)
    except:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')

        pk_chdir(D_PROJECT)


def make_shellscript_version_new_via_hard_coded():
    import inspect

    func_n = inspect.currentframe().f_code.co_name

    make_shellscript_version_new_via_hard_coded_v_1_0_1()
    pass


def make_shellscript_version_new_via_hard_coded_v_1_0_0():
    import inspect

    func_n = inspect.currentframe().f_code.co_name
    import os.path
    from pkg_py.pk_colorful_cli_util import pk_print

    import os
    import shutil
    import re

    def get_f_next_versioned(f_nx):
        import inspect

        func_n = inspect.currentframe().f_code.co_name

        # f 이름과 확장자를 분리
        f_n, f_x = os.path.splitext(f_nx)

        # 현재 _d_에 있는 모든 f 리스트
        f_list = os.listdir("..")

        # 정규표현식으로 "v1.x.y" 형태의 버전을 찾기
        f_versioned_list = [f for f in f_list if re.match(fr"{re.escape(f_n)}_v\d+\.\d+\.\d+{re.escape(f_x)}", f)]

        if f_versioned_list:
            # 최신 버전을 찾기 위해 버전별로 분리하여 정렬
            latest_version = max(f_versioned_list, key=lambda x: list(map(int, re.findall(r"\d+", x)[-3:])))
            major, minor, patch = map(int, re.findall(r"\d+", latest_version)[-3:])

            # 버전을 업데이트, 다음 패치 버전 생성
            patch += 1
            next_version = f"{major}.{minor}.{patch}"
        else:
            # 기존 버전이 없으면 기본 v1.0.0으로 생성
            next_version = "1.0.0"

        return f"{f_n}_v{next_version}{f_x}"

    def copy_with_version(file_pnx):

        import inspect
        func_n = inspect.currentframe().f_code.co_name

        # f 유효성 검사
        if not os.path.isfile(file_pnx):
            pk_print(working_str=rf'''file_pnx="{file_pnx}"  {'%%%FOO%%%' if LTA else ''}''')
            return

        # 복사
        file_pnx_new = get_f_next_versioned(os.path.basename(file_pnx))
        shutil.copy2(file_pnx, file_pnx_new)
        pk_print(working_str=rf'''file_pnx_new="{file_pnx_new}"  {'%%%FOO%%%' if LTA else ''}''')

    # 절대 경로를 사용하여 대상 f의 절대 경로를 입력
    file_pnxs = [
        os.path.expanduser(r"~/Downloads/pk_working/pk_system/vpc_info_collector.sh"),
        os.path.expanduser(r"~/Downloads/pk_working/pk_system/pk_ip_connection_update_for_114.sh"),
        os.path.expanduser(r"~/Downloads/pk_working/pk_system/pk_ip_connection_update_for_front.sh"),
        os.path.expanduser(r"~/Downloads/pk_working/pk_system/pk_ip_connection_update_for_rear.sh"),
        os.path.expanduser(r"~/Downloads/pk_working/pk_system/pk_ip_connection_update_for_reset.sh"),
    ]

    # 각 f을 복사하여 버전별로 관리
    for file_pnx in file_pnxs:
        copy_with_version(file_pnx)


def make_shellscript_version_new_via_hard_coded_v_1_0_1():
    import os.path
    import re
    import shutil
    from pkg_py.pk_core_constants import D_ARCHIVED
    import inspect
    func_n = inspect.currentframe().f_code.co_name

    def get_f_next_versioned(f_nx):
        import inspect
        func_n = inspect.currentframe().f_code.co_name

        name, ext = os.path.splitext(f_nx)
        files = os.listdir("..")

        # 정규표현식으로 "v1.x.y" 형태의 버전을 찾기
        versioned_files = [f for f in files if re.match(fr"{re.escape(name)}_v\d+\.\d+\.\d+{re.escape(ext)}", f)]

        if versioned_files:
            latest_version = max(versioned_files, key=lambda x: list(map(int, re.findall(r"\d+", x)[-3:])))
            major, minor, patch = map(int, re.findall(r"\d+", latest_version)[-3:])
            patch += 1
            next_version = f"{major}.{minor}.{patch}"
        else:
            next_version = "1.0.0"

        return f"{name}_v{next_version}{ext}"

    def copy_with_version(f):
        import inspect
        func_n = inspect.currentframe().f_code.co_name

        if not os.path.isfile(f):
            print(f"{f} f을 찾을 수 없습니다.")
            return

        f_new = get_f_next_versioned(os.path.basename(f))
        shutil.copy2(f, f_new)
        print(f"''{f}'를  {f_new}'로 복사되었습니다.")
        manage_versions(os.path.basename(f))

    def manage_versions(original_filename):
        import inspect
        func_n = inspect.currentframe().f_code.co_name

        name, ext = os.path.splitext(original_filename)
        files = os.listdir("..")

        # 해당 f의 모든 버전 f을 찾기

        versioned_files = sorted(
            [f for f in files if re.match(fr"{re.escape(name)}_v\d+\.\d+\.\d+{re.escape(ext)}", f)],
            key=lambda x: list(map(int, re.findall(r"\d+", x)[-3:]))
        )

        # 최신 버전 f을 제외한 나머지 버전 f을 archive _d_로 이동
        dst = D_ARCHIVED
        if len(versioned_files) > 1:
            latest_version = versioned_files[-1]
            os.makedirs(dst, exist_ok=True)

            for f in versioned_files[:-1]:
                shutil.move(f, dst)
                print(f"'{f}' f이 '{dst}' _d_로 이동되었습니다.")

    file_pnxs = [  # 상대경로
        os.path.expanduser(r"~/Downloads/pk_working/pk_system/vpc_info_collector.sh"),
        os.path.expanduser(r"~/Downloads/pk_working/pk_system/pk_ip_connection_update_for_114.sh"),
        os.path.expanduser(r"~/Downloads/pk_working/pk_system/pk_ip_connection_update_for_front.sh"),
        os.path.expanduser(r"~/Downloads/pk_working/pk_system/pk_ip_connection_update_for_rear.sh"),
        os.path.expanduser(r"~/Downloads/pk_working/pk_system/pk_ip_connection_update_for_reset.sh"),
        os.path.expanduser(r"~/Downloads/pk_working/pk_system/pk_evm_updater_for_front.sh"),
        # os.path.expanduser(r"~/Downloads/pk_working/pk_system/pk_evm_updater_for_rear.sh"),
    ]

    for file_pnx in file_pnxs:
        copy_with_version(file_pnx)

    print_iterable_as_vertical(item_iterable=file_pnxs, item_iterable_n="다운로드완료")


def gather_pnxs_useless_at_tree(src, mode):
    from pkg_py.pk_colorful_cli_util import pk_print

    pk_print(working_str=rf'''src="{src}"  {'%%%FOO%%%' if LTA else ''}''')
    pk_print(working_str=rf'''mode="{mode}"  {'%%%FOO%%%' if LTA else ''}''')

    if mode == 'd':
        # gather_pnxs_useless(src=src, debug_mode=True) #쓸라면 테스트 필요
        pass

    if mode == 'f':
        gather_f_useless_at_tree(d_working=src)


def gather_pnxs_empty_at_tree(d_src):
    import inspect
    func_n = inspect.currentframe().f_code.co_name

    gather_empty_d(d_working=d_src)


def collect_row_data_from_csv(line_order, issues_list_csv):
    df = get_df_from_issues_list_csv(issues_list_csv)
    columns_required = df.columns.tolist()

    data_required = {}
    line_order = int(line_order)
    nth_row = get_nth_row(df, n=line_order)

    if nth_row is not None:
        for col in columns_required:
            if col in df.columns:
                data_required[col] = nth_row[col]

    return data_required


def get_issue_log_index_data_from_f_csv(line_order, issues_list_csv):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import UNDERLINE

    df = get_df_from_issues_list_csv(issues_list_csv)
    columns_required = df.columns.tolist()
    data_required = {}
    line_order = int(line_order)
    nth_row = get_nth_row(df, n=line_order)
    if nth_row is not None:
        pk_print(working_str=rf'''{UNDERLINE}n="{line_order}"  {'%%%FOO%%%' if LTA else ''}''')
        for col in columns_required:
            if col in df.columns:  # 열이 존재하는 경우만 출력 # todo get은 get 기능만 출력은 따로..
                pk_print(f"{col}: {nth_row[col]}")
                # 필요한 것만 추가
                if col == "_f_ 위치":
                    data_required["_f_ 위치"] = nth_row[col]
                if col == "SW 버전":
                    data_required["SW 버전"] = nth_row[col]
                if col == "차량":
                    data_required["차량"] = nth_row[col]
                if col == "지역":
                    data_required["지역"] = nth_row[col]
                if col == "주행일자":
                    data_required["주행일자"] = nth_row[col]
                if col == "코스":
                    data_required["코스"] = nth_row[col]
            else:
                print(f"{col}: N/A")  # 열이 없는 경우 기본값 출력
                # data_required["차량아이디코드번호"] =
            # print(f"'차량아이디코드번호='{nth_row[col]}'") # 데이터 전처리하여 추출 및 딕셔너리 data_required에 추가
    return data_required


def download_issue_log_f(issue_log_index_data, original_log=False):
    import re
    from pkg_py.pk_colorful_cli_util import pk_print

    # 전처리
    if isinstance(issue_log_index_data["_f_ 위치"], float):
        issue_log_index_data["_f_ 위치"] = ""

    issue_file_name = issue_log_index_data["_f_ 위치"].split('/')[-1]

    def get_origin_log_file_name(issue_file_name):
        # 정규식 패턴 정의: "_숫자(최대 2자리)_VIDEO"
        pattern = r"_\d{1,2}_VIDEO"
        original_filename = re.sub(pattern, "", issue_file_name)
        return original_filename

    origin_log_file_name = get_origin_log_file_name(issue_file_name)
    issue_log_index_data["주행일자"] = issue_log_index_data["_f_ 위치"].split('/')[0]
    issue_log_index_data["_f_ 위치"] = issue_log_index_data["_f_ 위치"].replace("/", f"\\")

    src = rf"\\192.168.1.33\01_Issue\{issue_log_index_data["_f_ 위치"]}"
    pk_print(working_str=rf'''src="{src}"  {'%%%FOO%%%' if LTA else ''}''')
    if original_log == True:
        src = rf"\\192.168.1.33\02_Orignal\{issue_log_index_data["차량"]}\{issue_log_index_data["지역"]}\{issue_log_index_data["주행일자"]}\{issue_log_index_data["코스"]}\{origin_log_file_name}"
        pk_print(working_str=rf'''src="{src}"  {'%%%FOO%%%' if LTA else ''}''')
        return

    # pause()
    dst = rf"C:\log"
    cmd = rf"copy {src} {dst}"
    src_nx = get_nx(pnx=src)
    src_new = rf"{dst}\{src_nx}"

    while 1:
        if does_pnx_exist(pnx=src_new):
            pk_print(working_str=rf'''{src_new} 가 이미 있습니다."  {'%%%FOO%%%' if LTA else ''}''')
            break
        else:
            if not does_pnx_exist(pnx=src_new):
                cmd_to_os(cmd=cmd, mode="a")
                pk_print(working_str=rf'''이슈데이터 다운로드 완료 "{src_new}"  {'%%%FOO%%%' if LTA else ''}''', print_color='blue')
                return


# def download_torrent_magnet_from_nyaa_si(string_to_search, driver_selenium, exclude_elements_all, include_elements_any, include_elements_all):
#     func_n = inspect.currentframe().f_code.co_name
#     pk_print(str_working=rf'''{UNDERLINE}{func_n}()  {'%%%FOO%%%' if LTA else ''}''', print_color='blue')
#     f_func_n_txt = rf'{PROJECT_D}\pkg_txt\{func_n}.txt'
#     query = urllib.parse.quote(f"{string_to_search}")
#     url = f'https://nyaa.si/?f=0&c=0_0&q={query}'
#     url_decoded = get_str_url_decoded(string=url)
#     driver_selenium.get(url)
#
#     # 페이지 소스 RAW
#     page_src = driver_selenium.page_source  # page_src={page_src}  {'%%%FOO%%%' if LTA else ''}''')
#
#     soup = BeautifulSoup(page_src, "html.parser")
#
#     titles = []
#     magnets = []
#
#     string_to_search = string_to_search
#     string_to_search = get_str_removed_last_digit(string_to_search)
#     string_to_search = string_to_search.strip()
#
#     lines = soup.find_all(name="a")
#     for line in lines:
#         magnet = line.get('href')
#         if magnet:
#             magnets.append(magnet)
#     # data = get_dict_removed_element_duplicated(item_dict=data)
#
#     pk_print(str_working=rf'''url="{url}"  {'%%%FOO%%%' if LTA else ''}''')
#     pk_print(str_working=rf'''string_to_search="{string_to_search}"  {'%%%FOO%%%' if LTA else ''}''')
#     pk_print(str_working=rf'''url_decoded="{url_decoded}"  {'%%%FOO%%%' if LTA else ''}''')
#
#     for magnet in magnets:
#         if is_regex_in_string(string=get_str_url_decoded(magnet), regex=string_to_search, debug_mode=False):
#             # pk_print(string = rf'''get_str_url_decoded(magnet)="{get_str_url_decoded(magnet)}"  {'%%%FOO%%%' if LTA else ''}''')
#             # if is_regex_in_string(string=href, regex="magnet*", with_case_ignored=False, debug_mode=False):
#             exclude_check = not any(element in get_str_url_decoded(magnet) for element in exclude_elements_all)
#             include_all_check = all(element in get_str_url_decoded(magnet) for element in include_elements_all)
#             include_any_check = any(element in get_str_url_decoded(magnet) for element in include_elements_any)
#
#             # 필터링 조건 평가
#             if (
#                     not exclude_check and
#                     include_all_check and
#                     include_any_check
#             ):
#                 # 결과 출력 및 브라우저 열기
#                 pk_print(str_working=rf'''get_str_url_decoded(magnet)="{get_str_url_decoded(magnet)}"  {'%%%FOO%%%' if LTA else ''}''')
#                 webbrowser.open(magnet)

def get_torrent_magnets_set_from_nyaa_si(title_to_search, driver_selenium, exclude_elements_all=None, include_elements_any=None, include_elements_all=None):
    import urllib.parse
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PROJECT, UNDERLINE
    import inspect
    exclude_elements_all = exclude_elements_all or []
    include_elements_any = include_elements_any or []
    include_elements_all = include_elements_all or []
    func_n = inspect.currentframe().f_code.co_name
    pk_print(working_str=rf'''{UNDERLINE}{func_n}()  {'%%%FOO%%%' if LTA else ''}''', print_color='blue')
    f_func_n_txt = rf'{D_PROJECT}\pkg_txt\{func_n}.txt'
    query = urllib.parse.quote(f"{title_to_search}")
    url = f'https://nyaa.si/?f=0&c=0_0&q={query}'
    pk_print(working_str=rf'''url="{url}"  {'%%%FOO%%%' if LTA else ''}''')
    url_decoded = get_str_url_decoded(str_working=url)
    pk_print(working_str=rf'''url_decoded="{url_decoded}"  {'%%%FOO%%%' if LTA else ''}''')
    driver_selenium.get(url)

    # 페이지 소스 RAW
    page_src = driver_selenium.page_source
    from bs4 import BeautifulSoup
    soup = BeautifulSoup(page_src, "html.parser")

    magnets_list = []
    magnets_set = set()

    # 문자열에서 마지막 숫자 remove
    title_to_search = get_str_removed_last_digit(title_to_search).strip()

    # 페이지에서 모든 링크 추출
    lines = soup.find_all(name="a")
    for line in lines:
        magnet = line.get('href')
        if magnet:
            magnets_list.append(magnet)

    for magnet in magnets_list:
        decoded_magnet = get_str_url_decoded(magnet)
        # pk_print(string = rf'''decoded_magnet="{decoded_magnet}"  {'%%%FOO%%%' if LTA else ''}''')

        # 검색 문자열이 URL에 포함되어 있는지 확인
        if is_pattern_in_prompt(prompt=decoded_magnet, pattern=title_to_search):
            if exclude_elements_all and include_elements_any and include_elements_all:

                # 필터링 조건 평가
                include_all_check = all(include in decoded_magnet for include in include_elements_all)
                exclude_check = not any(exclude in decoded_magnet for exclude in exclude_elements_all)
                include_any_check = any(include in decoded_magnet for include in include_elements_any)

                # 필터링 조건이 만족되면
                if include_all_check and exclude_check and include_any_check:
                    magnets_set.add(magnet)
            else:
                magnets_set.add(magnet)
    return magnets_set


#
# def download_torrent_magnet_from_nyaa_si(string_to_search, driver_selenium, except_elements_all, include_elements_any, include_elements_all):
#     func_n = inspect.currentframe().f_code.co_name
#     pk_print(str_working=rf'''{UNDERLINE}{func_n}()  {'%%%FOO%%%' if LTA else ''}''', print_color='blue')
#     f_func_n_txt = rf'{PROJECT_D}\pkg_txt\{func_n}.txt'
#     query = urllib.parse.quote(f"{string_to_search}")
#     url = f'https://nyaa.si/?f=0&c=0_0&q={query}'
#     url_decoded = get_str_url_decoded(string=url)
#     driver_selenium.get(url)
#
#     # Get page source
#     page_src = driver_selenium.page_source
#     soup = BeautifulSoup(page_src, "html.parser")
#
#     hrefs = []
#     titles = []
#     lines = soup.find_all(name="a")
#     for line in lines:
#         titles.append(line.get('title'))
#         hrefs.append(line.get('href'))
#
#     hrefs = get_list_removed_element_preprocessed(hrefs)
#     titles = get_list_removed_element_preprocessed(titles)
#
#     # Log search parameters
#     string_to_search = get_str_removed_last_digit(string_to_search).strip()
#     pk_print(str_working=rf'''string_to_search="{string_to_search}"  {'%%%FOO%%%' if LTA else ''}''')
#     pk_print(str_working=rf'''url_decoded="{url_decoded}"  {'%%%FOO%%%' if LTA else ''}''')
#
#     # Match titles with regex
#     titles_matched_as_regex = [title for title in titles if title and is_regex_in_contents_with_case_ignored(contents=title, regex=string_to_search, debug_mode=False)]
#     # pk_print(string = rf'''titles_matched_as_regex="{titles_matched_as_regex}"  {'%%%FOO%%%' if LTA else ''}''')
#
#     # Filter titles and magnets
#     filtered_titles_and_magnets = []
#     for title, magnet in zip(titles_matched_as_regex, hrefs):
#
#         if not magnet or not is_regex_in_contents_v2( target=magnet, regex="magnet*"):
#             continue
#
#         if except_elements_all and any(except_text in title for except_text in except_elements_all):
#             continue
#
#         if include_elements_all and not all(include_text in title for include_text in include_elements_all):
#             continue
#
#         if include_elements_any and not any(include_text in title for include_text in include_elements_any):
#             continue
#
#         filtered_titles_and_magnets.append((title, magnet))
#
#     # log
#     pk_print(f"Filtered Titles: {[tm for tm in filtered_titles_and_magnets]}")
#     # pause()
#
#     # Open magnets and log
#     for i, (title, magnet) in enumerate(filtered_titles_and_magnets):
#         pk_print(f"{i}:{title}:{magnet}")
#         pause()
#         webbrowser.open(magnet)
#
#     # Update downloaded list
#     f_func_n_txt_list = get_list_from_text_file(pnx=f_func_n_txt)
#     if f_func_n_txt_list is not None:
#         string_to_search = string_to_search.strip()
#         texts_updated = get_list_striped_element(items=f_func_n_txt_list)
#         texts_updated = list(dict.fromkeys(text for text in texts_updated if text and string_to_search not in text))
#         write_list_to_file(pnx=f_func_n_txt, texts=texts_updated, mode="w")
#
#     # Append next item to download list
#     string_downloaded = string_to_search.strip()
#     new_number = str(int(get_last_digit(string_downloaded)) + 1).zfill(2).strip()
#     text_removed_success_and_last_digit = get_str_removed_last_digit(string_downloaded).strip()
#     write_str_to_f(pnx=f_func_n_txt, text=f"{text_removed_success_and_last_digit} {new_number}\n", mode="a")


# def print_list_as_foldable(working_list, working_list_n, foldable_mode=FOLDABLE_MODE):
#     if foldable_mode == True:
#         pk_print(str_working=rf'''working_list="{working_list}"  {'%%%FOO%%%' if LTA else ''}''')
#     else:
#         print_list_as_vertical(working_list=working_list, working_list_n=working_list_n)


#
# def make_plain_light_pkg_for_moving_to_house():
#     pnxs = [
#         rf"{PROJECT_D}\.git",
#         rf"{PROJECT_D}\.idea",
#         rf"{PROJECT_D}\.venv",
#     ]
#     dst =  PROJECT_PARENTS_DIRECTORY
#     move_pnxs_without_overwrite(pnxs=pnxs, dst=dst)
#     back_up_pnx_to_dst(src=PROJECT_D, dst=DESKTOP)


# todo : duplicated function
def move_pnxs_without_overwrite(pnxs, dst):
    for pnx in pnxs:
        move_pnx(pnx=pnx, d_dst=dst)


# todo : duplicated function (1)
def move_pnxs_without_overwrite(pnxs, dst):
    for pnx in pnxs:
        move_pnx(pnx=pnx, d_dst=dst)


def run_and_login_acu_update_v3_exe_and_run_autoa2zdrive_release_exe(issue_log_index_data):
    import os.path
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_HOME
    from pkg_py.pk_core_constants import D_PKG_TXT
    import inspect
    func_n = inspect.currentframe().f_code.co_name

    AUTOA2ZDRIVE_RELEASE_SW_VERSION_EXE = rf"{D_HOME}\Desktop\AutoA2zDrive\AutoA2ZDrive_Release_{issue_log_index_data["SW 버전"]}.exe"
    pk_print(working_str=rf'''AUTOA2ZDRIVE_RELEASE_SW_VERSION_EXE="{AUTOA2ZDRIVE_RELEASE_SW_VERSION_EXE}"  {'%%%FOO%%%' if LTA else ''}''')
    window_title_seg = "acu_update_v3_exe"
    if not does_pnx_exist(pnx=AUTOA2ZDRIVE_RELEASE_SW_VERSION_EXE):
        acu_update_v3_exe = rf"{D_HOME}\Desktop\AutoA2zDrive\ACU_update_v3.exe"
        acu_update_v3_exe_p = get_p(pnx=acu_update_v3_exe)
        os.chdir(acu_update_v3_exe_p)
        cmd = rf' start cmd.exe /k "title {window_title_seg} && {D_HOME}\Desktop\AutoA2zDrive\ACU_update_v3.exe &" '
        cmd_to_os(cmd=cmd, mode="a")
        pw = get_token_from_f_token(f_token=rf'{D_PKG_TXT}\token_linux_pw.txt', initial_str="")
        user_n = get_token_from_f_token(f_token=rf'{D_PKG_TXT}\token_linux_id.txt', initial_str="")
        while 1:
            pk_sleep(milliseconds=2000)
            if is_window_opened(window_title_seg=window_title_seg):
                ensure_window_to_front(window_title_seg=window_title_seg)
                pk_sleep(milliseconds=500)
                write_like_person(str_working=user_n)
                pk_press("enter")
                write_like_person(str_working=pw)
                pk_press("enter")
                write_like_person("2")
                pk_press("enter")
                write_like_person(rf"{issue_log_index_data["SW 버전"]}")
                pk_press("enter")
                break
    else:
        run_autoa2zdrive_release_exe()


def run_autoa2zdrive_release_exe():
    import time
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_DESKTOP

    import inspect
    func_n = inspect.currentframe().f_code.co_name

    # autoa2zdrive_release_exe exec  # via local file

    window_title_seg = "AutoA2Z Drive"
    timeout = 20
    start_time = time.time()
    while 1:
        if not is_window_opened(window_title_seg=window_title_seg):
            pnx = rf"{D_DESKTOP}\AutoA2ZDrive\AutoA2ZDrive_Release.exe"
            cmd = rf' explorer "{pnx}" '
            cmd_to_os(cmd=cmd, mode="a")
        while 1:
            if is_window_opened(window_title_seg=window_title_seg):
                break
            if time.time() - start_time > timeout:
                break
            pk_sleep(seconds=1)
        break

    # 자동닫힘 여부확인 # 40초 동안에
    timeout = 40
    start_time = time.time()
    while 1:
        if not is_window_opened(window_title_seg=window_title_seg):
            break
        if time.time() - start_time > timeout:
            break
        pk_sleep(seconds=1)

    # 40초 동안에 안열리면 VS code exec
    window_title_seg = "AutoA2ZDrive_Release.exe"
    timeout = 5
    start_time = time.time()
    while 1:
        if not is_window_opened(window_title_seg=window_title_seg):
            cmd = rf' explorer "C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\Common7\IDE\devenv.exe" '
            cmd_to_os(cmd=cmd, mode="a")
            break
        while 1:
            if is_front_window_title(window_title_seg=window_title_seg):
                ensure_window_to_front(window_title_seg=window_title_seg)
                break
        pk_print(working_str=time.time() - start_time)
        if time.time() - start_time > timeout:
            break
        pk_sleep(milliseconds=1000)


def run_autoa2z_drive():
    import time
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_HOME

    window_title_seg = "AutoA2Z Drive"
    timeout = 5
    start_time = time.time()
    while 1:
        if time.time() - start_time > timeout:
            break
        if not is_window_opened(window_title_seg=window_title_seg):
            window_title_seg = "git log"
            pk_chdir(d_dst=rf"{D_HOME}\source\repos\ms_proto_drive")
            cmd = rf' start cmd.exe /k "title {window_title_seg} && git log" '
            pk_print(working_str=rf'''cmd="{cmd}"  {'%%%FOO%%%' if LTA else ''}''')
            cmd_to_os(cmd=cmd, mode="a")
            break
        pk_sleep(milliseconds=1000)


def quit_autoa2z_drive():
    import time

    window_title_seg = "AutoA2Z Drive"
    timeout = 5
    start_time = time.time()
    while 1:
        if time.time() - start_time > timeout:
            break
        if is_window_opened(window_title_seg=window_title_seg):
            window_title_seg = "AutoA2ZDrive_Release.exe"
            while 1:
                pid = get_pid_by_window_title_via_tasklist(window_title_seg=window_title_seg)
                if is_number_v2(prompt=pid):
                    # cmd = rf' taskkill /f /pid {pid} '
                    # cmd_to_os_like_person(cmd=cmd, admin_mode=True) # fail
                    # cmd_to_os_like_person_as_admin(cmd=cmd)

                    cmd = rf' Stop-Process -Id {pid} -Force'
                    cmd_to_os_via_powershell_exe(cmd=cmd)
                    write_like_person(str_working='exit')
                    pk_press("enter")
                else:
                    break

            break
        else:
            break


def decompress_pnx_via_wsl_rar(f_zip, dst):  # 테스트필요 f_rar 같음
    import os.path

    if not os.path.exists(f_zip):
        raise FileNotFoundError(f"Source file not found: {f_zip}")

    if not f_zip.lower().endswith('.rar'):
        raise ValueError("The source file must be a .rar file")
    if not os.path.exists(dst):
        os.makedirs(dst)
    f_zip = get_pnx_wsl_unix_style(pnx=f_zip)
    dst = get_pnx_wsl_unix_style(pnx=dst)

    try:
        cmd = f"wsl rar x {f_zip} {dst}"
        cmd_to_os(cmd=cmd)

    except Exception as e:
        raise RuntimeError(f"Failed to decompress the .rar file: {e}")


def assist_to_find_pnx_list_like_everything():
    from pkg_py.pk_colorful_cli_util import pk_print
    # 기존의 파일과 디렉토리 목록에 없는 부분만 추가적으로 DB 에 저장
    # DB 에 저장 모든 파일과 디렉토리 목록을 idx 와 함꼐 출력
    #
    # pk {idx} 를 입력 하면 idx 에 해당하는 파일 또는 디렉토리를 open
    # open 시 디렉토리라면 explorer.exe 를 통해서 열고
    # open 시 파일이라면 확장자에 따라서 지정된 파일로 연다. 지정되지 않은 확장자라면 code.exe 로 연다.
    def get_pnx_list_from_pk_everything_db():
        # input()
        # '''select * from %{}%'''
        pass

    def open_pnx(idx):
        pnx = get_pnx_from_pk_everything_db(idx=idx)
        if is_d(pnx):
            cmd_to_os(f'explorer.exe {pnx}')
        else:
            x = get_x(pnx)
            if x == '.py':
                cmd_to_os(f'code {pnx}')
            else:
                pk_print(f'''아직 행위가 정의되지 않은 확장자입니다. {x} {'%%%FOO%%%' if LTA else ''}''')

    def get_pnx_from_pk_everything_db(idx):
        # input()
        # '''select * from %{}%'''
        pass

    @pk_measure_seconds
    def update_pk_everything_db():
        pass

    update_pk_everything_db()  # monitoring 을 통해서 업데이트를 수행하면 어떨까?

    while 1:
        d_working = input('탐색할 디렉토리를 입력하세요')
        pass

    # pnx_interested_list = [
    #     # rf'{USERPROFILE}\AppData\Roaming\bittorrent',
    # ]
    # string_exclude = [
    #     rf'.dat',
    #     rf'.dll',
    #     rf'.exe',
    #     rf'.dmp',
    #     rf'.lng',
    # ]
    # pnx_list = get_pnx_list_interested_from_file_system(pnx_interested_list=pnx_interested_list, string_exclude=string_exclude)
    # pnx_list = get_list_interested_from_list(working_list=pnx_list,  extension_list_include=[".torrent"])
    # print_list_as_vertical(working_list=pnx_list, working_list_n="pnx_list")
    # string_list_include_any = [
    #     'ONE PIECE - 1123',
    #     'Boku no Hero Academia - 160',
    #     'Re Zero kara Hajimeru Isekai Seikatsu - 59',
    #     'Dungeon ni Deai wo Motomeru no wa Machigatteiru Darou ka S5 - 09',
    #     'Dragon Ball Daima - 08',
    #     'Sword Art Online Alternative - Gun Gale Online S2 - 09',
    #     'Ao no Exorcist - Yuki no Hate-hen - 09',
    #     'Dandadan - 11',
    #     'Amagami-san Chi no Enmusubi - 10',
    #     'Seirei Gensouki 2 - 01',
    # ]
    # pnx_list = get_list_interested_from_list(working_list=pnx_list,  string_list_include_any=string_list_include_any)
    # print_list_as_vertical(working_list=pnx_list, working_list_n="pnx_list")

    # 탐색기 # 전체영역검색
    # get_pnx_list_found_from_file_system()
    # find_pnx_interested_list_from_text_file(including_texts=["심야 괴담회", "심야괴담회"], exclude_texts=[], including_extensions=[".torrent"], except_extensions=[])
    # pnxs_required = get_found_pnx_interested_list_from_text_file(including_texts=["심야 괴담회", "심야괴담회"], exclude_texts=[], including_extensions=[".torrent"], except_extensions=[])
    # pnxs_required = get_list_replaced_element_from_str_to_str(items=pnxs_required, from_str="심야 괴담회", to_str="심야괴담회")
    # pnxs_required = get_list_replaced_element_from_str_to_str(items=pnxs_required, from_str=rf"%USERPROFILE%\AppData\Roaming\bittorrent", to_str="")
    # pnxs_required = get_list_replaced_element_from_str_to_str(items=pnxs_required, from_str="시즌4", to_str="4")
    # pnxs_required = get_list_replaced_element_from_str_to_str(items=pnxs_required, from_str="심야괴담회 4", to_str="심야괴담회4")
    # pnxs_required = get_list_replaced_element_from_pattern_to_patternless(items=pnxs_required, pattern=r"\.\d{6}\.720p-NEXT")
    # pnxs_required = get_list_replaced_element_from_pattern_to_patternless(items=pnxs_required, pattern=r"\.\d{6}\.1080p-NEXT")
    # pnxs_required = get_list_replaced_element_from_pattern_to_patternless(items=pnxs_required, pattern=r"\.\d{6}\.1080p\.WANNA")
    # pnxs_required = get_list_replaced_element_from_pattern_to_patternless(items=pnxs_required, pattern=r"\.\d{6}\.1080p\.H264-F1RST")
    # pnxs_required = get_list_replaced_element_from_pattern_to_patternless(items=pnxs_required, pattern=rf"^\\") # \로 시작하는 부분 삭제
    # pnxs_required = get_list_removed_element_duplicated(items=pnxs_required)
    # pnxs_required = get_list_sorted_element(items=pnxs_required, mode="asc")
    # print_list_as_vertical(working_list=pnxs_required, items_name="pnxs_required")
    # pnxs_required = get_found_pnx_interested_list_from_text_file(including_texts=["ONE PIECE", "ONEPIECE", "one piece", "onepiece", "One Piece", "Onepiece"], exclude_texts=[], including_extensions=[], except_extensions=[".torrent",".jpg",".jpeg",".png",".PNG"])
    # pnxs_required = get_list_replaced_element_from_str_to_str(items=pnxs_required, from_str="ONE PIECE", to_str="ONEPIECE")
    # pnxs_required = get_list_replaced_element_from_str_to_str(items=pnxs_required, from_str="ONEPIECE 4", to_str="ONEPIECE4")
    # pnxs_required = get_list_replaced_element_from_pattern_to_patternless(items=pnxs_required, pattern=r"\.\d{6}\.720p-NEXT")
    # pnxs_required = get_list_replaced_element_from_pattern_to_patternless(items=pnxs_required, pattern=r"\.\d{6}\.1080p-NEXT")
    # pnxs_required = get_list_replaced_element_from_pattern_to_patternless(items=pnxs_required, pattern=r"\.\d{6}\.1080p\.WANNA")
    # pnxs_required = get_list_replaced_element_from_pattern_to_patternless(items=pnxs_required, pattern=r"\.\d{6}\.1080p\.H264-F1RST")
    # pnxs_required = get_list_replaced_element_from_pattern_to_patternless(items=pnxs_required, pattern=rf"^\\") # \로 시작하는 부분 삭제
    # pnxs_required = get_list_removed_element_duplicated(items=pnxs_required)
    # pnxs_required = get_list_sorted_element(items=pnxs_required, mode="asc")
    # print_list_as_vertical(working_list=pnxs_required, items_name="pnxs_required")
    # pk_print(string = rf'''len(pnxs_required)="{len(pnxs_required)}"  {'%%%FOO%%%' if LTA else ''}''')
    pass


def move_pnx_to_remote_os(pnx, dst='~/Downloads', **config_remote_os):
    from pkg_py.pk_colorful_cli_util import pk_print

    ensure_ssh_public_key_to_remote_os(**config_remote_os)

    ip = config_remote_os['ip']
    pw = config_remote_os['pw']
    port = config_remote_os['port']
    user_n = config_remote_os['user_n']

    if not does_pnx_exist(pnx=pnx):
        pk_print(f'''does not exist pnx to send {'%%%FOO%%%' if LTA else ''}''')
        return

    pnx = get_pnx_unix_style(pnx)
    dst = get_pnx_unix_style(dst)
    cmd = f'scp -P {port} -r "{pnx}" {user_n}@{ip}:{dst}'
    # cmd = f'rsync -avz -e "ssh -p {port}" "{src}" {users}@{ip}:{dst}' # windows 환경에는 rsync 없이 가능해야한다... wsl 설치하고 지우면...?너무 비효율적인가?

    cmd_to_os(cmd=cmd)  # warning : pw 물은 채로 정지
    window_title_seg = r"C:\Windows\system32\cmd"
    # pk_sleep(milliseconds=2000) # success : but late
    # pk_sleep(milliseconds=1000) # success : but late
    pk_sleep(milliseconds=500)
    while 1:
        if is_window_opened(window_title_seg=window_title_seg):
            ensure_window_to_front(window_title_seg=window_title_seg)
            # pk_sleep(milliseconds=500)  # success : but late
            # pk_sleep(milliseconds=200)
            pk_sleep(milliseconds=100)
            write_like_person(str_working=pw)
            pk_sleep(milliseconds=100)
            pk_press("enter")
            break
    pk_sleep(milliseconds=500)


def download_remote_release_n_n_n_zip_via_scp(vpc_aifw_version, dst):
    from pkg_py.pk_core_constants import D_PKG_TXT
    # def send_src_to_remote_os(src, port, users, ip, pw):
    dst = get_pnx_windows_style(dst)
    user_gitlab_token = get_token_from_f_token(f_token=rf'{D_PKG_TXT}\user_gitlab_token.txt', initial_str="")
    ip_gitlab_token = get_token_from_f_token(f_token=rf'{D_PKG_TXT}\ip_gitlab_token.txt', initial_str="")
    pw_gitlab_token = get_token_from_f_token(f_token=rf'{D_PKG_TXT}\pw_gitlab_token.txt', initial_str="")
    port_gitlab_token = get_token_from_f_token(f_token=rf'{D_PKG_TXT}\port_gitlab_token.txt', initial_str="")
    src = rf'{user_gitlab_token}@{ip_gitlab_token}:/home/user/release/remote_release_{vpc_aifw_version}.zip'
    cmd = rf"scp -P {port_gitlab_token} -r {src} {dst}"
    # cmd_to_os(cmd=cmd) # warning : pw 물은 채로 정지
    cmd_to_os_like_person(cmd=cmd)  # warning : pw 물은 채로 정지
    window_title_seg = r"C:\Windows\system32\cmd"
    while 1:
        pk_sleep(milliseconds=2000)
        if is_window_opened(window_title_seg=window_title_seg):
            ensure_window_to_front(window_title_seg=window_title_seg)
            pk_sleep(milliseconds=500)  # success : 중요.
            write_like_person(str_working=pw_gitlab_token)
            pk_press("enter")
            break
    pk_sleep(milliseconds=500)


# [def input]
def pk_input_validated(str_working, mode_verbose=1, mode_blank_validation=1, mode_nx_validation=1, mode_upper=1, input_str=":"):
    # todo : pk_input_validated 를 pk_input 에 통합
    '''
    all mode default value is True
    '''
    from pkg_py.pk_colorful_cli_util import pk_print
    while 1:
        if mode_upper:
            str_working = str_working.upper()
        pk_print(str_working, print_color='white', mode_verbose=mode_verbose)
        user_input = input(input_str).strip()
        if mode_blank_validation:
            if not user_input:
                pk_print("blank, name not allowed. Please try again.", print_color='red', mode_verbose=mode_verbose)
                continue
        if mode_nx_validation:
            if any(char in user_input for char in r'\/:*?"<>|'):
                pk_print("Char not allowed in f_n/d_n. Retry.", print_color='red')
                continue
        # todo : p일 조건 을
        # if p_validation_mode == True:
        #     if any(char not in user_input for char in r'\/:*?"<>|'):
        #         pk_print("Char not allowed in f_n/d_n. Retry.", print_color='red')
        #         continue
        return user_input


def compress_pnx_via_bz_exe(pnx, f_zip):
    cmd = f'bz.exe c "{f_zip}" "{pnx}"'
    cmd_to_os(cmd=cmd)


def compress_pnx_to_f_tar_gz(pnx, dst):
    import tarfile
    import os

    pnx = get_pnx_windows_style(pnx)
    dst = get_pnx_windows_style(dst)

    # Ensure the source exists
    if not os.path.exists(pnx):
        raise FileNotFoundError(f"Source path '{pnx}' does not exist.")

    # Create a tar.gz archive
    with tarfile.open(dst, "w:gz") as tar:
        def preserve_metadata(tarinfo):
            """
            Preserve file metadata (permissions, ownership, timestamps).
            """
            tarinfo.preserve = True  # Ensure extended metadata is kept
            return tarinfo

        # Add the source directory, preserving metadata
        tar.add(pnx, arcname=os.path.basename(pnx), recursive=True, filter=preserve_metadata)


def decompress_f_tar_gz(src, dst):  # not tested
    import tarfile
    import os
    # Ensure the archive exists
    if not os.path.exists(src):
        raise FileNotFoundError(f"Archive file '{src}' does not exist.")
    # Extract the archive
    with tarfile.open(src, "r:gz") as tar:
        # Preserve permissions, ownership, and timestamps during extraction
        def is_within_directory(directory, target):
            """
            Ensure the target path is within the directory to prevent path traversal attacks.
            """
            abs_directory = os.path.abspath(directory)
            abs_target = os.path.abspath(target)
            return os.path.commonpath([abs_directory, abs_target]) == abs_directory

        for member in tar.getmembers():
            # Ensure path traversal is prevented
            member_path = os.path.join(dst, member.name)
            if not is_within_directory(dst, member_path):
                raise Exception(f"Path traversal attempt detected: {member.name}")
        tar.extractall(path=dst)


# def convert_lf_to_crlf(f_from, f_to):
#     """for windows"""
#     with open(f_from, "r") as infile:
#         lines = infile.readlines()  # Read all lines (LF format)
#
#     with open(f_to, "w", newline="\r\n") as outfile:
#         outfile.writelines(lines)  # Write lines in CRLF format

def convert_lf_to_crlf(f_from, f_to):
    import chardet
    # f의 인코딩 감지
    with open(f_from, 'rb') as infile:
        raw_data = infile.read()
        result = chardet.detect(raw_data)
        encoding = result['encoding']

    # 감지된 인코딩으로 f을 읽고 CRLF로 변환하여 저장
    with open(f_from, 'r', encoding=encoding) as infile:
        lines = infile.readlines()  # Read all lines (LF format)

    with open(f_to, 'w', encoding='utf-8', newline='\r\n') as outfile:
        outfile.writelines(lines)


def convert_binary_to_text(binary_f, txt_f):
    # todo : chore : 내가 기대한 대로 fix 안됨. 재시도 필요
    # 바이너리 f을 'rb' 모드로 열고 데이터를 읽습니다.
    with open(binary_f, 'rb') as bin_file:
        binary_data = bin_file.read()

    # 읽은 바이너리 데이터를 'utf-8'로 디코딩하여 텍스트로 변환
    try:
        text_data = binary_data.decode('utf-8')
    except UnicodeDecodeError:
        # utf-8로 디코딩이 실패할 경우 다른 인코딩을 시도
        print(f"Failed to decode with utf-8, trying cp949...")
        text_data = binary_data.decode('cp949', errors='ignore')  # 잘못된 인코딩은 무시

    # 변환된 텍스트 데이터를 텍스트 f로 저장
    with open(txt_f, 'w', encoding='utf-8') as text_file:
        text_file.write(text_data)


def run_cmd(cmd):
    import subprocess

    from pkg_py.pk_colorful_cli_util import pk_print
    """Run a shell cmd and return 1 if successful."""
    try:
        result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        return result.returncode == 0
    except Exception as e:
        pk_print(f"cmd failed: {cmd}, Error: {e}", print_color='red')
        return 0


# def get_ip_connected_via_ping(ip):
#     import platform
#     import subprocess
#     from pkg_py.pk_colorful_cli_util import pk_print
#     """Check if an IP is reachable via ping."""
#     try:
#         if platform.system().lower() == "windows":
#             cmd = ["ping", "-n", "3", "-w", "1000", ip]  # 3회 시도, 1000ms 타임아웃
#         else:
#             cmd = ["ping", "-c", "3", "-W", "1", ip]  # 3회 시도, 1초 타임아웃
#         result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
#         return result.returncode == 0
#     except Exception as e:
#         pk_print(f"Ping failed with error: {e}", print_color='red')
#         return 0


# def get_ip_connected_via_tcp(ip, port):
#     import socket
#
#     from pkg_py.pk_colorful_cli_util import pk_print
#     """Check if an IP is reachable via TCP port."""
#     try:
#         with socket.create_connection((ip, port), timeout=2):
#             return 1
#     except (socket.timeout, socket.error) as e:
#         pk_print(f"TCP connection to {ip}:{port} failed: {e}", print_color='red')
#         return 0


# def get_ip_connected_via_udp(ip, port):
#     import socket
#
#     from pkg_py.pk_colorful_cli_util import pk_print
#     """Check if an IP is reachable via UDP port."""
#     sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
#     sock.settimeout(2)
#     try:
#         sock.sendto(b"", (ip, port))  # Send an empty payload
#         sock.recvfrom(1024)  # Expect a response
#         return 1
#     except socket.timeout:
#         pk_print(f"UDP connection to {ip}:{port} timed out", print_color='red')
#         return 0
#     except Exception as e:
#
#         pk_print(f"UDP connection to {ip}:{port} failed: {e}", print_color='red')
#         return 0
#     finally:
#         sock.close()


# def get_ip_connected_via_arp(ip):
#     import platform
#
#     from pkg_py.pk_colorful_cli_util import pk_print
#     """Check if an IP is reachable via ARP."""
#     try:
#         if platform.system().lower() == "windows":
#             cmd = ["arp", "-a", ip]
#         else:
#             cmd = ["arping", "-c", "1", ip]
#         return run_cmd(cmd)
#     except FileNotFoundError:
#         pk_print("Arping cmd not found. Please install arping.", print_color='red')
#         return 0
#     except Exception as e:
#         pk_print(f"ARP check failed: {e}", print_color='red')
#         return 0


def get_ip_connected_via_http(url):
    from pkg_py.pk_colorful_cli_util import pk_print
    import requests
    """Check if an IP is reachable via HTTP."""
    try:
        if not url.startswith(("http://", "https://")):
            url = f"http://{url}"  # Default to HTTP
        response = requests.get(url, timeout=2)
        return response.status_code == 200
    except requests.RequestException as e:
        pk_print(f"HTTP connection to {url} failed: {e}", print_color='red')
        return 0


@pk_measure_seconds
def get_ip_allowed_set():
    from pkg_py.pk_core_constants import D_PKG_TOML
    ip_allowed_set = [
        get_pk_token(f_token=rf'{D_PKG_TOML}/pk_token_ip_acu_it.toml', initial_str=""),
        get_pk_token(f_token=rf'{D_PKG_TOML}/pk_token_ip_vpc_a_side.toml', initial_str=""),
        get_pk_token(f_token=rf'{D_PKG_TOML}/pk_token_ip_vpc_b_side.toml', initial_str=""),
        get_pk_token(f_token=rf'{D_PKG_TOML}/pk_token_ip_vpc_test_02114.toml', initial_str=""),  # msi
        get_pk_token(f_token=rf'{D_PKG_TOML}/pk_token_ip_vpc_test_10114.toml', initial_str=""),
        get_pk_token(f_token=rf'{D_PKG_TOML}/pk_token_ip_vpc_test_02124.toml', initial_str=""),
        get_pk_token(f_token=rf'{D_PKG_TOML}/pk_token_ip_vpc_test_10124.toml', initial_str=""),
        get_pk_token(f_token=rf'{D_PKG_TOML}/pk_token_ip_galaxy_book_02076.toml', initial_str=""),
        'localhost',
        '10.10.10.114',
        '119.207.161.135',
    ]
    return ip_allowed_set


@pk_measure_seconds
def get_ip_conncetion_ping_test_result_list():
    from pkg_py.pk_colorful_cli_util import pk_print
    ip_allowed_set = get_ip_allowed_set()
    ping_test_result_list = []
    for ip in ip_allowed_set:
        state_success = 0
        state_result = ping(ip)
        if state_result is None:
            state_success = 0
        if state_result == 0:
            state_success = 0
        if state_result == 1:
            state_success = 1
        ping_test_result_list.append(("ping", ip, state_success))
        if LTA:
            pk_print(f'''ping_test_result_list={ping_test_result_list} {'%%%FOO%%%' if LTA else ''}''')
    return ping_test_result_list


@pk_measure_seconds
def get_ip_available_list():
    return get_ip_available_list_v4()


@pk_measure_seconds
def get_ip_available_list_v1():
    ip_conncetion_test_result = get_ip_conncetion_ping_test_result_list()
    available_ip_list = [result for result in ip_conncetion_test_result if result[2] == 1]
    available_ip_list = sorted(available_ip_list)
    return available_ip_list


@pk_measure_seconds
def get_ip_available_list_v2():  # v1 보다 4배 빠름
    from concurrent.futures import ThreadPoolExecutor
    ip_conncetion_test_result = get_ip_conncetion_ping_test_result_list()
    available_ip_list = [result for result in ip_conncetion_test_result if result[2] == 1]
    with ThreadPoolExecutor(max_workers=20) as pool:
        results = list(pool.map(ping, available_ip_list))
    return [ip for ip, ok in zip(available_ip_list, results) if ok]


@pk_measure_seconds
def get_ip_available_list_v4(timeout_ms=500, max_workers=None):
    # lazy import
    from pkg_py.pk_colorful_cli_util import pk_print
    from concurrent.futures import ThreadPoolExecutor
    ip_allowed_set = get_ip_allowed_set()
    ip_set = ip_allowed_set
    ip_connected_list = []
    if not ip_set:
        return []

    # 스레드 개수 결정 (IP 개수 vs max_workers 중 작은 쪽)
    workers = max_workers or min(len(ip_set), 20)

    # 병렬로 ping 실행
    with ThreadPoolExecutor(max_workers=workers) as executor:
        # executor.map 에서는 순서대로 ip, 결과(True/False)가 반환됨
        results = list(executor.map(lambda ip: (ip, ping(ip)), ip_set))

    # 성공한 IP만 추출
    ip_connected_list = [ip for ip, ok in results if ok]
    pk_print(f'''ip_connected_list={ip_connected_list} {'%%%FOO%%%' if LTA else ''}''')
    return ip_connected_list


# def get_ip_available_by_user_input_v1():
#     from pkg_py.pk_colorful_cli_util import pk_print
#
#     while 1:
#         available_ip_list = get_ip_available_list()
#         guide_print_ip_available_list(available_ip_list)
#
#         try:
#             pk_print(working_str=rf'''SELECT REMOTE DEVICE IP BY NUMBER(or 'R'=RETRY   0='TBD IP')  {'%%%FOO%%%' if LTA else ''}''', print_color='white')
#             user_input = input(":").strip()
#
#             if user_input.upper() == '0':  # IF USER INPUTS '', RETRY
#                 ip = None
#                 return ip
#
#             if user_input.upper() == '':  # IF USER INPUTS '', RETRY
#                 continue
#
#             if user_input.upper() == 'R':
#                 pk_print("RETRYING THE CONNECTION TEST...", print_color='yellow')
#                 continue
#
#             user_input = int(user_input) - 1
#             if 0 <= user_input < len(available_ip_list):
#                 ip = available_ip_list[user_input][1]
#                 return ip
#             else:
#                 pk_print("Invalid choice. Please run the program again.", print_color='red')
#                 raise
#         except ValueError:
#             pk_print("Invalid input. Please enter a number.", print_color='red')
#             raise


def get_local_ip():
    import socket
    # 로컬 IP 얻기 (localhost 제외)
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.settimeout(0)
    try:
        s.connect(('10.254.254.254', 1))  # 외부와 연결을 시도
        local_ip = s.getsockname()[0]
    except Exception:
        local_ip = 'localhost'
    finally:
        s.close()
    return local_ip


def get_ip_available_by_user_input():
    from pkg_py.pk_colorful_cli_util import pk_print
    try:
        while True:
            available_ip_list = get_ip_available_list()
            available_ip_without_localhost_list = []
            available_ip_only_localhost_list = []
            local_ip = get_local_ip()
            # pk_print(working_str=rf'''SELECT REMOTE DEVICE IP BY NUMBER REFER TO BELOW (or 'R'=RETRY   0='TBD IP')  {'%%%FOO%%%' if LTA else ''}''', print_color='white')
            # pk_print("AVAILABLE IP LIST:", print_color='blue')
            for idx, ip_info in enumerate(available_ip_list):
                if len(ip_info) >= 2:
                    name, ip = ip_info[0], ip_info[1]
                else:
                    ip = ip_info[0]  # name 정보가 없으면 그냥 ip만 사용
                me_marker = ' (me)' if ip == local_ip or ip == 'localhost' else ''
                # pk_print(f"{idx + 1}: {ip}{me_marker}", print_color='blue')
                if me_marker == '':
                    available_ip_without_localhost_list.append(f'{ip}')
                elif not me_marker == '':
                    available_ip_only_localhost_list.append(f'{ip}{me_marker}')

            available_ip_without_localhost_list.append('R(RETRY)')
            available_ip_without_localhost_list.append('0(TBD IP)')

            user_input = get_pk_input(message="user_input=", answer_options=available_ip_without_localhost_list)
            if user_input.upper() == '0' or '0(TBD IP)':
                ip = None
                return ip
            if user_input.upper() == '':  # IF USER INPUTS '', RETRY
                continue
            if user_input.upper() == 'R' or 'R(RETRY)':
                pk_print("RETRYING THE CONNECTION TEST...", print_color='yellow')
                continue
            user_input = int(user_input) - 1
            if 0 <= user_input < len(available_ip_list):
                ip = available_ip_list[user_input][1]
                return ip
            else:
                pk_print("Invalid choice. Please run the program again.", print_color='red')
                raise
    except ValueError:
        pk_print("Invalid input. Please enter a number.", print_color='red')
        raise


def cmd_to_remote_os_with_pw_via_paramiko(ip, port, user_n, pw, cmd):
    # todo   config_remote_os 를 16 usages 에 적용할것.
    # todo : pw 가 보안적으로 필요한 경우는 이 함수를 쓰자
    from pkg_py.pk_colorful_cli_util import pk_print
    import paramiko
    import traceback
    from pkg_py.pk_core_constants import STAMP_REMOTE_DEBUG, STAMP_REMOTE_ERROR, STAMP_TRY_GUIDE

    if LTA:
        pk_print(f"{STAMP_REMOTE_DEBUG} {STAMP_TRY_GUIDE} ssh -p {port} {user_n}@{ip} ")
    pk_print(f"{STAMP_REMOTE_DEBUG} cmd={cmd}")

    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    try:
        # Connect to the server
        ssh.connect(hostname=ip, port=port, username=user_n, password=pw, timeout=10)
        # pk_print("{STAMP_DEBUG} SSH connection established")

        # Execute the cmd
        stdin, stdout_stream, stderr_stream = ssh.exec_command(cmd)
        std_out_str = stdout_stream.read().decode('utf-8').strip()
        std_err_str = stderr_stream.read().decode('utf-8').strip()

        # Debugging output
        std_out_list = get_list_from_str(item_str=std_out_str)
        std_err_list = get_list_from_str(item_str=std_err_str)
        if len(std_out_list) > 1:
            for index, item in enumerate(std_out_list):
                pk_print(f"{STAMP_REMOTE_DEBUG} {item}")
        if len(std_err_list) > 1:
            for index, item in enumerate(std_err_list):
                pk_print(f"{STAMP_REMOTE_ERROR} {item}")

        # Raise an error if there is output in stderr
        if std_err_str:
            pk_print(f"{STAMP_REMOTE_ERROR} {cmd} : {std_err_str}", print_color='red')

        std_out_str = std_out_str.strip()
        std_err_str = std_err_str.strip()
        return std_out_str, std_err_str
    except:
        pk_print(f"{STAMP_REMOTE_ERROR} {traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''} ", print_color='red')
        return std_out_str, traceback.format_exc()
    finally:
        ssh.close()
        if LTA:
            pk_print(rf"{STAMP_REMOTE_DEBUG} SSH connection closed.")


def check_ssh_server_public_key(key_public, **config_remote_os):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import STAMP_ERROR
    import paramiko

    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    ip = config_remote_os['ip']
    port = config_remote_os['port']
    user_n = config_remote_os['user_n']
    pw = config_remote_os['pw']

    try:
        ssh.connect(hostname=ip, port=port, username=user_n, password=pw)

        cmd = f'grep -qxF "{key_public}" ~/.ssh/authorized_keys && echo "Key exists" || echo "Key not found"'
        stdin, stdout, stderr = ssh.exec_command(cmd)
        std_out_str = stdout.read().decode().strip()
        signiture = "Key exists"
        if signiture == std_out_str:
            pk_print(working_str="PUBLIC KEY IS ALREADY REGISTERED ON THE REMOTE SERVER.")
            return 1
        else:
            pk_print(working_str="PUBLIC KEY IS NOT REGISTERED ON THE REMOTE SERVER.", print_color='red')
            return 0

    except Exception as e:
        pk_print(f"{STAMP_ERROR} {e}", print_color='red')
        raise
    finally:
        ssh.close()
        if LTA:
            pk_print(rf"SSH connection closed.")


def upload_pnx_to_remote_os(local_pnx_src, remote_pnx_dst, **config_remote_os):
    local_pnx_src = get_pnx_unix_style(local_pnx_src)
    remote_pnx_dst = get_pnx_unix_style(remote_pnx_dst)
    if is_f(local_pnx_src):
        send_f_to_remote_os(f_local_src=local_pnx_src, f_remote_dst=remote_pnx_dst, **config_remote_os)
    elif is_d(local_pnx_src):
        send_d_to_remote_os(d_local_src=local_pnx_src, d_remote_dst=remote_pnx_dst, **config_remote_os)


def send_f_to_remote_os(f_local_src, f_remote_dst, **config_remote_os):
    from pkg_py.pk_colorful_cli_util import pk_print
    import paramiko
    import os

    ip = config_remote_os['ip']
    pw = config_remote_os['pw']
    port = config_remote_os['port']
    user_n = config_remote_os['user_n']

    f_local_src = get_pnx_os_style(f_local_src)
    if not os.path.exists(f_local_src):
        pk_print(f"{f_local_src} can not send, for not found", print_color='red')
        raise

    ssh = None
    sftp = None
    try:
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(hostname=ip, port=port, username=user_n, password=pw)
        sftp = ssh.open_sftp()

        # send f_local
        pk_print(f"started to send f{(f_local_src)} to remote os({config_remote_os['ip']})")
        sftp.put(f_local_src, f_remote_dst)

        # f 전송 상태 확인
        f_local_size = os.path.getsize(f_local_src)
        f_remote_size = sftp.stat(f_remote_dst).st_size
        if f_local_size == f_remote_size:
            pk_print(f"send pnx ({f_remote_dst})", print_color="green")
            return 1  # 성공 시 True 반환
        else:
            pk_print(f"send pnx ({f_remote_dst})", print_color='red')
            raise
    except Exception as e:
        pk_print(f"send pnx : {e}", print_color='red')
        raise
    finally:
        # 리소스 정리
        if sftp:
            sftp.close()
        if ssh:
            ssh.close()
        if LTA:
            pk_print(working_str="SSH connection closed.")


def send_d_to_remote_os(d_local_src, d_remote_dst, **config_remote_os):
    import shutil
    from pkg_py.pk_colorful_cli_util import pk_print
    import os
    import paramiko

    ip = config_remote_os['ip']
    pw = config_remote_os['pw']
    port = config_remote_os['port']
    user_n = config_remote_os['user_n']
    local_ssh_public_key = config_remote_os['local_ssh_public_key']

    ssh = None
    sftp = None
    f_zip_local = None
    try:
        # compress from d_local to f_zip_local
        f_zip_nx = os.path.basename(d_local_src) + ".zip"
        f_zip_local = os.path.join(os.path.dirname(d_local_src), f_zip_nx)
        f_zip_local = get_pnx_os_style(pnx=f_zip_local)
        shutil.make_archive(base_name=f_zip_local.replace(".zip", ""), format="zip", root_dir=d_local_src)
        if does_pnx_exist(f_zip_local):
            pk_print(f"compress d from d_local to f_zip_local({f_zip_local})")

        f_zip_remote = os.path.join(d_remote_dst, f_zip_nx).replace("\\", "/")

        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(hostname=ip, port=port, username=user_n, password=pw)
        sftp = ssh.open_sftp()

        # send d as f_zip
        pk_print(f"start to send d as f_zip from {f_zip_local} to {f_zip_remote}")
        sftp.put(f_zip_local, f_zip_remote)
        pk_print(f"send d as f_zip from {f_zip_local} to {f_zip_remote}", print_color="green")

        # decompress in remote
        cmd = f"unzip -o {f_zip_remote} -d {d_remote_dst}"
        stdin, stdout, stderr = ssh.exec_command(cmd)  # 이 방식.

        # ensure d existance
        # todo

    except Exception as e:
        print(f"Error during directory transfer: {e}")
        raise
    finally:
        if sftp:
            sftp.close()
        if ssh:
            ssh.close()
        # 잔여 pnx 삭제
        if os.path.exists(f_zip_local):
            os.remove(f_zip_local)
        if LTA:
            pk_print("SSH connection closed.")


def download_pnx_from_aidev1_release_server(remote_f_src, local_d_dst, **config_aidev1_release_server):
    from pkg_py.pk_colorful_cli_util import pk_print
    import paramiko
    import os

    user_n = config_aidev1_release_server['user_n']
    ip = config_aidev1_release_server['ip']
    pw = config_aidev1_release_server['pw']
    port = config_aidev1_release_server['port']

    # todo 보안고민필요...ssh public key 저장해도 되는지..안되면 로컬에 다운받아 넣는 식으로...보안 트집 잡히지 말고 자동화 수립
    # todo migrate secret txt f to token

    remote_f_src = get_pnx_unix_style(remote_f_src)
    pk_print(working_str=rf'''src="{remote_f_src}"  {'%%%FOO%%%' if LTA else ''}''')

    f_dst = rf"{local_d_dst}/{get_nx(remote_f_src)}"
    f_dst = get_pnx_windows_style(f_dst)
    pk_print(f'''f_dst={f_dst} {'%%%FOO%%%' if LTA else ''}''')

    ssh = None
    sftp = None
    try:
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(hostname=ip, port=port, username=user_n, password=pw)

        sftp = ssh.open_sftp()

        d_local = os.path.dirname(f_dst)
        if not os.path.exists(d_local):
            os.makedirs(d_local)

        pk_print(f"started to download pnx {remote_f_src} to {f_dst}")
        sftp.get(remote_f_src, f_dst)
        pk_print(f"download pnx {f_dst}", print_color='green')

    except paramiko.AuthenticationException:
        pk_print("ssh Authentication failed. Please check your user_n and pw.", print_color='red')
        raise
    except Exception as e:
        pk_print(f"Error: {e}", print_color='red')
        raise
    finally:
        if sftp:
            sftp.close()
        if ssh:
            ssh.close()
        if LTA:
            pk_print("SSH connection closed.")


def set_wired_connection(vpc_wired_connection, **config_remote_os):
    from pkg_py.pk_core_constants import STAMP_ERROR

    from pkg_py.pk_colorful_cli_util import pk_print

    cmd_list = []
    if vpc_wired_connection["address"] == "":
        cmd_list.append(f'sudo nmcli connection modify "Wired connection {vpc_wired_connection['wired_connection_no']}" ipv4.method "{vpc_wired_connection["method"]}"')
        cmd_list.append(f'sudo nmcli connection modify "Wired connection {vpc_wired_connection['wired_connection_no']}" ipv4.address "{vpc_wired_connection["address"]}"')
    else:
        cmd_list.append(f'sudo nmcli connection modify "Wired connection {vpc_wired_connection["wired_connection_no"]}" ipv4.address "{vpc_wired_connection["address"]}"')
        cmd_list.append(f'sudo nmcli connection modify "Wired connection {vpc_wired_connection["wired_connection_no"]}" ipv4.method "{vpc_wired_connection["method"]}"')
    cmd_list.append(f'sudo nmcli connection modify "Wired connection {vpc_wired_connection['wired_connection_no']}" ipv4.gateway "{vpc_wired_connection["gateway"]}"')
    cmd_list.append(f'sudo nmcli connection modify "Wired connection {vpc_wired_connection['wired_connection_no']}" ipv4.dns "{vpc_wired_connection["dns"]}"')
    for cmd in cmd_list:
        std_out_list, std_err_list = cmd_to_remote_os(cmd=cmd, **config_remote_os)
        std_err = get_str_from_list(working_list=std_err_list)
        if std_err:
            if "\n" in std_err:
                error_list = std_err.split("\n")
                for error_str in error_list:
                    pk_print(f"{STAMP_ERROR}{error_str}", print_color='red')
            else:
                pk_print(f"{STAMP_ERROR}{std_err}", print_color='red')
    cmd_to_remote_os(cmd="sudo systemctl restart NetworkManager", **config_remote_os)


def get_nmcli_connection_list(**config_remote_os):
    std_out_list, std_err_list = cmd_to_remote_os(cmd=f'nmcli connection show', **config_remote_os)
    # std_out_list, std_err_list = cmd_to_remote_os(cmd=f'nmcli device status',**config_remote_os)
    return std_out_list, std_err_list


def reset_wired_connection_list(wired_connection_no_range, **config_remote_os):
    for wired_connection_no in wired_connection_no_range:
        vpc_wired_connection = {'wired_connection_no': wired_connection_no, "address": rf"", "method": "auto", "gateway": "", "dns": ""}
        set_wired_connection(vpc_wired_connection, **config_remote_os)


def ensure_remove_pnx_of_remote_os(pnx, **config_remote_os):
    from pkg_py.pk_colorful_cli_util import pk_print
    std_out_list, std_err_list = cmd_to_remote_os(cmd=f"rm -rf {pnx}", **config_remote_os)
    std_out_list, std_err_list = cmd_to_remote_os(cmd=f"ls {pnx}", **config_remote_os)
    signiture = 'todo'
    for std_out in std_out_list:
        if signiture in std_out:
            pk_print(f'''remove {pnx} at {config_remote_os['ip']}  {'%%%FOO%%%' if LTA else ''}''', print_color='green')
        else:
            pk_print(f'''remove {pnx} at {config_remote_os['ip']}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
            raise


def ensure_remove_and_make_remote_d(d, config_remote_os):
    from pkg_py.pk_colorful_cli_util import pk_print

    # remove d
    ensure_remove_pnx_of_remote_os(d=d, **config_remote_os)

    # make d
    std_out_list, std_err_list = cmd_to_remote_os(d=f"mkdir -p {d}", **config_remote_os)
    for std_out in std_out_list:
        pk_print(working_str=rf'''std_out={std_out}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        raise


def ensure_unzip_remote_f(remote_f_src, pnx_remote_d_dst, **config_remote_os):
    from pkg_py.pk_colorful_cli_util import pk_print
    std_out_list, std_err_list = cmd_to_remote_os(cmd=f"unzip {remote_f_src} -d {pnx_remote_d_dst}", **config_remote_os)
    if std_out_list == [] or std_err_list == []:
        pk_print(f'''{'%%%FOO%%%' if LTA else ''}''', print_color='green')
    else:
        pk_print(working_str=rf'''{'%%%FOO%%%' if LTA else ''}''', print_color='red')
        raise


def ensure_rename_remote_f(remote_f_src, pnx_remote_d_dst, **config_remote_os):
    from pkg_py.pk_colorful_cli_util import pk_print
    std_out_list, std_err_list = cmd_to_remote_os(cmd=f"mv {remote_f_src} {pnx_remote_d_dst}", **config_remote_os)
    if std_out_list == [] or std_err_list == []:
        pk_print(f'''{'%%%FOO%%%' if LTA else ''}''', print_color='green')
    else:
        pk_print(working_str=rf'''{'%%%FOO%%%' if LTA else ''}''', print_color='red')
        raise


@pk_measure_seconds
def ensure_vpc_side_mode(vpc_data, config_remote_os):
    import traceback
    from pkg_py.pk_core_constants import D_PKG_TXT
    from pkg_py.pk_core_constants import D_PKG_TOML
    from pkg_py.pk_colorful_cli_util import pk_print
    import os

    vpc_side_mode = vpc_data.vpc_side_mode
    vpc_aifw_version = vpc_data.vpc_aifw_version
    with_packing_mode = vpc_data.with_packing_mode

    # ip_after_flash = config_remote_os['ip']
    # pw = config_remote_os['pw']
    # port = config_remote_os['port']
    # user_n = config_remote_os['user_n']
    # local_ssh_public_key = config_remote_os['local_ssh_public_key']

    # vpc_type = get_vpc_type()
    ip_new = get_pk_token(f_token=rf'{D_PKG_TOML}/pk_token_ip_vpc_{vpc_side_mode}_side.toml', initial_str="")
    try:
        # cmd = "mkdir -p ~/.ssh && chmod 700 ~/.ssh"
        # std_out_list, std_err_list = cmd_to_remote_os(cmd=cmd, **config_remote_os)
        # if std_out_list != [] or std_err_list != []:
        #     return

        ensure_remove_and_make_remote_d(d='~/works', **config_remote_os)

        d_temp = make_and_get_d_temp()

        config_aidev1_release_server = {
            'user_n': get_token_from_f_token(f_token=rf'{D_PKG_TXT}\user_gitlab_token.txt', initial_str=""),
            'ip': get_token_from_f_token(f_token=rf'{D_PKG_TXT}\ip_gitlab_token.txt', initial_str=""),
            'pw': get_token_from_f_token(f_token=rf'{D_PKG_TXT}\pw_gitlab_token.txt', initial_str=""),
            'port': get_token_from_f_token(f_token=rf'{D_PKG_TXT}\port_gitlab_token.txt', initial_str=""),
        }
        download_pnx_from_aidev1_release_server(remote_f_src=f"/home/user/release/remote_release_{vpc_aifw_version}.zip", local_d_dst=d_temp, **config_aidev1_release_server)

        upload_pnx_to_remote_os(local_pnx_src=f'{d_temp}/remote_release_{vpc_aifw_version}.zip', remote_pnx_dst=f'/home/nvidia/works/remote_release_{vpc_aifw_version}.zip', **config_remote_os)

        ensure_pnx_removed(d_temp)

        ensure_unzip_remote_f(remote_f_src=f'~/works/remote_release_{vpc_aifw_version}.zip', pnx_remote_d_dst='~/works', **config_remote_os)

        ensure_rename_remote_f(remote_f_src=f'~/works/remote_release_{vpc_aifw_version}', pnx_remote_d_dst='~/works/remote_release', **config_remote_os)

        d_temp = make_and_get_d_temp()

        # download f (a2z_xavier_launcher)
        pk_chdir(d_temp)
        std_list = cmd_to_os(cmd="git clone -b packing_ai_framework --single-branch http://211.171.108.170:8003/ai_dept/a2z_xavier_launcher.git")

        # send f (a2z_xavier_launcher)
        upload_pnx_to_remote_os(local_pnx_src=os.path.join(d_temp, f'a2z_xavier_launcher'), remote_pnx_dst='/home/nvidia/works', **config_remote_os)

        ensure_pnx_removed(d_temp)

        # unzip f (a2z_xavier_launcher)
        cmd = f"unzip -o ~/works/a2z_xavier_launcher.zip -d ~/works/a2z_xavier_launcher"
        std_out_list, std_err_list = cmd_to_remote_os(cmd=cmd, **config_remote_os)
        if std_out_list == [] or std_err_list == []:
            pk_print(f'''{'%%%FOO%%%' if LTA else ''}''', print_color='green')
        else:
            pk_print(working_str=rf'''{'%%%FOO%%%' if LTA else ''}''', print_color='red')
            raise

        d_temp = make_and_get_d_temp()

        # download xc_field.sh
        pk_chdir(d_temp)
        f_remote_src = rf"{d_temp}/xc_field.sh"
        f_remote_src = get_pnx_unix_style(f_remote_src)
        f_nx = get_nx(f_remote_src)
        token_gitlab_repo = get_token_from_f_token(f_token=rf'{D_PKG_TXT}\token_xc_field_gitlab_repo.txt', initial_str=rf"")
        download_f_from_gitlab(f_nx_remote_src='xc_field.sh', d_local_dst=d_temp, gitlab_repo_url=token_gitlab_repo)

        # edit xc_field.sh
        # todo : chore : No password / ai_framework model packing ver / a2z_xavier_launcher / IP Setting
        # 이것도 자동화 하자
        f_remote_src = get_pnx_windows_style(f_remote_src)
        cmd_to_os(rf' explorer "{f_remote_src}" ')
        check_manual_task_iteractively(question=rf'''did you finish customizing {f_nx} manually?  {'%%%FOO%%%' if LTA else ''}''', ignore_uppercase_word_list=[f_nx])

        # remove xc_field.sh
        cmd = f"rm -rf ~/{f_nx}"
        std_out_list, std_err_list = cmd_to_remote_os_with_pw_via_paramiko(cmd=cmd, **config_remote_os)
        if std_out_list == [] or std_err_list == []:
            pk_print(f'''{'%%%FOO%%%' if LTA else ''}''', print_color='green')
        else:
            pk_print(working_str=rf'''{'%%%FOO%%%' if LTA else ''}''', print_color='red')
            return

        # send xc_field.sh
        upload_pnx_to_remote_os(local_pnx_src=os.path.join(d_temp, f'{f_nx}'), remote_pnx_dst=f'/home/nvidia/{f_nx}', **config_remote_os)

        # xc_field.sh chmod
        cmd = f"chmod +x ~/{f_nx}"
        std_out_list, std_err_list = cmd_to_remote_os_with_pw_via_paramiko(cmd=cmd, **config_remote_os)
        if std_out_list == [] or std_err_list == []:
            pk_print(f'''{'%%%FOO%%%' if LTA else ''}''', print_color='green')
        else:
            pk_print(working_str=rf'''{'%%%FOO%%%' if LTA else ''}''', print_color='red')
            return

        # import ipdb
        # ipdb.set_trace()

        cmd = f"echo '{pw}' | sudo -S bash -c \"echo 'nvidia ALL=(ALL:ALL) NOPASSWD:ALL' >> /etc/sudoers\""
        std_out_list, std_err_list = cmd_to_remote_os_with_pw_via_paramiko(cmd=cmd, **config_remote_os)
        cmd = "sudo grep -n 'nvidia ALL=(ALL:ALL) NOPASSWD:ALL' /etc/sudoers"
        std_out_list, std_err_list = cmd_to_remote_os_with_pw_via_paramiko(cmd=cmd, **config_remote_os)
        # echo 'nvidia ALL=(ALL:ALL) NOPASSWD:ALL' | sudo tee /etc/sudoers.d/nvidia
        # sudo chmod 440 /etc/sudoers.d/nvidia
        if "nvidia ALL=(ALL:ALL) NOPASSWD:ALL" in std_out_list:
            pk_print("THE ENTRY IS ALREADY PRESENT.", 'green')
        else:
            import ipdb
            ipdb.set_trace()

        # visudo 등록상태 검사
        cmd = f"sudo visudo -c"
        std_out_list, std_err_list = cmd_to_remote_os_with_pw_via_paramiko(cmd=cmd, **config_remote_os)
        if "parsed OK" not in std_out_list:
            pk_print(working_str=rf'''{cmd} fail  {'%%%FOO%%%' if LTA else ''}''', print_color='red')

        # a2z_xavier_launcher.zip rm
        cmd = f"rm -rf ~/works/a2z_xavier_launcher.zip"
        std_out_list, std_err_list = cmd_to_remote_os_with_pw_via_paramiko(cmd=cmd, **config_remote_os)
        if std_out_list == [] or std_err_list == []:
            pk_print(f'''{'%%%FOO%%%' if LTA else ''}''', print_color='green')
        else:
            pk_print(working_str=rf'''{'%%%FOO%%%' if LTA else ''}''', print_color='red')
            return

        # set xc_field.sh {mode}
        cmd = f"~/{f_nx} {vpc_side_mode}"
        cmd_to_remote_os(cmd=cmd, **config_remote_os)

        check_manual_task_iteractively(question=rf'''did {f_nx} works successfully?  {'%%%FOO%%%' if LTA else ''}''')

        check_manual_task_iteractively(question=rf'''did exit {f_nx} at local?  {'%%%FOO%%%' if LTA else ''}''')

        # remove xc_field.sh
        cmd = f"rm -rf ~/{f_nx}"
        std_out_list, std_err_list = cmd_to_remote_os_with_pw_via_paramiko(cmd=cmd, **config_remote_os)
        if std_out_list == [] or std_err_list == []:
            pk_print(f'''{'%%%FOO%%%' if LTA else ''}''', print_color='green')
        else:
            pk_print(working_str=rf'''{'%%%FOO%%%' if LTA else ''}''', print_color='red')
            return

        # download xc_field.sh
        f_remote_src = rf"{d_temp}/xc_field.sh"
        f_remote_src = get_pnx_unix_style(f_remote_src)
        f_nx = get_nx(f_remote_src)
        token_gitlab_repo = get_token_from_f_token(f_token=rf'{D_PKG_TXT}\token_xc_field_gitlab_repo.txt', initial_str=rf"")
        download_f_from_gitlab(f_nx_remote_src='xc_field.sh', d_local_dst=d_temp, gitlab_repo_url=token_gitlab_repo)
        if not does_pnx_exist(pnx=f_remote_src):
            ensure_pnx_removed(d_temp)
            ensure_pnx_made(pnx=d_temp, mode='d')
            pk_chdir(d_temp)
            token_gitlab_repo = get_token_from_f_token(f_token=rf'{D_PKG_TXT}\token_xc_field_gitlab_repo.txt', initial_str=rf"")
            download_f_from_gitlab(f_nx_remote_src='xc_field.sh', d_local_dst=d_temp, gitlab_repo_url=token_gitlab_repo)
        if not does_pnx_exist(pnx=f_remote_src):
            pk_print(working_str=rf'''{f_remote_src} does not exist.  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
            import ipdb
            ipdb.set_trace()
            return

        # transfer xc_field.sh
        f_local_src = os.path.join(d_temp, f'{f_nx}')
        f_remote_dst = f'/home/nvidia/{f_nx}'
        upload_pnx_to_remote_os(local_pnx_src=f_local_src, remote_pnx_dst=f_remote_dst, **config_remote_os)

        # ip = get_ip_choosen_by_user_input_via_available_ip()  # todo : ref : 불필요해보임.
        # ip = '192.168.10.114'  # todo : code for dev
        ip_new = None
        if vpc_side_mode == 'a':
            ip_new = get_pk_token(f_token=rf'{D_PKG_TOML}/pk_token_ip_vpc_a_side.toml', initial_str=""),
        elif vpc_side_mode == 'b':
            ip_new = get_pk_token(f_token=rf'{D_PKG_TOML}/pk_token_ip_vpc_b_side.toml', initial_str=""),

        # debug
        # stdout, stderr = get_wired_connection_list_via_paramiko(port=port_xc, users=users_xc, ip=ip, pw=pw_xc)

        # reset
        reset_wired_connection_list(wired_connection_no_range=range(1, 5), **config_remote_os)

        # set as mode
        set_wired_connection(vpc_data.wired_connection_1_new, **config_remote_os)
        set_wired_connection(vpc_data.wired_connection_3_new, **config_remote_os)

        # set as custom
        # wired_connection_no = 3
        # set_wired_connection_via_paramiko( port=port_xc, users=users_xc, ip=ip, pw=pw_xc, wired_connection_info={"address": rf"192.168.2.114/22", "method": "manual", "gateway": "192.168.1.1", "dns": "8.8.8.8", })
        # set_wired_connection_via_paramiko( port=port_xc, users=users_xc, ip=ip, pw=pw_xc, wired_connection_info={"address": rf"192.168.10.114/24", "method": "manual", "gateway": "", "dns": "", })

        print_wired_connection_list(wired_connection_no_range=range(1, 5), config_remote_os=config_remote_os)

        # 원격 시스템 reboot
        reboot_vpc()

        check_manual_task_iteractively(question=f'''DID THE AI FRAMEWORK WORK AFTER THE OS OF THE vpc WAS REBOOTED?''')

        # todo : chore : System Settings... 등, 현재의 XC flash 이미지는 문제가 없음.
        # pk_print(f'''check "System Settings..."''', print_color='blue')
        # input(rf"{get_stamp_func_n(func_n=func_n)} >")

        ensure_pnx_removed(d_temp)

        pk_print(working_str=rf'''Successfully, set XC as {vpc_side_mode}.  {'%%%FOO%%%' if LTA else ''}''', print_color="green")
    except:
        pk_print(working_str=rf"{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''} ", print_color='red')
        import sys
        raise


def get_remote_tree(d_path, **config_remote_os):
    ip = config_remote_os['ip']
    user_n = config_remote_os['user_n']
    pw = config_remote_os['pw']

    from paramiko import SSHClient, AutoAddPolicy
    ssh = SSHClient()
    ssh.set_missing_host_key_policy(AutoAddPolicy())
    ssh.connect(hostname=ip, username=user_n, password=pw)

    cmd = f"find {d_path}"
    stdin, stdout, stderr = ssh.exec_command(cmd)
    tree_output = stdout.read().decode()
    ssh.close()
    return tree_output


def get_data_from_f_toml(f):
    import tomllib
    with open(f, "rb") as f_obj:
        data = tomllib.load(f_obj)
    return data


def compare_vpc_tree(f_vpc_tree_answer_list, f_vpc_ref_tree2_list, ignore_list):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import STAMP_SUCCEEDED, STAMP_INFO, STAMP_ERROR
    """
    두 TOML f의 tree.paths를 비교하여 추가된 f과 remove된 f 출력
    :param f_ref: 기준이 되는 TOML f 경로
    :param f_path_list_measured: 측정된 TOML f 경로
    :param ignore_list: 비교에서 제외할 경로들의 리스트
    """
    f_vpc_tree_answer_list = get_pnx_os_style(pnx=f_vpc_tree_answer_list)

    if ignore_list is None:
        ignore_list = []

    # 기준 및 측정된 경로 가져오기
    ref_paths = set(get_data_from_f_toml(f_vpc_tree_answer_list)["tree"]["paths"])
    measured_paths = set(get_data_from_f_toml(f_vpc_ref_tree2_list)["tree"]["paths"])

    # 경로가 ignore_list의 항목을 포함하는지 확인
    def should_ignore(path):
        return any(ignored in path for ignored in ignore_list)

    # ignore_list 에 포함된 항목 remove
    ref_paths = {path for path in ref_paths if not should_ignore(path)}
    measured_paths = {path for path in measured_paths if not should_ignore(path)}

    # 추가된 f과 remove된 f 추출
    added_files = list(measured_paths - ref_paths)
    removed_files = list(ref_paths - measured_paths)

    # 추가된 f 출력
    pk_print(f"{STAMP_INFO} {get_nx(f_vpc_ref_tree2_list)} 에 추가된 f (+{len(added_files)} EA) : 참고 : ({get_nx(f_vpc_tree_answer_list)}[원격지_f_]와 {get_nx(f_vpc_ref_tree2_list)}[로컬_f_]의 트리비교)", print_color='blue')
    for file in sorted(added_files):
        pk_print(file)

    # 누락된 f 출력
    # 누락 파악이 더 중요.
    pk_print(f"{STAMP_ERROR} {get_nx(f_vpc_ref_tree2_list)} 에서 누락된 f (-{len(removed_files)} EA) : 참고 : ({get_nx(f_vpc_tree_answer_list)}[원격지_f_]와 {get_nx(f_vpc_ref_tree2_list)}[로컬_f_]의 트리비교)", print_color='red')
    for file in sorted(removed_files):
        pk_print(f"{file}", print_color='red')
    if len(removed_files) == 0:
        pk_print(f"{STAMP_SUCCEEDED} {get_nx(f_vpc_ref_tree2_list)} 에서 누락된 f이 없습니다 : 참고 : ({get_nx(f_vpc_tree_answer_list)}와 {get_nx(f_vpc_ref_tree2_list)}의 트리비교)", print_color='green')


def set_remote_os_as_nopasswd_v1(**config_remote_os):
    from pkg_py.pk_colorful_cli_util import pk_print
    pw = config_remote_os['pw']
    cmd = "sudo grep -n 'nvidia ALL=(ALL:ALL) NOPASSWD:ALL' /etc/sudoers"
    std_out_list, std_err_list = cmd_to_remote_os_with_pw_via_paramiko(cmd=cmd, **config_remote_os)
    std_out = get_str_from_list(std_out_list)
    if "nvidia ALL=(ALL:ALL) NOPASSWD:ALL" in std_out:
        pk_print("The entry is already present.", 'green')
    else:
        cmd = f"echo '{pw}' | sudo -S bash -c \"echo 'nvidia ALL=(ALL:ALL) NOPASSWD:ALL' >> /etc/sudoers\""
        std_out_list, std_err_list = cmd_to_remote_os_with_pw_via_paramiko(cmd=cmd, **config_remote_os)
        cmd = f"sudo visudo -c"
        std_out_list, std_err_list = cmd_to_remote_os_with_pw_via_paramiko(cmd=cmd, **config_remote_os)


def download_pnx_from_remote_os(f_remote_src, f_local_dst, **config_remote_os):
    f_local_dst = get_pnx_os_style(f_local_dst)
    user = config_remote_os['user']
    ip = config_remote_os['ip']
    port = config_remote_os['port']
    cmd_to_remote_os(cmd=rf"scp -P {port} -r {user}@{ip}:{f_remote_src} {f_local_dst}", **config_remote_os)


def get_yymmdd():
    import datetime
    today = datetime.datetime.now()
    yymmdd = today.strftime("%y%m%d")
    return yymmdd


def ensure_vpc_ip(vpc_data, **config_remote_os):
    from pkg_py.pk_colorful_cli_util import pk_print
    vpc_ip = vpc_data.vpc_ip
    vpc_side_mode = vpc_data.vpc_side
    vpc_type = vpc_data.vpc_type
    vpc_identifier = vpc_data.vpc_identifier
    ip_new = vpc_data.vpc_ip
    while 1:
        set_vpc_ip(vpc_data, **config_remote_os)
        if not ping(ip_new):
            pk_print(working_str=rf'''{vpc_type} set as {vpc_side_mode} side {'%%%FOO%%%' if LTA else ''}''', print_color="red")
            raise
        else:
            break


def save_vpc_tree_to_f_toml(f, config_remote_os):
    f = get_pnx_os_style(pnx=f)
    vpc_tree = get_remote_tree(**config_remote_os, d_path="~/")
    vpc_tree_list = vpc_tree.split('\n')
    data = {"tree": {"paths": vpc_tree_list}}
    set_data_to_f_toml(data, f)


def set_data_to_f_toml(data, f):
    import toml
    with open(f, "w") as f_obj:
        toml.dump(data, f_obj)


def set_vpc_ip(vpc_data, **config_remote_os):
    set_wired_connection(vpc_data.vpc_wired_connection_1_new, **config_remote_os)
    set_wired_connection(vpc_data.vpc_wired_connection_3_new, **config_remote_os)


def ensure_vpc_smoke_test(vpc_data):
    import traceback

    import os
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PROJECT_VSTEST
    from pkg_py.pk_core_constants import D_HOME
    import inspect
    # IT에서 XC로 docker image전송
    # IT에서 XC로 docker image run 명령
    # IT에서 XC에서 제어PC로 결과 수집

    func_n = inspect.currentframe().f_code.co_name

    vpc_aifw_version = vpc_data.vpc_aifw_version
    vpc_id = vpc_data.vpc_id
    vpc_side_mode = vpc_data.vpc_side
    vpc_type = vpc_data.vpc_type

    # 초기 설정 및 유효성 검사

    config_remote_os = {}
    config_remote_os['ip'] = get_ip_available_by_user_input()
    config_remote_os['pw'] = vpc_data.vpc_pw
    config_remote_os['port'] = vpc_data.vpc_port
    config_remote_os['user_n'] = vpc_data.vpc_user_n
    config_remote_os['local_ssh_public_key'] = os.path.join(D_HOME, ".ssh", "id_ed25519.pub")

    ensure_ssh_public_key_to_remote_os(**config_remote_os)

    # 임시 _d_ 설정
    d_temp = make_and_get_d_temp()

    check_manual_task_iteractively(question=rf'''did you verify lan6 connected and indicator is dimming ?  {'%%%FOO%%%' if LTA else ''}''')
    if not ensure_vpc_ip(vpc_data, **config_remote_os):
        ip = get_ip_available_by_user_input()

    # input(f"{pk_get_colorful_working_str_with_stamp_enviromnet(func_n=func_n)} >")  # [SUGGEST] sleep() 하는게 어떤가?

    ensure_auto_reboot_test()

    try:
        # set_remote_os_as_nopasswd_v1(**config_remote_os)
        ensure_remote_os_as_nopasswd(**config_remote_os)

        # remove f remote (vpc_info_collector.sh)
        f_nx = 'vpc_info_collector.sh'
        std_out_list, std_err_list = cmd_to_remote_os(cmd=f"rm -rf ~/Downloads/{f_nx}", **config_remote_os)
        if std_out_list == [] or std_err_list == []:
            pk_print(f'''{'%%%FOO%%%' if LTA else ''}''', print_color='green')
        else:
            pk_print(working_str=rf'''{'%%%FOO%%%' if LTA else ''}''', print_color='red')
            raise

        # send f (vpc_info_collector.sh)
        f_nx = 'vpc_info_collector.sh'
        f_local = os.path.join(D_PROJECT_VSTEST, f_nx)
        f_remote = os.path.join('/home/nvidia/Downloads', f_nx)
        upload_pnx_to_remote_os(local_pnx_src=f_local, remote_pnx_dst=f_remote, **config_remote_os)

        # chmod +x (vpc_info_collector.sh)
        cmd = rf"chmod +x {f_remote}"
        std_out_list, std_err_list = cmd_to_remote_os(cmd=cmd, **config_remote_os)
        if std_out_list != [] or std_err_list != []:
            return

        # run f (vpc_info_collector.sh)
        cmd = rf"cd {get_p(f_remote)} && {f_remote}"
        # cmd = rf"{remote_f}"
        std_out_list, std_err_list = cmd_to_remote_os(cmd=cmd, **config_remote_os)
        if std_out_list == [] or std_err_list == []:
            pk_print(f'''{'%%%FOO%%%' if LTA else ''}''', print_color='green')
        else:
            pk_print(working_str=rf'''{'%%%FOO%%%' if LTA else ''}''', print_color='red')
            return

        vpc_id = vpc_id.strip()
        yymmdd = get_yymmdd()

        # download f (vpc_info_collector.txt)
        f_remote_src = "/home/nvidia/Downloads/vpc_info_collector.txt"
        f_local_new = rf"{D_PROJECT_VSTEST}/{vpc_id}_smoke_test_report_at_{yymmdd}.txt"
        download_pnx_from_remote_os(f_remote_src, f_local_new, **config_remote_os)

        # check f_local_dst
        f_local_new = get_pnx_os_style(f_local_new)
        if does_pnx_exist(pnx=f_local_new):
            cmd_to_os(cmd=f'explorer "{f_local_new}" ', mode='a')

        # convert from lf to crlf # todo for not working
        f_n = get_n(f_nx)
        f_x = get_x(f_nx)
        f_to = rf"{D_PROJECT_VSTEST}/{f_n}_crlf{f_x}"
        f_to = get_pnx_windows_style(f_to)
        convert_lf_to_crlf(f_from=f_local_new, f_to=f_to)

        # convert from binary to txt
        # f_from = f_to
        # f_to = rf"{PROJECT_DIRECTORY}/{f_n}_binary{f_x}"
        # convert_binary_to_text(binary_f=f_from, txt_f=f_to)

        # rename vpc_info_collector.txt
        f_remote_src = "/home/nvidia/Downloads/vpc_info_collector.txt"
        f_remote_new = f'/home/nvidia/Downloads/{vpc_id}_smoke_test_report_at_{yymmdd}.txt'
        std_out_list, std_err_list = cmd_to_remote_os(cmd=f"mv {f_remote_src} {f_remote_new}", **config_remote_os)
        if std_out_list == [] or std_err_list == []:
            pk_print(f'''{'%%%FOO%%%' if LTA else ''}''', print_color='green')
        else:
            pk_print(working_str=rf'''{'%%%FOO%%%' if LTA else ''}''', print_color='red')
            return

        # remove vpc_info_collector.sh
        std_out_list, std_err_list = cmd_to_remote_os(cmd=f"rm -rf ~/Downloads/vpc_info_collector.sh", **config_remote_os)
        if std_out_list == [] or std_err_list == []:
            pk_print(f'''{'%%%FOO%%%' if LTA else ''}''', print_color='green')
        else:
            pk_print(working_str=rf'''{'%%%FOO%%%' if LTA else ''}''', print_color='red')
            return

        # compare vpc tree 
        vpc_aifw_version = vpc_aifw_version.replace('.', "_")
        f_vpc_ref_tree2 = rf"{D_PROJECT_VSTEST}\{get_n(f_to)}_tree_{yymmdd}.toml"
        f_vpc_tree_answer = rf"{D_PROJECT_VSTEST}/{vpc_type}_{vpc_aifw_version}_tree_{vpc_side_mode}_ref.toml"
        save_vpc_tree_to_f_toml(f=f_vpc_ref_tree2, config_remote_os=config_remote_os)
        ignore_list = [
            "/home/nvidia/.local",
            # "/home/nvidia/.compiz",
            "/home/nvidia/.cache",
            "/home/nvidia/works/log",
            "/home/nvidia/works/a2z_xavier_launcher/log",
            "/home/nvidia/.ssh/known_hosts",
            "/home/nvidia/.config",
        ]
        compare_vpc_tree(f_vpc_tree_answer_list=f_vpc_tree_answer, f_vpc_ref_tree2_list=f_vpc_ref_tree2, ignore_list=ignore_list)

        ensure_pnx_removed(d_temp)

        import ipdb
        ipdb.set_trace()

        print_wired_connection_list(wired_connection_no_range=range(1, 5), **config_remote_os)

        reset_wired_connection_list(wired_connection_no_range=range(1, 5), **config_remote_os)

        # set vpc ip
        ensure_vpc_ip(vpc_data, **config_remote_os)

        # input(f"{pk_get_colorful_working_str_with_stamp_enviromnet(func_n=func_n)} >")

        # set vpc ip as custom
        wired_connection_3_new = {'wired_connection_no': 3, "address": rf"", "method": "auto", "gateway": "", "dns": ""}  # reset vpc ip
        wired_connection_3_new = {'wired_connection_no': 3, "address": rf"192.168.2.124/22", "method": "manual", "gateway": "192.168.1.1", "dns": "8.8.8.8"}
        wired_connection_3_new = {'wired_connection_no': 3, "address": rf"192.168.2.114/22", "method": "manual", "gateway": "192.168.1.1", "dns": "8.8.8.8"}
        wired_connection_3_new = {'wired_connection_no': 3, "address": rf"192.168.10.114/22", "method": "manual", "gateway": "", "dns": ""}
        set_wired_connection(wired_connection_3_new, **config_remote_os)

        # if xc
        # a2z_component_f, a2z_component_m %CPU 확인
        # 카메라 미연결 시, a2z_component_f, %CPU=100~110
        cmd_to_remote_os(cmd=f"top", **config_remote_os)

        # cmd = f"sudo dmesg"
        cmd_to_remote_os(cmd=f"sudo dmesg -w", **config_remote_os)

        cmd_to_remote_os(cmd=f"timedatectl", **config_remote_os)

        # 로거 설정확인
        cmd_to_remote_os(cmd=f"cat ./autorun.sh", **config_remote_os)

        # 로거 테스트
        # a2z_xavier_launcher.zip
        std_out_list, std_err_list = cmd_to_remote_os(cmd=f"cd ~/works/a2z_wavier_launcher && sudo python3 SystemLogger.py", **config_remote_os)
        if std_out_list == [] or std_err_list == []:
            pk_print(f'''{'%%%FOO%%%' if LTA else ''}''', print_color='green')
        else:
            pk_print(working_str=rf'''{'%%%FOO%%%' if LTA else ''}''', print_color='red')
            return

        # 로그 확인
        # find /home/nvidia/works/log/ -ctime +4 -delete

        # 로그 수집

        # 강제전원remove 후 재부팅 시 AI_Framework 동작여부 확인 테스트
        check_manual_task_iteractively(question=rf'''remove power of XC, forcely ? {'%%%FOO%%%' if LTA else ''}''')
        check_manual_task_iteractively(question=rf'''connect power of XC, again ? {'%%%FOO%%%' if LTA else ''}''')
        check_manual_task_iteractively(question=rf'''AI frame work is restarted, again ? {'%%%FOO%%%' if LTA else ''}''')

    except:
        pk_print(working_str=rf"{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''} ", print_color='red')
        return
    finally:
        ensure_pnx_removed(d_temp)


def download_f_from_gitlab(f_nx_remote_src, d_local_dst, gitlab_repo_url):
    'gitlab_repo_url : 192.168...'

    while 1:
        pk_chdir(d_local_dst)
        cmd_to_os(cmd=f'git init')
        cmd = rf"git remote add -f origin http://{gitlab_repo_url}"
        std_list = cmd_to_os(cmd=cmd)

        cmd_to_os(cmd=f'git fetch')
        cmd_to_os(cmd=f'git checkout origin/main -- {f_nx_remote_src}')
        # cmd_to_os(cmd = f'git remote remove origin') # 로그인 실패시 # todo

        # todo
        # f_remote_src = 현재 디렉토리의 + f_nx_remote_src
        # if not does_pnx_exist(pnx=f_remote_src):
        #     continue
        # if does_pnx_exist(pnx=f_remote_src):
        #     break


def get_weekday_as_korean():
    from datetime import datetime
    now = datetime.now()
    weekdays_korean = ['월', '화', '수', '목', '금', '토', '일']
    return weekdays_korean[now.weekday()]


def get_time_as_(pattern: str):
    import time
    from datetime import datetime
    now = datetime.now()
    weekday = get_weekday_as_korean()
    epoch_time = time.time()
    seconds = int(epoch_time)
    nanoseconds = int((epoch_time - seconds) * 1e9)  # 나노초 부분
    milliseconds = (now.microsecond // 1000)  # 마이크로초 ->> 밀리초
    time_styles = {
        'now': f"{now.year}_{now.month:02}_{now.day:02}_{weekday}_{now.hour:02}_{now.minute:02}_{now.second:02}_{milliseconds:03}_{nanoseconds:09}",
        'yyyy': str(now.year),
        'MM': str(now.month).zfill(2),
        'dd': str(now.day).zfill(2),
        'HH': str(now.hour).zfill(2),
        'mm': str(now.minute).zfill(2),
        'ss': str(now.second).zfill(2),
        'fff': str(milliseconds).zfill(3),  # 밀리초
        'fffffff': str(nanoseconds).zfill(9),  # 나노초
        'weekday': weekday,
        'elapsed_days_from_jan_01': str(now.timetuple().tm_yday),  # 금년 1월 1일부터 오늘까지의 일수
        'yyyy MM dd (weekday) HH mm': f"{now.year} {now.month:02} {now.day:02} ({weekday}) {now.hour:02} {now.minute:02}",
        'yyyy MM dd weekday HH mm ss': f"{now.year} {now.month:02} {now.day:02} {weekday} {now.hour:02} {now.minute:02} {now.second:02}",
        'yyyy MM dd weekday HH mm ss fff': f"{now.year} {now.month:02} {now.day:02} {weekday} {now.hour:02} {now.minute:02} {now.second:02} {milliseconds:03}",
        'yyyy MM dd weekday HH mm ss fff ffffff': f"{now.year} {now.month:02} {now.day:02} {weekday} {now.hour:02} {now.minute:02} {now.second:02} {milliseconds:03} {nanoseconds:09}",
    }
    if pattern in time_styles:
        return time_styles[pattern]
    return now.strftime(pattern)


def get_ip_wsl_another_way():
    from pkg_py.pk_colorful_cli_util import pk_print
    wsl_ip = None
    std_list = cmd_to_os("wsl ip -4 addr show eth0")
    signiture_str = 'inet '
    for std_str in std_list:
        if signiture_str in std_str:
            wsl_ip = std_str.split('/')[0].split(signiture_str)[1]
            if LTA:
                pk_print(working_str=rf'''wsl_ip="{wsl_ip}" {'%%%FOO%%%' if LTA else ''}''', print_color='green')
    return wsl_ip


def install_docker(**config_remote_os):
    std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd='sudo apt update', **config_remote_os)
    std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd='curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg', **config_remote_os)  # GPG 키 추가
    std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd='sudo apt install -y apt-transport-https ca-certificates curl software-properties-common gnupg lsb-release', **config_remote_os)  # wsl docker dependency
    std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd='echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null', **config_remote_os)  # Docker 리포지토리 추가
    std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd='sudo apt update', **config_remote_os)
    std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd='sudo apt install -y docker-ce docker-ce-cli containerd.io', **config_remote_os)
    std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd='sudo usermod -aG docker $USER', **config_remote_os)


def ensure_general_ubuntu_pkg(ubuntu_pkg_n, **config_remote_os):
    from pkg_py.pk_colorful_cli_util import pk_print
    std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd=f'sudo apt install {ubuntu_pkg_n}', **config_remote_os)
    if not len(std_err_list) == 0:
        for std_err_str in std_err_list:
            pk_print(working_str=rf'{std_err_str}', print_color='red')
    pk_print(working_str=rf'''{ubuntu_pkg_n} installed in {config_remote_os['ip']} {'%%%FOO%%%' if LTA else ''}''', print_color='green')


def ensure_ubuntu_pkg_installed(ubuntu_pkg_n):
    import shutil
    from pkg_py.pk_colorful_cli_util import pk_print
    while 1:
        ubuntu_pkg_bin = shutil.which(ubuntu_pkg_n)
        if not ubuntu_pkg_bin:
            pk_print(f"{ubuntu_pkg_n} is not installed")
            pk_print(f"try to install {ubuntu_pkg_n} now")
            cmd_to_os(f"sudo apt install -y {ubuntu_pkg_n}")
            ubuntu_pkg_bin = get_pnx_ubuntu_pkg_installed(ubuntu_pkg_n)
            if ubuntu_pkg_bin is None:
                continue
        else:
            pk_print(f"{ubuntu_pkg_n} is installed")
            break


def ensure_ubuntu_pkg_to_remote_os(ubuntu_pkg_n, **config_remote_os):
    from pkg_py.pk_colorful_cli_util import pk_print
    if not is_internet_connected():
        pk_print(f'''can not install ubuntu pakage ({ubuntu_pkg_n}) for internet not connected  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        raise
    if ubuntu_pkg_n == 'docker':
        std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd='docker --version', **config_remote_os)
        if check_signiture_in_loop(time_limit=10, working_list=std_out_list, signiture="The cmd 'docker' could not be found in this WSL 2 distro.", signiture_found_ment="docker is not installed in wsl"):
            install_docker(**config_remote_os)
    elif ubuntu_pkg_n == 'net-tools':
        todo('%%%FOO%%%')
    else:
        # std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd=f'{ubuntu_pkg_n} --version', **config_remote_os)
        std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd=f'sudo apt list --installed | grep {ubuntu_pkg_n}', **config_remote_os)
        signiture = 'installed'
        if check_signiture_in_loop(time_limit=10, working_list=std_out_list, signiture=signiture, signiture_found_ment=f"{ubuntu_pkg_n} is installed in {config_remote_os['ip']}"):
            ensure_general_ubuntu_pkg(ubuntu_pkg_n=ubuntu_pkg_n, **config_remote_os)


def get_tree_depth_level(f: str):
    return len(f.split("\\")) - 1


def get_pnx(pnx):
    return pnx


def get_pn(pnx):
    import os
    return rf"{os.path.dirname(pnx)}\{os.path.splitext(os.path.basename(pnx))[0]}"


def get_nx(pnx):
    import os
    return rf"{os.path.splitext(os.path.basename(pnx))[0]}{os.path.splitext(os.path.basename(pnx))[1]}"


def get_x(pnx):
    """ . 포함해서 리턴한다 ex> .txt """
    import os
    if is_f(pnx=pnx):
        return rf"{os.path.splitext(os.path.basename(pnx))[1]}"
    else:
        return ""


from pathlib import Path
from typing import Union
import uuid


def get_n(pnx: Union[str, Path]) -> str:
    try:
        # 문자열화 → Path 변환 → 이름 추출
        path = Path(str(pnx))
        name = path.stem if path.suffix else path.name

        # 금지 문자가 있다면 오류 발생시켜 fallback 실행
        if any(c in name for c in '<>:"/\\|?*'):
            raise ValueError("invalid characters in filename")

        return name.strip() or f"unknown_{uuid.uuid4().hex[:8]}"
    except Exception:
        return f"unknown_{uuid.uuid4().hex[:8]}"


def get_n_v1(pnx):
    import os
    if is_f(pnx=pnx):
        return rf"{os.path.splitext(os.path.basename(pnx))[0]}"
    else:
        return os.path.basename(pnx)


def download_video_f(url: str):
    import os
    import traceback
    from pkg_py.pk_core_constants import D_DOWNLOADING, VIDEO_IDS_ALLOWED, AUDIO_IDS_ALLOWED, F_YT_DLP_EXE
    from pkg_py.pk_colorful_cli_util import pk_print, print_magenta
    from pkg_py.pk_interface_graphic_user import GuiUtil
    while 1:
        if url.strip() == "":
            pk_print(f'''  {'%%%FOO%%%' if LTA else ''} {url}" ''', print_color='red')
            break

        pk_print(working_str=rf'''url="{url}"  {'%%%FOO%%%' if LTA else ''}''')

        # 유튜브 다운로더 업데이트 # 다운로드가 안되면 주석 풀어 시도
        # os.system(rf'{YT_DLP_CMD} -U')

        video_id = ''
        # lines=subprocess.check_output(rf'{YT_DLP_CMD} -F {url}', shell=True).decode('utf-8').split("\n")

        cmd = rf'{F_YT_DLP_EXE} -F {url}'
        # lines=cmd_to_os_like_person_as_admin(cmd=cmd)
        lines = cmd_to_os(cmd=cmd)
        # 순서는 우선순위에 입각해 설정되었다. 순서를 바꾸어서는 안된다.

        video_ids_allowed = VIDEO_IDS_ALLOWED
        audio_ids_allowed = AUDIO_IDS_ALLOWED
        audio_id = ""
        for line in lines:
            if 'video only' in line or 'audio only' in line:
                pk_print(line, print_color='blue')
                # video_id 설정
                for id in video_ids_allowed:
                    if id in line:
                        video_id = id
                        if video_id.strip() == "":
                            pk_print(rf"다운로드 할 수 있는 video_id가 아닙니다 {video_id.strip()}", print_color='blue')
                            break
                # audio_id 설정
                for id in audio_ids_allowed:
                    if id in line:
                        audio_id = id
                        if audio_id.strip() == "":
                            pk_print(rf"다운로드 할 수 있는 audio_id가 아닙니다 {audio_id.strip()}", print_color='blue')
                            break
                        break

        # 다운로드 가능 옵션 ID 설정
        # if video_id not in video_ids and audio_id not in audio_ids:
        #     video_id=str(input('video option:'))
        #     audio_id=str(input('audio option:'))
        #     pk_print(rf'video option: {video_id}  audio option: {audio_id}')
        #     speak(rf'video option: {video_id}  audio option: {audio_id}')
        # else:
        #     pass

        # directories=["storage"]
        # for directory in directories:
        #     if not is_d(rf'{os.getcwd()}\{directory}'):
        #         print(rf'storage d 생성 중...')
        #         os.makedirs(rf'{directory}')

        # 2023년 12월 12일 (화) 16:02:06
        # 다운로드의 최고 품질이 아닐 수 있다. 그래도
        # 차선책으로 두는 것이 낫겠다
        # cmd=rf'{YT_DLP_CMD} -f best "{url}"'
        # cmd=rf'{YT_DLP_CMD} -f {video_id}+{audio_id} {url}' # 초기에 만든 선택적인 방식
        # cmd=rf'{YT_DLP_CMD} -f "best[ext=webm]" {url}' # 마음에 안드는 결과
        cmd = rf'{F_YT_DLP_EXE} -f "bestvideo[ext=webm]+bestaudio[ext=webm]" {url}'  # 지금 가장 마음에 드는 방법 근데 webm 없는 경우가 많음
        # cmd=rf'{YT_DLP_CMD} -f "bestvideo[ext=webm]+bestaudio[ext=webm]/best[ext=webm]/best" {url}' # 아직 시도하지 않은 방법
        # cmd=rf'{YT_DLP_CMD} x+x "{url}"' # --list-formats 해서 다운로드
        if video_id == "" or audio_id == "" == 1:
            # text="다운로드를 진행할 수 없습니다\n다운로드용 video_id 와 audio_id를 설정 후\nurl을 다시 붙여넣어 다운로드를 다시 시도하세요\n{url}"
            pk_print(working_str="불완전한 다운로드 명령어가 감지되었습니다....")
            pk_speak_v2(working_str="불완전한 다운로드 명령어가 감지되었습니다", comma_delay=0.98)
            dialog = GuiUtil.CustomQdialog(
                prompt=f"에러코드[E004]\n아래의 비디오 아이디를 저장하고 에러코드를 관리자에게 문의해주세요\nvideo id: {url}",
                btn_list=["확인"],
                input_box_mode=True,
                input_box_text_default=url,
            )
            dialog.exec()
            print(cmd)
            break

        try:
            lines = cmd_to_os_like_person_as_admin(cmd=cmd)
        except:
            print_magenta("except:2024-04-12 1750")
            print_magenta(rf'''cmd : {cmd}''')

        if not os.path.exists(D_DOWNLOADING):
            os.makedirs(D_DOWNLOADING)

        pk_print(working_str="다운로드 f 이동 시도 중...")
        file = ""
        try:
            clip_id = parse_youtube_video_id(url)
            if clip_id is None:
                clip_id = url

            lines = os.listdir()
            for line in lines:
                if is_pattern_in_prompt(str(line), str(clip_id)):
                    file = line

            src = os.path.abspath(file)
            src_renamed = rf"{D_DOWNLOADING}\{os.path.basename(file)}"

            pk_print(f'src_renamed : {src_renamed}', print_color='blue')
            if src == os.getcwd():  # 여기 또 os.getcwd() 있는 부분 수정하자..
                # E001 : exec 불가능한 명령어입력 감지
                # S001 : 다운로드 가능한 video_id 와 audio_id 를 가용목록에 추가해주세요.
                dialog = GuiUtil.CustomQdialog(
                    prompt=f"에러코드[E001]\n아래의 비디오 아이디를 저장하고 에러코드를 관리자에게 문의해주세요\nvideo id: {url}",
                    btn_list=["확인"],
                    input_box_mode=True,
                    input_box_text_default=url, )
                dialog.exec()
                pk_print("cmd", print_color='blue')
                pk_print(cmd, print_color='blue')
                break
            # shutil.move(src, storage)
            if src != os.getcwd():  # 여기 또 os.getcwd() 있는 부분 수정하자..
                move_pnx(src, src_renamed)

        except:
            pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        print(rf'다운로드 결과 확인 중...')
        try:
            src_moved = rf'{D_DOWNLOADING}\{file}'
            pk_print(rf'''src_moved : {src_moved}''', print_color='blue')

            # 재생할까요? 불필요하면 주석
            # dialog=GuiUtil.CustomQdialog(ment="다운로드된 영상을 재생할까요?", btns=["재생하기", "재생하지 않기"], auto_click_negative_btn_after_seconds=10)
            # dialog=GuiUtil.CustomQdialog(ment="다운로드된 영상을 재생할까요?", btns=["재생하기", "재생하지 않기"], auto_click_negative_btn_after_seconds=3600)
            # dialog.exec()
            # if dialog.btn_txt_clicked == "재생하기":
            #     open_pnx(pnx_todo=src_moved)

            # 무조건 재생
            text_editor = 'explorer.exe'
            cmd = f'{text_editor} "{src_moved}" '
            cmd_to_os(cmd=cmd)

            # GuiUtil.pop_up_as_complete(title="작업성공보고", ment=f"다운로드가 성공되었습니다\n{src_moved}", auto_click_positive_btn_after_seconds=2) # 성공 뜨는게 귀찮아서 주석처리함,

        except Exception:
            pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')

        # 다운로드 로깅 처리
        # cmd=f'echo "{url}" >> success_yt_dlp.log'
        # run_via_cmd_exe(cmd=cmd)
        break


def convert_mkv_to_wav(file_mkv):
    cmd_to_os_like_person_as_admin(rf'ffmpeg -i "{file_mkv}" -ab 160k -ac 2 -ar 44100 -vn {get_pn(file_mkv)}.wav')


def convert_mp4_to_webm(src):
    import inspect
    import os
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_FFMPEG_EXE
    func_n = inspect.currentframe().f_code.co_name
    '''테스트 필요'''

    pk_print(f'from : {src}', print_color='blue')
    file_edited = f'{os.path.splitext(os.path.basename(src))[0]}.webm'
    pk_print(f'to   : {file_edited}', print_color='blue')

    path_started = os.getcwd()
    os.system("chcp 65001 >nul")
    os.system('mkdir storage >nul')
    os.chdir('storage')
    os.system(f'"{F_FFMPEG_EXE}" -i "{src}" -f webm -c:v libvpx -b:v 1M -acodec libvorbis "{file_edited}" -hide_banner')
    pk_chdir(path_started)


def convert_wav_to_flac(pnx_wav):
    import inspect
    import os
    import subprocess
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    from pkg_py.pk_core_constants import F_FFMPEG_EXE
    '''테스트 필요'''

    os.system("chcp 65001 >nul")

    pk_print(f'from : {pnx_wav}', print_color='blue')
    file_edited = f'{os.path.splitext(os.path.basename(pnx_wav))[0]}.flac'
    pk_print(f'to   : {file_edited}', print_color='blue')

    ffmpeg_exe = F_FFMPEG_EXE
    destination = 'storage'
    try:
        os.makedirs(destination)
    except Exception as e:
        pass
    pk_chdir(destination)
    pk_print(f'"{ffmpeg_exe}" -i "{pnx_wav}" -c:a flac "{file_edited}"        를 수행합니다.', print_color='blue')
    subprocess.check_output(f'"{ffmpeg_exe}" -i "{pnx_wav}" -c:a flac "{file_edited}"', shell=True)


def convert_mp4_to_wav(pnx):
    import inspect
    import os
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    '''테스트 필요'''
    pk_print(f'from : {pnx}', print_color='blue')
    file_edited = f'{os.path.splitext(os.path.basename(pnx))[0]}.wav'
    pk_print(f'to   : {file_edited}', print_color='blue')

    path_started = os.getcwd()

    os.system('mkdir storage')
    pk_chdir('storage')
    if os.path.splitext(os.path.basename(pnx))[1] == '.mp4':
        from moviepy import VideoFileClip
        videoclip = VideoFileClip(pnx)
        audioclip = videoclip.audio

        # audioclip.write_audiofile(file_edited, fps= 8000 )
        audioclip.write_audiofile(file_edited, fps=44100)
        audioclip.close()
        videoclip.close()

    pk_chdir(path_started)


def convert_mp4_to_flac(pnx):
    import inspect
    import os
    import subprocess
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    from pkg_py.pk_core_constants import F_FFMPEG_EXE
    '''테스트 필요'''

    os.system("chcp 65001 >nul")
    pk_print(f'from : {pnx}', print_color='blue')
    file_edited = f'{os.path.splitext(os.path.basename(pnx))[0]}.flac'
    pk_print(f'to   : {file_edited}', print_color='blue')

    path_started = os.getcwd()

    ffmpeg_exe = F_FFMPEG_EXE
    destination = 'storage'
    try:
        os.makedirs(destination)
    except Exception as e:
        pass
    pk_chdir(destination)
    pk_print(f'"{ffmpeg_exe}" -i "{pnx}" -c:a flac "{file_edited}"        를 수행합니다.', print_color='blue')
    subprocess.check_output(f'"{ffmpeg_exe}" -i "{pnx}" -c:a flac "{file_edited}"', shell=True)

    pk_chdir(path_started)


def convert_mp3_to_flac(f_mp3):
    import inspect
    import os
    import subprocess
    from pkg_py.pk_core_constants import F_FFMPEG_EXE
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    '''테스트 필요'''
    os.system("chcp 65001 >nul")

    pk_print(f'f_mp3 : {f_mp3}', print_color='blue')
    f_edited = f'{os.path.splitext(os.path.basename(f_mp3))[0]}.flac'
    pk_print(f'f_edited   : {f_edited}', print_color='blue')

    d_started = os.getcwd()

    ffmpeg_exe = F_FFMPEG_EXE
    d_dst = 'storage'
    try:
        os.makedirs(d_dst)
    except Exception as e:
        pass
    pk_chdir(d_dst)
    pk_print(f'"{ffmpeg_exe}" -i "{f_mp3}" -c:a flac "{f_edited}"        를 수행합니다.', print_color='blue')
    subprocess.check_output(f'"{ffmpeg_exe}" -i "{f_mp3}" -c:a flac "{f_edited}"', shell=True)

    pk_chdir(d_started)


def convert_xls_to_xlsx(f_xls):
    """
    2024-02-12 15:45 작성 함수 템플릿 샘플
    """
    import inspect
    import os
    import traceback
    from zipfile import BadZipFile
    from pkg_py.pk_colorful_cli_util import pk_print, print_success, print_yellow
    from pkg_py.pk_decide_program_performance import CustomErrorUtil

    import pandas as pd
    from pkg_py.pk_core_constants import Encoding
    from enum import Enum

    func_n = inspect.currentframe().f_code.co_name
    f_new_xlsx = f'{get_pn(f_xls)}.xlsx'

    try:
        if ".xls" == get_x(f_xls):
            if not os.path.exists(f_xls):
                pk_print(f"{func_n}() {get_x(f_xls)} 는 처리할 수 없는 확장자입니다.", print_color='red')
                return
    except CustomErrorUtil as e:
        pk_print(f"{func_n}() {get_x(f_xls)} 는 처리할 수 없는 확장자입니다.", print_color='red')
        return

    try:
        df = pd.read_excel(f_xls, engine='openpyxl')  # openpyxl 에만 적용이 되는 함수.. 에러 소지 있음.
        # if not os.path.exists(new_file_xlsx):
        df.to_excel(f_new_xlsx, index=False)
    except BadZipFile as e:
        # 유효데이터만 파싱하여 데이터프레임 으로 변환 후 Excel f로 저장
        # read_html() 를 이용하면 손상된 f을 열 수 ...
        print_yellow(f"확장자가 {get_x(f_xls)} 손상된 f 같습니다. 복구를 시도합니다")
        encoding: Enum
        df = pd.read_html(f_xls, encoding=Encoding.UTF8.value)
        # print_ment_blue(df)
        # print_ment_blue(df[0]) # 이번 데이터 구조의 특성상, 불필요 데이터
        # print_ment_blue(df[1]) # 이번 데이터 구조의 특성상, 불필요 데이터
        # print_ment_blue(df[2]) # 이번 데이터 구조의 특성상, 유효 데이터 , 데이터프레임 모든컬럼
        # print_ment_blue(df[2].get(0)) # 데이터프레임 첫번쨰컬럼
        # print_ment_blue(df[2].get(1)) # 데이터프레임 두번쨰컬럼
        # print_ment_blue(df[2].get(2)) #
        # print_ment_blue(df[2].get(6)) #
        # 이번 데이터에서 필요한 데이터, # 0 ~ 6 컬럼까지 유효
        df = df[2]  # 이번 데이터 구조의 특성상, 유효 데이터
        # df_selected=df[[0, 1, 2, 3, 4, 5, 6]]
        # df_selected=df[df.columns[0:7]]
        # df_selected=df[df.columns[7:]]
        # df_selected=df[df.columns[:5]]
        # df_selected=df[df.columns[1:5]]
        df = df[df.columns[:]]  # 모든 컬럼
        # print(rf'df : {df}')
        df.to_excel(f_new_xlsx, index=False)

        # # txt 로 변환
        # file_recovery=f"{get_target_as_pn(pnx_todo)}.txt"
        # print(rf'''file_recovery : {file_recovery}''')
        # shutil.copy2(pnx_todo,file_recovery)

        # # html 로 변환하여, HTML 테이블을 데이터프레임으로 저장
        # file_recovery=f"{get_target_as_pn(pnx_todo)}.html"
        # print(rf'''file_recovery : {file_recovery}''')
        # shutil.copy2(pnx_todo,file_recovery)
        # with open(file=file_recovery,mode= 'r', encoding=Encoding.UTF8.value) as file:
        #     html_content=file.read()
        # soup=BeautifulSoup(html_content, "lxml")
        # # results=soup.find_all(href=re.compile("magnet"), id='link1') # <a class="sister" href="http://example.com/magnet" id="link1">Elsie</a>
        # # results=soup.find_all("body")
        # # results=soup.find_all("html")
        # tables=soup.find_all("table")
        # table_selected=tables[2]  # 3번째 테이블 선택
        # df=pd.read_html(str(table_selected))[0]
        # print_ment_blue(df)

    except Exception as e:
        pk_print(f"{func_n}() \n {traceback.format_exc()}", print_color='red')
    print_success(f"{func_n}(), success")


def convert_as_zip_with_timestamp(f):
    import os
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    starting_d = get_d_working()
    try:
        target_dirname = os.path.dirname(f)
        target_dirname_dirname = os.path.dirname(target_dirname)
        target_basename = os.path.basename(f).split(".")[0]
        target_zip = rf'$zip_{target_basename}.zip'
        target_yyyy_mm_dd_HH_MM_SS_zip = rf'{target_basename} - {get_time_as_("%Y %m %d %H %M %S")}.zip'
        # pk_print(rf'# target_dirname_dirname 로 이동')
        pk_chdir(target_dirname_dirname)
        # pk_print(rf'부모d로 백업')
        cmd = f'bandizip.exe c "{target_zip}" "{f}"'
        cmd_to_os_like_person_as_admin(cmd)
        # pk_print(rf'이름변경')
        cmd = f'ren "{target_zip}" "$deleted_{target_yyyy_mm_dd_HH_MM_SS_zip}"'
        cmd_to_os_like_person_as_admin(cmd)
        # pk_print(rf'부모d에서 백업될 d로 이동')
        cmd = f'move "$deleted_{target_yyyy_mm_dd_HH_MM_SS_zip}" "{target_dirname}"'
        cmd_to_os_like_person_as_admin(cmd)
        # pk_print(rf'백업될 d로 이동')
        pk_chdir(target_dirname)
        # pk_print(str_working="os.getcwd()")
        # pk_print(os.getcwd())
        # pk_print(str_working="원본f삭제")
        os.remove(f)
    except:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
    finally:
        pk_print(rf'프로젝트 d로 이동')
        pk_chdir(starting_d)


def convert_img_to_img_blurred(img_pnx):
    import inspect
    from PIL import Image, ImageFilter
    func_n = inspect.currentframe().f_code.co_name
    img_converted = Image.open(img_pnx).filter(ImageFilter.GaussianBlur(10))  # 가우시안 블러 적용 # 숫자크면 많이흐려짐
    img_converted.show()


def convert_img_to_img_grey(img_pnx):
    import inspect
    from PIL import Image
    func_n = inspect.currentframe().f_code.co_name
    img_converted = Image.open(img_pnx).convert("L")
    img_converted.show()


def convert_img_to_img_resized(img_pnx, width_px, height_px):
    import inspect
    from PIL import Image
    func_n = inspect.currentframe().f_code.co_name
    img_converted = Image.open(img_pnx).resize((width_px, height_px))
    img_converted.show()


def convert_img_to_img_cropped(img_pnx, abs_x: int, abs_y: int, width_px: int, height_px: int):
    import inspect
    from PIL import Image
    func_n = inspect.currentframe().f_code.co_name
    img_converted = Image.open(img_pnx).crop((abs_x, abs_y, width_px, height_px))
    img_converted.show()


def convert_img_to_img_rotated(img_pnx, degree: int):
    import inspect
    import os
    from PIL import Image
    func_n = inspect.currentframe().f_code.co_name
    img_converted = Image.open(img_pnx).rotate(degree)
    img_converted.show()
    img_converted.save(f"{os.path.dirname(img_pnx)}   {os.path.splitext(img_pnx)[0]}_$flipped_h{os.path.splitext(img_pnx)[1]}")


def convert_img_to_img_flipped_horizontally(img_pnx):
    # todo : fix
    # import os
    # from pkg_py.pk_colorful_cli_util import pk_print
    # from PIL import Image
    # img_converted = Image.open(img_pnx).transpose(Image.FLIP_LEFT_RIGHT)
    # img_converted.show()
    # img_converted.save(f"{os.path.dirname(img_pnx)}   {os.path.splitext(img_pnx)[0]}_$flipped_h{os.path.splitext(img_pnx)[1]}")
    pass


def convert_img_to_img_flipped_vertical(img_pnx):
    # todo : fix
    # import os
    # from pkg_py.pk_colorful_cli_util import pk_print
    # from PIL import Image
    # img_converted = Image.open(img_pnx).transpose(Image.FLIP_TOP_BOTTOM)
    # img_converted.show()
    # img_converted.save(f"{os.path.dirname(img_pnx)}   {os.path.splitext(img_pnx)[0]}_$flipped_v{os.path.splitext(img_pnx)[1]}")
    pass


def convert_img_to_img_watermarked(img_pnx):
    from PIL import Image, ImageFont, ImageDraw

    # step2.워터마크 삽입할 이미지 불러오기
    img = Image.open('cat.jpg')
    width, height = img.size

    # step3.그림판에 이미지를 그대로 붙여넣는 느낌의 Draw() 함수
    draw = ImageDraw.Draw(img)

    # step4.삽입할 워터마크 문자
    text = "봵 워터마크"

    # step5.삽입할 문자의 폰트 설정
    font = ImageFont.truetype('/Users/sangwoo/Downloads/나눔 글꼴/나눔손글씨_펜/NanumPen.ttf', 30)

    # step6.삽입할 문자의 높이, 너비 정보 가져오기
    width_txt, height_txt = draw.textsize(text, font)  # noqa

    # step7.워터마크 위치 설정
    margin = 10
    x = width - width_txt - margin
    y = height - height_txt - margin

    # step8.텍스트 적용하기
    draw.text((x, y), text, fill='blue', font=font)

    # step9.이미지 출력
    img.show()

    # step10.현재작업 경로에 완성 이미지 저장
    img.save("cat_watermakr.jpg")  # 절대경로 되는지 확인해보자.


def assist_to_kill_window_duplicated_list():
    from pkg_py.pk_colorful_cli_util import pk_print
    import threading

    flag_to_detect_enter = 0  # 루프제어용

    def listen_enter():
        global flag_to_detect_enter
        while 1:
            input()
            flag_to_detect_enter = 1

    def run_main_loop():
        global flag_to_detect_enter
        previous_windows_opened_list = get_window_opened_list()
        len_before: int = 0
        while 1:
            # kill_windows_duplicated
            current_windows_opened_list = get_window_opened_list()
            len_current = len(current_windows_opened_list)
            if len_before != len_current:
                pk_print(f'''len_before={len_before}  {'%%%FOO%%%' if LTA else ''}''')
                pk_print(f'''len_current={len_current}  {'%%%FOO%%%' if LTA else ''}''')
                print_iterable_as_vertical(item_iterable=current_windows_opened_list, item_iterable_n="current_windows_opened_list")
                len_before = len_current
            if len(current_windows_opened_list) != len(previous_windows_opened_list):
                # pk_print(f'''len(current_windows_opened_list)={len(current_windows_opened_list)} len(previous_windows_opened_list)={len(previous_windows_opened_list)}  {'%%%FOO%%%' if LTA else ''}''',print_color="blue")
                kill_explorer_window_duplicated_list()
                previous_windows_opened_list = current_windows_opened_list
            pk_sleep(seconds=1)

    # start thread ( in background )
    thread = threading.Thread(target=listen_enter, daemon=True)
    thread.start()

    # run main loop
    run_main_loop()


def rsync_d_remote(d_pnx):
    """이게 뭐냐면 외부망에 있는 d를 동기화. 리눅스 rsync 에 의존하는 기술"""
    from pkg_py.pk_core_constants import PkMents2025Korean
    # todo : chore :

    if not is_internet_connected():
        raise
    pk_speak(PkMents2025Korean.NOT_PREPARED_YET)
    pass


def copy_pnx_from_local_os_to_remote_os_via_rsync(d_pnx):
    # todo
    import os
    import shutil
    import traceback
    from dirsync import sync
    from pkg_py.pk_colorful_cli_util import pk_print
    if not is_internet_connected():
        raise
    try:

        d_pnx = d_pnx
        d_pnx_new = rf"{d_pnx}_sync"
        pk_print(f'''d_pnx_new={d_pnx_new}  {'%%%FOO%%%' if LTA else ''}''')

        # 기존 작업 d가 없는 경우
        if not os.path.exists(d_pnx_new):
            shutil.copytree(d_pnx, d_pnx_new)
        else:
            # remove_target_parmanently(DIRSYNC_LOG)
            # # logging 설정 및 DIRSYNC_LOG 생성
            # logging.basicConfig(filename=DIRSYNC_LOG, level=logging.DEBUG, filemode='w', encoding=Encoding.UTF8.value)
            # dirsync_logger=logging.getLogger('dirsync')

            # result_sync=sync(sourcedir=pnx_todo, targetdir=pnx_todo_new, action='sync', verbose=True, logger=dirsync_logger) #success
            # result_sync=sync(sourcedir=pnx_todo, targetdir=pnx_todo_new, action="sync", options=["--purge", "--verbose", "--force"], logger=dirsync_logger)
            result_sync = sync(sourcedir=d_pnx, targetdir=d_pnx_new, action="sync", options=["--purge", "--verbose", "--force"])
            # sync(sourcedir=pnx_todo_new, targetdir=pnx_todo , action='sync',verbose=True , logger=dirsync_logger)  # 양방향 으로 로컬동기화d를 만드려면 sync() 코드를 추가하여 sync() 함수가 총 2개가 targetdir 간에 sourcedir 서로 자리바뀌어 있도록 작성
            # if result_sync:
            #     # DIRSYNC_LOG 내용 가져오기
            #     if os.path.exists(DIRSYNC_LOG):
            #         lines=get_lines_of_file(DIRSYNC_LOG)[-4:-1]
            #         lines=[sample.strip() for sample in lines]
            #         for sample in lines:
            #             # print(translate_eng_to_kor_via_googletrans(sample))
            #             print_ment_light_white(rf'sample : {sample}')
            #         print_ment_light_white(rf'len(lines) : {len(lines)}')
            #         remove_target_parmanently(DIRSYNC_LOG)
            #         lines=[x for x in lines if x.strip("\n")]  # 리스트 요소 "" remove,  from ["", A] to [A]       [""] to []
            #         # speak_ments(f"타겟의 동기화가 성공 되었습니다", sleep_after_play=0.65, thread_join_mode=True)
            #         print_ment_success("타겟동기화 성공")
            #         GuiUtil.pop_up_as_complete(title_="작업성공보고", ment=f"타겟의 동기화가 성공 되었습니다\n{pnx_todo_new}", auto_click_positive_btn_after_seconds=1)
            pk_print(working_str="타겟동기화 성공")
    except:
        pk_print("타겟동기화 실패")
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')

    # sources=[r'C:\Users\seon\Desktop\오리지널',
    #            r'C:\Users\seon\Desktop\오리지널2',
    #            r'C:\Users\seon\Desktop\오리지널3']
    # pnxs=[r'C:\Users\seon\Desktop\테스트',
    #            r'C:\Users\seon\Desktop\테스트2',
    #            r'C:\Users\seon\Desktop\테스트3']
    # total=dict(zip(sources, pnxs))
    # for source, target in total.items():
    #     sync(sourcedir=source, targetdir=target, action='sync', verbose=True, purge=True, create=True,  delete=True, update=True)  # 이것이 sync() default 파라미터들이다.
    #     sync(sourcedir=source, targetdir=target, action='sync', verbose=True, purge=True, create=True,  delete=True, update=True)  # purge=True 이면 targetdir 에 이물질 같은 f이 있으면 삭제를 합니다, delete=False 이면 어떻게 되는거지? # verbose=True 이면 상세설명출력

    # 윈도우 d를 WSL 경로로 변환
    # try:
    #     server_time=get_time_as_('%Y_%m_%d_%H_%M_%S_%f')
    #     pnx_todo=rf"/mnt/c/{pnx_todo}" \ 에서 / 로 바꿔야한다
    #     # pnx_todo_new=rf"/mnt/c/{pnx_todo}_{server_time}"
    #     pnx_todo_new=rf"/mnt/c/{pnx_todo}_sync"
    #     cmd=f"rsync -avz {pnx_todo} {pnx_todo_new}"
    #     print(cmd)
    #     subprocess.call(cmd, shell=True)
    # except:
    #     pass


def generate_token_f(f, initial_str):
    from pkg_py.pk_colorful_cli_util import pk_print
    if not does_pnx_exist(pnx=f):
        ensure_pnx_made(pnx=f, mode="f")
    pk_print(f'''f={f}  {'%%%FOO%%%' if LTA else ''}''')
    line_list = get_list_from_f(f=f)
    line_list = get_list_removed_by_removing_runtine(working_list=line_list)
    # print_iterable_as_vertical(item_iterable=line_list, item_iterable_n='line_list')
    if len(line_list) == 0:
        token = initial_str
        if initial_str != "":
            write_str_to_f(txt=f"{token}\n", f=f, mode="w")
            pk_print(working_str=rf'''token is generated token={token}  {'%%%FOO%%%' if LTA else ''}''', print_color='green')


def get_token_from_f_token(f_token, initial_str):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    generate_token_f(f=f_token, initial_str=initial_str)
    pk_print(working_str=rf'''f_token_nx="{get_nx(f_token)}"  {'%%%FOO%%%' if LTA else ''}''')
    token = get_str_from_txt_f(pnx=f_token)
    token = token.replace("\n", "")
    token = token.strip()
    pk_print(working_str=rf'''token="{token}"  {'%%%FOO%%%' if LTA else ''}''')
    if token == "" or token == "\n":
        pk_print(working_str=rf'''token is empty  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        import ipdb
        ipdb.set_trace()
    return token


# @measure_time
def get_list_from_f(f):
    from pkg_py.pk_core_constants import Encoding
    import os
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print

    f = get_pnx_os_style(f)
    pk_print(f'''f={f}''')

    if f is None:
        return []

    try:
        if os.path.exists(f):
            # with open(file=f,mode= 'r', encoding=Encoding.UTF8.value) as f:
            # with open(file=f, 'r', errors='ignore') as f:
            with open(file=f, mode='r', encoding=Encoding.UTF8.value, errors='ignore') as f:
                lines = f.readlines()  # from file.ext to ["한줄","한줄","한줄"]
                # mkr_f 내용을 디스크에 강제로 기록
                # os.fsync(f.fileno())
                if lines is None:
                    return []
                return lines
    except:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}" ''', print_color='red')


def get_str_from_f(f):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import Encoding
    import os
    import traceback
    import inspect

    func_n = inspect.currentframe().f_code.co_name

    pk_print(f'''f={f}''')

    if f is None:
        return ""

    try:
        if os.path.exists(f):
            # f 읽기
            with open(file=f, mode='r', encoding=Encoding.UTF8.value, errors='ignore') as f:
                content = f.read()  # f 내용을 문자열로 읽기
                if content is None:
                    return ""
                return content
    except:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}" ''', print_color='red')
        return ""


def remove_pnx_parmanently(pnx):
    import inspect
    import os
    import platform
    import shutil
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PROJECT
    func_n = inspect.currentframe().f_code.co_name
    if platform.system() == 'Windows':
        try:
            if validate_and_return(value=pnx) is not False:
                pk_chdir(os.path.dirname(pnx))
                if os.path.exists(pnx):
                    if is_d(pnx):
                        # shutil.rmtree(pnx_todo)
                        # if is_d(pnx_todo):
                        #     run_via_cmd_exe(rf'echo y | rmdir /s "{pnx_todo}"')
                        move_pnx_to_pk_recycle_bin(pnx)
                    elif is_f(pnx):
                        # os.remove(pnx_todo)
                        # if is_f(pnx_todo):
                        #     run_via_cmd_exe(rf'echo y | del /f "{pnx_todo}"')
                        move_pnx_to_pk_recycle_bin(pnx)

                    # pk_print(f" {'%%%FOO%%%' if LTA else ''} green {texts}" , print_color='blue)
                    # pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        except:
            pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')

        finally:
            pk_chdir(D_PROJECT)
    else:
        func_n = inspect.currentframe().f_code.co_name
        try:
            if validate_and_return(value=pnx) is not False:
                pk_chdir(os.path.dirname(pnx))
                if os.path.exists(pnx):
                    if is_d(pnx):
                        shutil.rmtree(pnx)
                    elif is_f(pnx):
                        os.remove(pnx)
        except:
            pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')

        finally:
            pk_chdir(D_PROJECT)


def get_pnx_list_with_mtime_without_f_list_to_exclude(d_src):
    import os
    from pkg_py.pk_core_constants import F_LOCAL_PKG_CACHE, F_SUCCESS_LOG, F_DB_YAML
    f_list_to_exclude = [
        F_DB_YAML,
        F_SUCCESS_LOG,
        F_LOCAL_PKG_CACHE,
    ]
    f_list_of_d = []
    for root, _, f_nx_list in os.walk(d_src):
        for f_nx in f_nx_list:
            if not f_nx.endswith(".mp3"):  # 모든 mp3 f을 배제
                f = os.path.join(root, f_nx)
                if f not in f_list_to_exclude:
                    # files_of_d[rf"{file_path}"]=os.path.getmtime(file_path)
                    f_list_of_d.append([f, os.path.getmtime(f)])
    return f_list_of_d


def get_added_f_list(previous_state, current_state):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    return DataStructureUtil.get_elements_that_list1_only_have(list1=current_state, list2=previous_state)


def get_deleted_f_list(previous_state, current_state):
    from pkg_py.pk_decide_program_performance import DataStructureUtil
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    return DataStructureUtil.get_elements_that_list1_only_have(list1=previous_state, list2=current_state)


def get_modified_f_list(previous_state, current_state):
    import inspect
    from pkg_py.pk_decide_program_performance import DataStructureUtil
    func_n = inspect.currentframe().f_code.co_name
    return DataStructureUtil.get_different_elements(list1=current_state, list2=previous_state)


def ensure_pnx_made(pnx, mode, script_list=None, mode_script_overwrite=0):
    from pkg_py.pk_colorful_cli_util import pk_print
    import traceback
    import inspect
    import os
    pnx = get_pnx_os_style(pnx=pnx)
    func_n = inspect.currentframe().f_code.co_name
    state_pnx_duplicated = 0
    if mode == "f":
        if not does_pnx_exist(pnx=pnx):
            try:
                os.makedirs(os.path.dirname(pnx))
            except:
                pass
            cmd_to_os(rf'chcp 65001 >nul')
            cmd_to_os(rf'echo. > "{pnx}"')
        if script_list:
            while 1:
                if does_pnx_exist(pnx):
                    state_pnx_duplicated = 1
                    break
                elif does_pnx_exist(pnx):
                    state_pnx_duplicated = 0
                    break
            if state_pnx_duplicated == 1:
                pk_print(f'''state_pnx_duplicated={state_pnx_duplicated} {'%%%FOO%%%' if LTA else ''}''')
                # cmd_to_os(f'code {pnx}')
            if os.path.exists(pnx):
                # write script to f
                mode_open = None
                if mode_script_overwrite == 1:
                    mode_open = 'w'
                elif mode_script_overwrite == 0:
                    mode_open = 'a'
                with open(file=pnx, mode=mode_open, newline='\r\n') as f_obj:  # CRLF 개행 설정
                    # with open(file=pnx, mode=mode_open, newline='\n') as f_obj:  # LF 개행
                    for line in script_list:
                        f_obj.write(f"{line}\n")
                        pk_print(f'''{line} written to {pnx} {'%%%FOO%%%' if LTA else ''}''')
                    std_list = cmd_to_os(f'type {pnx}')
                    # 마지막줄 쓰였는지 확인
                    last_line = script_list[-1].replace("\n", "")
                    if last_line == std_list[-1].replace("\n", ""):
                        pk_print(f'''{last_line} written to {pnx} {'%%%FOO%%%' if LTA else ''}''', print_color='green')
                    else:
                        pk_print(f'''{last_line} written to {pnx} {'%%%FOO%%%' if LTA else ''}''', print_color='red')
                        raise
    elif mode == "d":
        if not os.path.exists(pnx):
            os.makedirs(pnx)
    else:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        return


def merge_d_list(d_list: List[str]):
    import os
    import string
    from pkg_py.pk_colorful_cli_util import pk_print, print_success

    # f명들을 나열한다.
    # f을 깊이 별로 나열을 하고 깊이가 깊은 것부터 시작해서 깊이가 낮은 것으로 처리해 나간다

    d_list = [x for x in d_list if x.strip()]  # 리스트 요소 "" remove,  from ["", A] to [A]    from [""] to []
    d_list = [x.strip() for x in d_list]  # 리스트 각 요소 strip(),  ["   A", "B   "] from ["A", "B"]
    d_list = [x.strip("\"") for x in d_list]  # 리스트 각 요소 strip("\""),  [""A""] from ["A"]
    d_list = [x.strip("\'") for x in d_list]  # 리스트 각 요소 strip("\'),  ["'A'""] from ["A"]

    pk_print(f'''d_list={d_list}  {'%%%FOO%%%' if LTA else ''}''')

    if 0 == len(d_list):
        pk_speak_v2("pnx가 아무것도 입력되지 않았습니다", comma_delay=0.98)
        return
    elif 1 == len(d_list):
        pk_speak_v2("하나의 pnx로는 머지를 시도할수 없습니다, 여러개의 pnx들을 입력해주세요", comma_delay=0.98)
        return
    elif 1 < len(d_list):
        for index, d in enumerate(d_list):
            connected_drives = []
            for drive_letter in string.ascii_uppercase:
                drive_path = drive_letter + ":\\"
                if os.path.exists(drive_path):
                    connected_drives.append(drive_path)
                    if d == drive_path:
                        pk_speak_v2("입력된 pnx는 너무 광범위하여, 진행할 수 없도록 설정되어 있습니다", comma_delay=0.98)
                        break

        # make_d_leaf(D_EMPTY)

        # indices_to_remove=[]  # remove할 인덱스를 기록할 리스트
        # for index, directory in enumerate(directoryies_):
        #     if is_d(directory):
        #         if is_empty_directory(directory):
        #             move_pnx_without_overwrite(pnx_todo=directory, dst=D_EMPTY)
        #             indices_to_remove.append(index)
        # for index in indices_to_remove:
        #     directoryies_.pop(index)

        # for index, directory in enumerate(directoryies_):
        #     if directory == "":
        #         speak_ments("하나 이상의 pnx가 공백으로 입력되었습니다", sleep_after_play=0.65)
        #         return
        #     if not os.path.exists(directory):
        #         speak_ments("하나 이상의 pnx가 존재하지 않습니다", sleep_after_play=0.65)
        #         return

        pk_print("빈 트리 리프d별로 해체한 뒤 remove")
        f_list_to_move = []
        for index, d in enumerate(d_list):
            for root, _, f_nx_list in os.walk(d, topdown=True):
                for f_nx in f_nx_list:
                    f_list_to_move.append(rf"{root}\{f_nx}")
        [pk_print(rf'f_to_move : {f_to_move}') for f_to_move in f_list_to_move]
        pk_print(f'''type(f_list_to_move)={type(f_list_to_move)}  {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''len(f_list_to_move)={len(f_list_to_move)}  {'%%%FOO%%%' if LTA else ''}''')
        dst = rf"{os.path.dirname(d_list[0])}\{os.path.basename(d_list[0]).replace("_$merged", "")}_$merged"
        ensure_pnx_made(dst, mode="d")
        pk_print(rf'dst : {dst}')

        for f_to_move in f_list_to_move:
            move_pnx(pnx=f_to_move, d_dst=dst)

        # 이 함수는 캐싱문제를 해결하지 못함.
        def count_f_in_folder(folder_path):
            f_cnt = 0
            for _, _, f_nx_list in os.walk(folder_path):
                f_cnt += len(f_nx_list)
            return f_cnt

        # 이 함수는 캐싱문제를 해결하지 못함.
        # def count_files_in_folder(folder_path):

        #     file_count=0
        #     with os.scandir(folder_path) as entries:
        #         for entry in entries:
        #             if entry.is_file():
        #                 file_count += 1
        #     return file_count

        # 분명히 f이 들어있는데 개수가 0개로 나오네  캐싱때문에 그럴 수 있어?
        # 운영체제 성능향상을 위한 d정보 캐싱으로 갱신이 안될 수 있음.
        # d를 다른 위치로 이동한 후 다시 이동합니다. 이렇게 하면 f 시스템이 d의 변경을 감지하고 캐시를 갱신할 수 있습니다.
        # current_path=os.getcwd()
        # chdir(os.path.dirname(current_path)) # 부모 d로 이동
        # chdir(current_path)

        # [fail] 분명히 가 틀렸다. 운영체제의 캐싱이 문제가 아닌,
        # 로직을 잘못 만든 것이었다.
        # d 변수를 엉뚱하게 초기화하였기 때문이다.
        # d 를 d_ 로 별도로 호출해서 해소하였다.

        # empty d 리프단위로 분해하여 이동
        while 1:
            d_list_to_move = []
            for index, d in enumerate(d_list):
                for root, d_nx_list, f_nx_list in os.walk(d, topdown=False):
                    for d_nx in d_nx_list:
                        f_cnt = count_f_in_folder(rf"{root}\{d_nx}")
                        if f_cnt == 0:
                            d_list_to_move.append(rf"{root}\{d_nx}")

            [pk_print(sample) for sample in d_list_to_move]
            pk_print(f'''d_list_to_move={d_list_to_move}''')
            pk_print(rf'''type(d_list_to_move)={type(d_list_to_move)}''')
            pk_print(rf'''len(d_list_to_move)={len(d_list_to_move)}''')

            pk_print(rf'dst : {dst}')
            ensure_pnx_made(dst, mode="d")

            if len(d_list_to_move) == 0:
                break

            for d_to_move in d_list_to_move:
                move_pnx(pnx=d_to_move, d_dst=dst)

        for d in d_list:
            gather_empty_d(d_working=d)

        print_success(rf'd 머지를 완료했습니다')


# 프로그램 PID 출력
def get_current_program_pid():
    import inspect
    import subprocess
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    pro = subprocess.check_output(
        rf'powershell (Get-WmiObject Win32_Process -Filter ProcessId=$PID).ParentProcessId', shell=True).decode(
        'utf-8')  # 실험해보니 subprocess.check_output(cmd,shell=True).decode('utf-8') 코드는 프로세스가 알아서 죽는 것 같다. 모르겠는데 " " 가 있어야 동작함
    lines = pro.split('\n')
    pids = []
    for line in lines:
        if "" != line.strip():
            pid = line
            pids.append(pid)
            pk_print(f'pid: {pid}', print_color='blue')
    return pids


def get_target_bite(start_path='.'):
    import os
    total_size = 0
    for root, d_nx_list, f_nx_list in os.walk(start_path):
        for f_nx in f_nx_list:
            f = os.path.join(root, f_nx)
            # skip if it is symbolic link
            if not os.path.islink(f):
                total_size += os.path.getsize(f)
    return total_size


def get_target_megabite(target_path):
    return get_target_bite(target_path.strip()) / 1024 ** 2


def get_target_gigabite(target_path):
    return get_target_bite(target_path.strip()) / 1024 ** 3


def open_recycle_bin():
    cmd_to_os(cmd='explorer.exe shell:RecycleBinFolder')


def xcopy_with_overwrite(pnx, pnx_future):
    import inspect
    import subprocess
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    try:
        result = cmd_to_os_like_person_as_admin(rf'echo a | xcopy "{pnx}" "{pnx_future}" /e /h /k /y')
        if result == subprocess.CalledProcessError:
            if is_f(pnx):
                cmd_to_os_like_person_as_admin(rf'echo f | xcopy "{pnx}" "{pnx_future}" /e /h /k /y')
            else:
                cmd_to_os_like_person_as_admin(rf'echo d | xcopy "{pnx}" "{pnx_future}" /e /h /k /y')
    except Exception:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')


def xcopy_without_overwrite(pnx, pnx_future):
    import inspect
    import os
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    try:
        if os.path.exists(pnx_future):
            pnx_future = rf"{os.path.dirname(pnx_future)}\{os.path.basename(pnx)[0]}_{get_time_as_('%Y_%m_%d_%H_%M_%S_%f')}{os.path.basename(pnx)[1]}"
        cmd_to_os_like_person_as_admin(rf'echo a | xcopy "{pnx}" "{pnx_future}" /e /h /k')
        if is_f(pnx):
            cmd_to_os_like_person_as_admin(rf'echo f | xcopy "{pnx}" "{pnx_future}" /e /h /k')
        else:
            cmd_to_os_like_person_as_admin(rf'echo d | xcopy "{pnx}" "{pnx_future}" /e /h /k')
    except Exception:
        print(rf"subprocess.CalledProcessError 가 발생하여 재시도를 수행합니다 {inspect.currentframe().f_code.co_name}")
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')


def move_pnx_v1(pnx, d_dst, with_overwrite=0, sequential_mode=0, timestamp_mode=0):
    import os
    import random
    import re
    import shutil
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    try:
        if with_overwrite == 0:
            pnx_p = os.path.dirname(pnx)
            time_pattern = rf"{get_time_as_('now')}"
            pnx_n = get_n(pnx)
            pnx_x = get_x(pnx)
            pnx_with_timestamp = rf'{pnx_p}\{re.sub(pattern=r'\d{4}_\d{2}_\d{2}_(월|화|수|목|금|토|일)_\d{2}_\d{2}_\d{2}_\d{3}', repl='', string=pnx_n)}_{time_pattern}{random.randint(10, 99)}{pnx_x}'
            src_type = None
            if is_f(pnx):
                src_type = 'f'
            elif is_d(pnx):
                src_type = 'd'
            dst_n_timestamp_x = rf'{d_dst}\{get_nx(pnx_with_timestamp)}'

            if d_dst != os.path.dirname(pnx_with_timestamp):
                os.rename(pnx, pnx_with_timestamp)
                if not does_pnx_exist(pnx_with_timestamp):
                    shutil.move(src=pnx_with_timestamp, dst=d_dst)
                if LTA:
                    pk_print(working_str=rf'''time_pattern="{time_pattern}"  {'%%%FOO%%%' if LTA else ''}''')
                    pk_print(working_str=rf'''src_type="{src_type:5s}" pnx_with_timestamp="{pnx_with_timestamp:<150}" dst="{d_dst:<50}" {'%%%FOO%%%' if LTA else ''}''', print_color='green')
                    pk_print(working_str=rf'''src_type={src_type} pnx_with_timestamp={pnx_with_timestamp.replace('\n', ''):<150} dst={d_dst.replace('\n', ''):<50}  {'%%%FOO%%%' if LTA else ''}''', print_color='green')
                pk_print(working_str=rf'''src_type={src_type} pnx_with_timestamp={pnx_with_timestamp:<150} dst={d_dst:<50}  {'%%%FOO%%%' if LTA else ''}'''.replace('\n', ''), print_color='green')
        elif with_overwrite == 1:
            if not is_f(pnx):
                pk_print(f"Source file does not exist: {pnx}")

            d_dst = os.path.dirname(d_dst)
            if d_dst and not os.path.exists(d_dst):
                os.makedirs(d_dst)
            try:
                if os.path.exists(d_dst):
                    os.remove(d_dst)  # Remove the existing file
                shutil.move(pnx, d_dst)
                pk_print(f"Successfully moved '{pnx}' to '{d_dst}'", print_color='green')
            except Exception as e:
                pk_print(f"Failed to move file: {e}")

    except:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')


def move_pnx_v2(pnx, d_dst, with_overwrite=0, sequential_mode=0, timestamp_mode=0):
    import os
    import shutil
    import traceback
    from datetime import datetime
    from pkg_py.pk_colorful_cli_util import pk_print

    def generate_sequential_pnx(dst_base_path, base_name, ext):
        for i in range(1, 1000):
            candidate = os.path.join(dst_base_path, f"({i})_{base_name}{ext}")
            if not os.path.exists(candidate):
                return candidate
        raise RuntimeError("Too many duplicates to resolve with sequential mode.")

    def generate_timestamped_pnx(dst_base_path, base_name, ext):
        ts_prefix = datetime.now().strftime("%Y%m%d_%H%M%S_%f")[:-3]
        candidate = os.path.join(dst_base_path, f"{ts_prefix}_{base_name}{ext}")
        return candidate

    try:
        sequential_mode = int(sequential_mode)
        timestamp_mode = int(timestamp_mode)

        if with_overwrite == 0:
            pnx_p = os.path.dirname(pnx)
            pnx_n = get_n(pnx)
            pnx_x = get_x(pnx)
            dst_base = d_dst

            src_type = 'f' if is_f(pnx) else 'd' if is_d(pnx) else 'unknown'
            dst_pnx = os.path.join(dst_base, get_nx(pnx))

            if os.path.exists(dst_pnx):
                base_name, ext = os.path.splitext(get_nx(pnx))
                if timestamp_mode == 1:
                    dst_pnx = generate_timestamped_pnx(dst_base, base_name, ext)
                elif sequential_mode == 1:
                    dst_pnx = generate_sequential_pnx(dst_base, base_name, ext)
                else:
                    pk_print(f"[DUPLICATE] '{dst_pnx}' 존재함 → 중복 회피 모드 꺼져 있어 이동 중단", print_color='red')
                    return

            if not os.path.exists(d_dst):
                os.makedirs(d_dst)

            shutil.move(pnx, dst_pnx)

            if LTA:
                pk_print(f"src_type={src_type} dst_pnx={dst_pnx:<150} dst={d_dst:<50}  {'%%%FOO%%%' if LTA else ''}", print_color='green')
            else:
                pk_print(f"[MOVE] '{pnx}' → '{dst_pnx}'", print_color='green')

        elif with_overwrite == 1:
            if not is_f(pnx):
                pk_print(f"[ERROR] Source file does not exist: {pnx}", print_color='red')
                return

            d_dst = os.path.dirname(d_dst)
            if d_dst and not os.path.exists(d_dst):
                os.makedirs(d_dst)
            try:
                if os.path.exists(d_dst):
                    os.remove(d_dst)
                shutil.move(pnx, d_dst)
                pk_print(f"[OVERWRITE MOVE] '{pnx}' → '{d_dst}'", print_color='green')
            except Exception as e:
                pk_print(f"[ERROR] Failed to move file: {e}", print_color='red')

    except Exception:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')


def move_pnx(pnx, d_dst, with_overwrite=0, sequential_mode=0, timestamp_mode=0):
    move_pnx_v2(pnx=pnx, d_dst=d_dst, with_overwrite=with_overwrite, sequential_mode=sequential_mode)


def move_without_overwrite_via_robocopy(src, dst):  # 명령어 자체가 안되는데 /mir 은 되는데 /move 안된다
    import inspect
    import os
    import traceback

    from pkg_py.pk_colorful_cli_util import pk_print
    src = src
    func_n = inspect.currentframe().f_code.co_name
    try:
        pk_print(f'타겟이동 시도')
        # run_via_cmd_exe(rf'robocopy "{pnx_todo}" "{dst}" /MOVE')
        if os.path.exists(rf'{dst}\{os.path.dirname(src)}'):
            move_pnx_to_pk_recycle_bin(src)

    except Exception:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')


# def write_str_to_f(txt_str, f, mode="a", encoding=None):
#     from pkg_py.pk_core_constants import BLANK, Encoding
#     if encoding is None:
#         encoding = Encoding.UTF8
#     with open(file=f, mode=mode, encoding=encoding.value) as f:
#         f.write(txt_str)

def write_str_to_f(txt: str, f: str, mode: str = "a", encoding=None) -> None:
    """
    문자열을  f에 저장하는 함수.

    :param text: 저장할 문자열
    :param f: f 경로
    :param mode: f 열기 모드 (기본값: "a" - 추가 모드)
    :param encoding: 인코딩 방식 (기본값: Encoding.UTF8)
    """
    from pkg_py.pk_core_constants import Encoding
    from enum import Enum
    encoding: Enum
    # if encoding is None:
    #     encoding = Encoding.UTF8
    encoding = encoding or Encoding.UTF8  # None 또는 False 인 경우 Encoding.UTF8를 할당 (**"단축 평가(short-circuit evaluation)를 활용한 기본값 할당"**)

    with open(file=f, mode=mode, encoding=encoding.value) as file:
        file.write(txt)


def write_list_to_f(working_list, f, mode, encoding=None, line_feed_mode=1, head_line_mode=True):
    from pkg_py.pk_core_constants import Encoding
    from enum import Enum
    encoding: Enum
    encoding = encoding or Encoding.UTF8
    f = get_pnx_os_style(pnx=f)
    with open(file=f, mode=mode, encoding=encoding.value) as f_tmp:
        if head_line_mode == True:
            f_tmp.write(f"\n")
        for text in working_list:
            if line_feed_mode == 1:
                f_tmp.write(f"{text}\n")
            else:
                f_tmp.write(f"{text}")


def get_cnts_of_line_of_f(f):
    with open(file=f, mode='r') as file:
        return sum(1 for line in file)


def get_os_n():
    import platform
    if platform.system() == 'Windows':
        return 'Windows'.lower()
    elif platform.system() == 'Linux':
        return 'Linux'.lower()
    else:
        return 'Unknown'.lower()


def truncate_tree(d_src):
    import inspect
    import os
    import shutil
    func_n = inspect.currentframe().f_code.co_name
    if os.path.exists(d_src):
        shutil.rmtree(d_src)
    if not os.path.exists(d_src):
        ensure_pnx_made(d_src, mode="d")


def get_count_none_of_list(list):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    # count=sum(element is None for element in list)
    Nones = list
    None_count = Nones.count(None)
    return None_count


def get_validated(target: any):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    if target is None:
        target = "논값"
    if target == "":
        target = "공백"
    if type(target) == str:
        if is_pattern_in_prompt(prompt=target, pattern=r'[^a-zA-Z0-9가-힣\s]', with_case_ignored=False):  # 특수문자 패턴 정의( 알파벳, 숫자, 한글, 공백을 제외한 모든 문자)
            target = get_str_replaced_special_characters(target, "$특수문자$")
        return target
    else:
        return target


def validate_and_return(value: str):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    func_n = inspect.currentframe().f_code.co_name
    try:
        pk_print(rf'[벨리데이션 테스트 결과] [value={value}] [type(value)={type(value)}] [len(value)={len(value)}]')
    except:
        pass
    if value is None:
        pk_print(rf'[벨리데이션 테스트 결과] [value=None]')
        return 0
    if value == "":
        pk_print(rf'[벨리데이션 테스트 결과] [value=공백]')
        return 0
    # if 전화번호만 같아 보이는지
    # if 특수문자만 같아 보이는지
    return value


def get_age_biological(birth_day):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    # 2023-1994=29(생일후)
    # 2024-1994=30(생일후)
    # 만나이 == 생물학적나이
    # 생일 전 만나이
    # 생일 후 만나이
    pass


def get_age_korean(birth_day):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    # 2023-1994=29(생일후)
    # 2024-1994=30(생일후)
    # 만나이 == 생물학적나이
    # 생일 전 만나이
    # 생일 후 만나이
    pass


# def should_i_download_youtube_as_webm_alt():
#     func_n=inspect.currentframe().f_code.co_name
#     func_n=inspect.currentframe().f_code.co_name
#     previous_text=""
#     while 1:
#         input_box_text_default=pk_paste()
#         # input_box_text_default="https://www.youtube.com/shorts/oM6c4Zkej7Y"
#         # input_box_text_default=""
#         dialog=GuiUtil.CustomQdialog(string="다운로드하고 싶은 URL을 입력해주세요", btns=["입력", "입력하지 않기"], input_box_mode=True, input_box_text_default=input_box_text_default)
#         dialog.exec()
#         btn_txt_clicked=dialog.btn_txt_clicked
#         pk_print(btn_txt_clicked, print_color='blue)
#         if btn_txt_clicked == "입력":
#             url=dialog.input_box.text()
#             download_from_youtube_to_webm_alt(url)
#         else:
#             break

def download_video_from_web_via_chrome_extension():
    from pkg_py.pk_core_constants import D_PROJECT
    while 1:
        # press("ctrl", "0")
        f_png = rf"{D_PROJECT}\pkg_png\download_video_via_chrome_extensions.png"
        click_center_of_img_recognized_by_mouse_left(img_pnx=f_png, loop_limit_cnt=10)

        pk_sleep(1000)

        pk_press("tab")
        pk_sleep(30)

        pk_press("enter")
        pk_sleep(30)

        pk_press("ctrl", "shift", "tab")

        pk_press("ctrl", "0")
        pk_press("ctrl", "-")
        pk_press("ctrl", "-")
        break


def guide_to_check_routines():
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    """
    예정된 routines 수행 다하면 보상을 주는 게임을 exec 할지 묻는 함수 mkmk
    """
    # 여기서 deepcopy() 를 쓴 이유
    # 원본의 len(routines) 을 알아야 하는데
    # deepcopy 를 하지않으면 step 마다  routine: str 이 줄어든 routines: [routine] 의 len 을 참조하게 되는데
    # 이는, 의도한 초기의 routines 의 len 을 참조하는 것과 다르므로, routines_deep_copied 를 만들었다
    # 여기서는 routines 를 수행된 routine을 remove하고 routine이 remove된 routines 를 관리하는데
    # 그동안 평소 구현했던 일반적으로 리스트를 순환할때와 enumerate를 통하여 cursor 를 움직이며 동작하는 것과 달리,
    # routines: [str] 에서 routine 을 하나씩 없애도록 만들었다 .
    # step= 1, routines=[ "routine1", "routine2", "routine3" ]
    # step= 2, routines=[ "routine2", "routine3" ]
    # step= 3, routines=[ "routine3" ]
    # 큐 자료구조와 일부 비슷한 부분이 있는 구조이다.
    # 자료구조적으로는 FIFO 활용
    # cursor 는 routines[0] 만 계속 가리키게 한다. routines[0]을 수행했다면 routines 에서 routines[0](리스트의 첫 원소)를 계속 빼어 버린다.

    # routines=routines
    # routines_deep_copied=copy.deepcopy(routines)

    # ment='루틴을 가이드합니다'
    # speak(ment=ment)

    # pk_sleep(milliseconds=50)

    # ment: str="\n".join(routines)
    # print_as_gui(ment=ment, auto_click_positive_btn_after_seconds=10)

    # btns=[DONE, I_WANT_TO_TO_DO_NEXT_TIME, OK_I_WILL_DO_IT_NOW]
    # routines_left: str="\n".join(routines)
    # ment=f"<남은 루틴목록>\n\n{routines_left}
    # '응, 아니 지금할게'


def classify_pnx_by_special_keyword(d_src, special_keyword, with_walking):
    import os
    import string
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_WORKING_EXTERNAL

    d_src = d_src.strip()
    d_src = d_src.replace("\"", "")
    d_src = d_src.replace("\'", "")
    pk_print(f'''d_src={d_src} special_keyword={special_keyword}''')
    connected_drives = []
    for drive_letter in string.ascii_uppercase:
        drive_path = drive_letter + ":\\"
        if os.path.exists(drive_path):
            connected_drives.append(drive_path)
            if d_src == drive_path:
                pk_print(working_str=rf'''광범위진행제한 {'%%%FOO%%%' if LTA else ''}''', print_color='red')
                return

    if not os.path.exists(d_src):
        pk_print(working_str=rf"입력된 d_src 가 존재하지 않습니다 d_src={d_src}", print_color='red')
        return

    if d_src == "":
        pk_print(f'''  d_src == "" ''', print_color='red')
        return

    special_dirs_promised = [
        # "blahblahblah_boom_boom_boom",
    ]
    # previous_keyword=pk_paste()
    # if previous_keyword == pnx:
    #     previous_keyword=""

    special_keyword = special_keyword.strip()
    if special_keyword == "":
        pk_print(working_str="special_keyword 는 ""일 수 없습니다.", print_color='red')
        return
    if "\n" in special_keyword:
        f_list = special_keyword.split("\n")
    else:
        f_list = [special_keyword]
    f_nx_list = [get_nx(f) for f in f_list]
    pk_print(f'''len(f_list)={len(f_list)} {'%%%FOO%%%' if LTA else ''}''')
    pk_print(f'''f_nx_list={f_nx_list}  {'%%%FOO%%%' if LTA else ''}''')
    for special_keyword in f_list:
        special_keyword = special_keyword.strip()
        if special_keyword != "":
            special_dirs_promised.append(special_keyword)
        for special_pnx in special_dirs_promised:
            ensure_pnx_made(rf"{D_WORKING_EXTERNAL}\{special_pnx}", mode="d")
        pnxs_searched = []
        if is_d(d_src):
            if with_walking == True:
                for root, d_nx_list, f_nx_list in os.walk(d_src, topdown=False):  # os.walk()는 with walking 으로 동작한다
                    for f_nx in f_nx_list:
                        f = os.path.join(root, f_nx)
                        for special_keyword in special_dirs_promised:
                            if special_keyword in os.path.basename(f):
                                pnxs_searched.append(f)
            else:
                # todo : without_waling
                return

        pk_print(working_str=rf'''len(pnxs_searched)="{len(pnxs_searched)}"  {'%%%FOO%%%' if LTA else ''}''')  # 검색된 f 개수
        dst = None
        for index, special_dir in enumerate(special_dirs_promised):
            dst = rf"{D_WORKING_EXTERNAL}\{special_dirs_promised[index]}"
            for pnx_searched in pnxs_searched:
                if special_dir in os.path.basename(pnx_searched):
                    move_pnx(pnx=pnx_searched, d_dst=dst)
        special_dirs_promised = []
        pk_print(working_str=rf'''dst="{dst}"  {'%%%FOO%%%' if LTA else ''}''', print_color='green')


def do_random_schedules():
    import inspect
    import random
    func_n = inspect.currentframe().f_code.co_name
    int_random = random.randint(0, 7)
    # pk_system_Tts.speak(f'랜덤숫자 {int_random} 나왔습니다')
    # mkmk
    if int_random == 0:
        pass
    elif int_random == 1:
        pass
    elif int_random == 2:
        pass
    elif int_random == 3:
        pass
    elif int_random == 4:
        pass
    elif int_random == 5:
        pass
    elif int_random == 6:
        pass
    elif int_random == 7:
        pass


def pk_count_down(countdown_limit_upper):  #
    for i in range(0, countdown_limit_upper, -1):
        pk_print_and_speak(f'count down {i}')


def pk_sleep(milliseconds=None, seconds=None, minutes=None, hours=None, mode_countdown=1):
    pk_sleep_v2(milliseconds=milliseconds, seconds=seconds, minutes=minutes, hours=hours, mode_countdown=mode_countdown)


def pk_sleep_v2(milliseconds=None, seconds=None, minutes=None, hours=None, mode_countdown=1):
    from pkg_py.pk_colorful_cli_util import pk_print
    import inspect
    import time
    func_n = inspect.currentframe().f_code.co_name

    # 인자 유효성 검사
    time_units = {"milliseconds": milliseconds, "seconds": seconds, "minutes": minutes, "hours": hours}
    provided_units = {k: v for k, v in time_units.items() if v is not None}
    if len(provided_units) != 1:
        pk_print(working_str=f"{func_n}() 함수는 {list(time_units.keys())} 중 하나만 정의되어야 합니다.")
        return
    unit, value = next(iter(provided_units.items()))

    # 시간을 초 단위로 변환
    time_value = None
    if unit == "milliseconds":
        time_value = value / 1000
    elif unit == "seconds":
        time_value = value
    elif unit == "minutes":
        time_value = value * 60
    elif unit == "hours":
        time_value = value * 3600
    if mode_countdown:
        remaining = int(time_value)

        # 시간, 분, 초로 변환하는 함수
        def format_time(seconds_left):
            hours = seconds_left // 3600
            minutes = (seconds_left % 3600) // 60
            seconds = seconds_left % 60
            return f"{hours:02}:{minutes:02}:{seconds:02}"

        # 카운트다운 시작
        for i in range(remaining, 0, -1):
            formatted_time = format_time(i)
            pk_print(working_str=f"⏳ 남은 시간: {formatted_time}")
            time.sleep(1)

        # 남은 시간이 소수점으로 딱 맞지 않는 경우, 잉여 시간 처리
        leftover = time_value - remaining
        if leftover > 0:
            time.sleep(leftover)
        else:
            pk_print(working_str="count down complete")
    else:
        time.sleep(time_value)


def pk_sleep_v1(milliseconds=None, seconds=None, minutes=None, hours=None, mode_countdown=1):
    import inspect
    import time
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name

    # 인자 유효성 검사
    time_units = {"milliseconds": milliseconds, "seconds": seconds, "minutes": minutes, "hours": hours}
    provided_units = {k: v for k, v in time_units.items() if v is not None}
    if len(provided_units) != 1:
        pk_print(
            prompt=f"{func_n}() 함수는 {list(time_units.keys())} 중 하나만 정의되어야 합니다."
        )
        return
    unit, value = next(iter(provided_units.items()))
    if unit == "milliseconds":
        time_value = value / 1000
    elif unit == "seconds":
        time_value = value
    elif unit == "minutes":
        time_value = value * 60
    elif unit == "hours":
        time_value = value * 3600
    time.sleep(time_value)  # time 객체를 써야함


def add_os_sys_environment_variable(environment_variable_name: str, environment_variable_value: str):
    import inspect
    import sys
    from pkg_py.pk_colorful_cli_util import pk_print
    """시스템 환경변수 path 업데이트"""
    func_n = inspect.currentframe().f_code.co_name
    pk_print("테스트가 필요한 함수를 적용하였습니다")
    pk_print("기대한 결과가 나오지 않을 수 있습니다")
    pk_print("업데이트 전 시스템 환경변수")
    for i in sys.path:
        pk_print(i, print_color='blue')
    sys.path.insert(0, environment_variable_value)
    sys.path.append(environment_variable_value)
    pk_print("업데이트 전 시스템 환경변수")
    for i in sys.path:
        pk_print(i, print_color='blue')


def compress_pnx_via_bz(pnx):
    import inspect
    import os
    import re
    import shutil
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print, print_magenta
    from pkg_py.pk_core_constants import D_PROJECT
    from datetime import datetime
    func_n = inspect.currentframe().f_code.co_name
    try:
        while 1:
            ment = rf"백업 {pnx}"
            pk_print(f" {'%%%FOO%%%' if LTA else ''} {ment}", )

            # 전처리
            pnx = pnx.replace("\n", "")
            pnx = pnx.replace("\"", "")

            if pnx.strip() == "":
                pk_speak_v2(working_str="백업할 대상이 입력되지 않았습니다", comma_delay=0.98)
                break

            target_dirname = os.path.dirname(pnx)
            target_dirname_dirname = os.path.dirname(target_dirname)
            target_basename = os.path.basename(pnx).split(".")[0]
            target_zip = rf'{target_dirname}\$zip_{target_basename}.zip'
            target_yyyy_mm_dd_hh_mm_ss_zip_basename = rf'{target_basename} - {get_time_as_("%Y %m %d %H %M %S")}.zip'
            pk_print(f"pnx : {pnx}")
            pk_print(f"target_dirname : {target_dirname}")
            pk_print(f"target_dirname_dirname : {target_dirname_dirname}")
            pk_print(f"target_basename : {target_basename}")
            pk_print(f"target_zip : {target_zip}")
            pk_print(f"target_yyyy_mm_dd_HH_MM_SS_zip_basename : {target_yyyy_mm_dd_hh_mm_ss_zip_basename}")

            cmd = f'bz.exe c "{target_zip}" "{pnx}"'
            cmd_to_os(cmd=cmd)

            cmd = rf'ren "{target_zip}" "{target_yyyy_mm_dd_hh_mm_ss_zip_basename}"'
            cmd_to_os(cmd=cmd)

            # f이 위치한 드라이브로 이동
            drives = [
                "C",
                "D",
                "E",
                "F",
                "G",
            ]
            drive_where_target_is_located = pnx.split(":")[0].upper()
            for drive in drives:
                if (drive_where_target_is_located == drive):
                    os.system(rf"cd {drive}:")
            try:
                pk_chdir(target_dirname)
            except:
                pk_speak_v2(working_str="경로를 이해할 수 없습니다", comma_delay=0.98)
                pk_chdir(D_PROJECT)
                break
            lines = cmd_to_os_like_person_as_admin('dir /b /a-d *.zip')
            print_magenta(rf'''len(lines)={len(lines)}''')
            for line in lines:
                print_magenta(f'''line={line}''')
                if line != "":
                    if os.getcwd() != line:  # 여기 os.getcwd() 이게 들어가네... 나중에 수정하자
                        # 2023-12-04 월 12:14 SyntaxWarning: invalid escape sequence '\d'
                        # r 을 사용 Raw String(원시 문자열),  \를 모두 remove
                        # 정규식은 r 쓰면 안된다. \ 써야한다?.
                        # 2023-12-12 화 14:23 SyntaxWarning: invalid escape sequence '\d'
                        # 가상환경 재설치 후 또 문제가 나타남,
                        # pattern='d{4} d{2} d{2} d{2} d{2} d{2}'
                        # pattern=r'\d{4} \d{2} \d{2} \d{2} \d{2} \d{2}'
                        pattern = r'd{4} d{2} d{2} d{2} d{2} d{2}'
                        # pk_print(line)
                        if is_pattern_in_prompt(line, pattern):
                            pk_print(f"zip f 목록에 대하여 {pattern} 타임스탬프 정규식 테스트를 통과했습니다")
                            # pk_print(line)
                            # 2023-12-03 일 20:03 trouble shooting 성공
                            # 백업 시 타임스탬프에 언더바 넣도록 변경했는데 regex 는 변경 하지 않아서 난 실수 있었음.
                            time_to_backed_up = re.findall(pattern, line)
                            time_to_backed_up_ = time_to_backed_up[0][0:10].replace(" ", "-") + " " + time_to_backed_up[0][11:16].replace(" ", ":") + ".00"
                            time_to_backed_up__ = datetime.strptime(str(time_to_backed_up_), '%Y-%m-%d %H:%M.%S')
                            time_current = datetime.now()
                            try:
                                target_dirname_old = rf'{target_dirname}\pkg_zip'
                                if not os.path.exists(target_dirname_old):
                                    os.makedirs(target_dirname_old)
                            except Exception:
                                pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
                                pk_chdir(D_PROJECT)
                                break
                            # 지금부터 7일 이전의 f만
                            # diff=time_to_backed_up__ - time_current
                            # if diff.days <-7:
                            # pk_print(f"line : {line}")

                            # pk_print(f"1분(60 seconds) 이전의 f자동정리 시도...")
                            pk_print(f"f자동정리 시도...")
                            change_min = time_current - datetime.timedelta(seconds=60)
                            diff = time_to_backed_up__ - change_min
                            if 60 < diff.seconds:
                                try:
                                    file_with_time_stamp_zip = os.path.abspath(line.strip())
                                    file_dirname_old_abspath = os.path.abspath(target_dirname_old)
                                    pk_print(rf'move "{file_with_time_stamp_zip}" "{file_dirname_old_abspath}"', print_color='blue')
                                    shutil.move(file_with_time_stamp_zip, file_dirname_old_abspath)
                                except Exception:
                                    pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
                                    pk_chdir(D_PROJECT)
                                    break
            pk_chdir(D_PROJECT)
            pk_print(f" {'%%%FOO%%%' if LTA else ''} green {ment}", print_color='blue')
            break
    except:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        pk_chdir(D_PROJECT)


def upzip_pnx(pnx):
    import os
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print, print_success
    from pkg_py.pk_core_constants import D_PROJECT
    try:
        while 1:
            # 전처리
            pnx = pnx.replace("\n", "")
            pnx = pnx.replace("\"", "")

            if pnx.strip() == "":
                pk_print(working_str="백업할 대상이 입력되지 않았습니다")
                break

            pnx_dirname = os.path.dirname(pnx)
            pnx_basename = os.path.basename(pnx).split(".")[0]
            target_zip = rf'{pnx_dirname}\{pnx_basename}.zip'

            pk_chdir(pnx_dirname)

            if os.path.exists(target_zip):
                # cmd=f'bandizip.exe bx "{target_zip}"'
                cmd = f'bz.exe x -aoa "{target_zip}"'  # x 는 경로 보존, -aoa :Overwrite All existing files without prompt
                cmd_to_os_like_person_as_admin(cmd)
                if os.path.exists(pnx):
                    cmd = rf'echo y | del /f "{target_zip}"'
                    cmd_to_os_like_person_as_admin(cmd)
                else:
                    pk_print("압축해제 후 압축f을 삭제에 실패")
            else:
                pk_print("압축해제할 f이 없었습니다")
            pk_chdir(D_PROJECT)
            print_success("압축해제 성공")
            break
    except:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        pk_chdir(D_PROJECT)


def parse_youtube_video_id(url):
    import inspect
    import urllib
    from urllib.parse import quote
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    keyword_shorts = '/shorts/'
    keyword_slash = '/'
    if keyword_shorts in url:
        youtube_video_id = url.split(keyword_shorts)[1]
        youtube_video_id = youtube_video_id.split(keyword_slash)[0]
        pk_print(working_str=rf'''youtube_video_id="{youtube_video_id}"  {'%%%FOO%%%' if LTA else ''}''')
        return youtube_video_id
    query = urllib.parse.urlparse(url=url)
    # pk_print(query.scheme)
    # pk_print(query.netloc)
    # pk_print(query.hostname)
    # pk_print(query.port)
    # pk_print(query._replace(fragment="").geturl())
    # pk_print(query)
    # pk_print(query["v"][0])
    if query.hostname == 'youtu.be':
        pk_print(working_str=rf'''query.path[1:]="{query.path[1:]}"  {'%%%FOO%%%' if LTA else ''}''')
        return query.path[1:]
    if query.hostname in ('www.youtube.com', 'youtube.com'):
        if query.path == '/watch':
            p = urllib.parse.parse_qs(query.query)
            pk_print(working_str=rf'''p['v'][0]="{p['v'][0]}"  {'%%%FOO%%%' if LTA else ''}''')
            return p['v'][0]
        if query.path[:7] == '/embed/':
            pk_print(working_str=rf'''query.path.split('/')[2]="{query.path.split('/')[2]}"  {'%%%FOO%%%' if LTA else ''}''')
            return query.path.split('/')[2]
        if query.path[:3] == '/v/':
            pk_print(working_str=rf'''query.path.split('/')[2]="{query.path.split('/')[2]}"  {'%%%FOO%%%' if LTA else ''}''')
            return query.path.split('/')[2]


def download_video_mp4(url: str):
    import inspect
    import os
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print, print_magenta
    from pkg_py.pk_core_constants import D_DOWNLOADING, VIDEO_IDS_ALLOWED, AUDIO_IDS_ALLOWED, F_YT_DLP_EXE
    from pkg_py.pk_interface_graphic_user import GuiUtil
    func_n = inspect.currentframe().f_code.co_name
    while 1:
        if url.strip() == "":
            pk_print(rf"if url.strip() == "":", print_color='blue')
            break

        pk_print(working_str=rf'''url="{url}"  {'%%%FOO%%%' if LTA else ''}''')
        video_id = ''
        cmd = rf'{F_YT_DLP_EXE} -F {url}'
        lines = cmd_to_os(cmd=cmd)

        video_ids_allowed = VIDEO_IDS_ALLOWED
        audio_ids_allowed = AUDIO_IDS_ALLOWED
        audio_id = ""
        for line in lines:
            if 'video only' in line or 'audio only' in line:
                pk_print(f"line: {line}", print_color='blue')
                # video_id 설정
                for id in video_ids_allowed:
                    if id in line:
                        video_id = id
                        if video_id.strip() == "":
                            pk_print(rf"다운로드 할 수 있는 video_id가 아닙니다 {video_id.strip()}", print_color='blue')
                            break
                # audio_id 설정
                for id in audio_ids_allowed:
                    if id in line:
                        audio_id = id
                        if audio_id.strip() == "":
                            pk_print(rf"다운로드 할 수 있는 audio_id가 아닙니다 {audio_id.strip()}", print_color='blue')
                            break
                        break

        cmd = rf'{F_YT_DLP_EXE} -f "bestvideo[ext=mp4]+bestaudio[ext=mp4]" {url}'  # ext=mp4 로 처리
        if video_id == "" or audio_id == "" == 1:
            # text="다운로드를 진행할 수 없습니다\n다운로드용 video_id 와 audio_id를 설정 후\nurl을 다시 붙여넣어 다운로드를 다시 시도하세요\n{url}"
            pk_print("불완전한 다운로드 명령어가 감지되었습니다....", print_color='blue')
            pk_speak_v2(working_str="불완전한 다운로드 명령어가 감지되었습니다", comma_delay=0.98)
            dialog = GuiUtil.CustomQdialog(
                prompt=f"에러코드[E004]\n아래의 비디오 아이디를 저장하고 에러코드를 관리자에게 문의해주세요\nvideo id: {url}",
                btn_list=["확인"],
                input_box_mode=True,
                input_box_text_default=url,
            )
            dialog.exec()
            pk_print(cmd, print_color='blue')
            break

        try:
            lines = cmd_to_os_like_person_as_admin(cmd=cmd)
        except:
            print_magenta("except:2024-04-12 1750")
            print_magenta(rf'''cmd : {cmd}''')

        if not os.path.exists(D_DOWNLOADING):
            os.makedirs(D_DOWNLOADING)

        pk_print("다운로드 f 이동 시도 중...", print_color='blue')
        file = ""
        try:
            clip_id = parse_youtube_video_id(url)
            if clip_id is None:
                clip_id = url

            lines = os.listdir()  # todo : wording : lines vs f_list or f_nx_list ?
            for line in lines:
                if is_pattern_in_prompt(str(line), str(clip_id)):
                    file = line

            src = os.path.abspath(file)
            src_renamed = rf"{D_DOWNLOADING}\{os.path.basename(file)}"

            pk_print(f'src_renamed : {src_renamed}', print_color='blue')
            if src == os.getcwd():  # 여기 또 os.getcwd() 있는 부분 수정하자..
                dialog = GuiUtil.CustomQdialog(
                    prompt=f"에러코드[E001]\n아래의 비디오 아이디를 저장하고 에러코드를 관리자에게 문의해주세요\nvideo id: {url}",
                    btn_list=["확인"],
                    input_box_mode=True,
                    input_box_text_default=url,
                )
                dialog.exec()
                pk_print("cmd", print_color='blue')
                pk_print(cmd, print_color='blue')
                break
            if src != os.getcwd():  # 여기 또 os.getcwd() 있는 부분 수정하자..
                move_pnx(src, src_renamed)

        except:
            pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        pk_print(rf'다운로드 결과 확인 중...', print_color='blue')
        try:
            src_moved = rf'{D_DOWNLOADING}\{file}'
            pk_print(rf'''src_moved : {src_moved}''', print_color='blue')

            # 무조건 재생
            text_editor = 'explorer.exe'
            cmd = f'{text_editor} "{src_moved}" '
            cmd_to_os(cmd=cmd)

        except Exception:
            pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')

        break


def download_from_youtube_to_webm(urls):
    import inspect
    import sys
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print, print_magenta
    from pkg_py.pk_core_constants import UNDERLINE
    from pkg_py.pk_interface_graphic_user import GuiUtil
    func_n = inspect.currentframe().f_code.co_name
    while 1:
        urls = str(urls).strip()
        if urls is None:
            pk_speak_v2(working_str="다운로드할 대상 목록에 아무것도 입력되지 않았습니다", comma_delay=0.98)
            break
        if urls == "None":
            pk_speak_v2(working_str="다운로드할 대상 목록에 이상한 것이 입력되었습니다", comma_delay=0.98)
            break

        if "\n" in urls:
            urls = urls.split("\n")
        else:
            urls = [urls]

        urls = [x for x in urls if x.strip("\n")]  # 리스트 요소 "" remove,  from ["", A] to [A]       [""] to []
        GuiUtil.pop_up_as_complete(title="작업중간보고", ment=f"{len(urls)} 개의 url이 입력되었습니다", auto_click_positive_btn_after_seconds=1)

        try:
            urls.append(sys.argv[1])
        except IndexError:
            pass
        except Exception:
            pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
            pass

        # urls 중복remove(ordered way)
        urls_removed_duplicated_element: [str] = []
        for url in urls:
            if url not in urls_removed_duplicated_element:
                if url is not None:
                    # if url is not "None":
                    urls_removed_duplicated_element.append(url)
        urls = urls_removed_duplicated_element
        print_magenta(f'''urls : \n{urls}''')
        print_magenta(rf'''type(urls) : {type(urls)}''')
        print_magenta(rf'''len(urls) : {len(urls)}''')

        only_clip_id = ''
        for i in urls:
            pk_print(i, print_color='blue')
            only_clip_id = i

        if len(urls) == 0:
            GuiUtil.pop_up_as_complete(title="작업성공보고", ment=f"다운로드할 대상이 없습니다", auto_click_positive_btn_after_seconds=5)
            # TtsUtil.speak_ments(ment="다운로드할 대상이 없습니다", sleep_after_play=0.65)
            break

        if len(urls) != 1:
            pk_speak_v2(f"{str(len(urls))}개의 다운로드 대상이 확인되었습니다", comma_delay=0.98)
        for url in urls:
            url = url.strip()  # url에 공백이 있어도 다운로드 가능하도록 설정
            if '&list=' in url:
                pk_print(f' clips mode')
                from pytube import Playlist
                playlist = Playlist(url)  # 이걸로도 parsing 기능 수행 생각 중
                pk_print(f"predicted clips cnt : {len(playlist.video_urls)}", print_color='blue')
                pk_speak_v2(working_str=f"{len(playlist.video_urls)}개의 다운로드 목록이 확인되었습니다", comma_delay=0.98)
                # os.system(f'echo "여기서부터 비디오 리스트 시작 {url}" >> success_yt_dlp.log')
                for video_id in playlist.video_urls:
                    try:
                        download_video_f(video_id)
                    except Exception:
                        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
                        continue
                # os.system(f'echo "여기서부터 비디오 리스트 종료 {url}" >> success_yt_dlp.log')
            else:
                if parse_youtube_video_id(url) is not None:
                    pk_print(f'{UNDERLINE}youtube video id parsing mode')
                    try:
                        download_video_f(f'https://www.youtube.com/watch?v={parse_youtube_video_id(url)}')
                    except Exception:
                        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
                        continue
                else:
                    pk_print(f'{UNDERLINE}experimental mode with clip id only')
                    download_video_mp4(f'https://www.youtube.com/watch?v={only_clip_id}')
                    try:
                        pk_print(rf'''try:2024-04-12 18:04''', print_color='blue')
                        url_parts_useless = [
                            "https://youtu.be/",
                            "https://www.youtube.com/shorts/",
                        ]
                        try:
                            for index, useless_str in enumerate(url_parts_useless):
                                if useless_str in url:
                                    print(rf'url.split(useless_str)[1] : {url.split(useless_str)[1]}')
                                    download_video_f(url=url.split(useless_str)[1])
                        except Exception:
                            download_video_f(url)
                            pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
                    except Exception:
                        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
                    continue
        break


# deprecated method by pk_system_
# def print_police_line(police_line_ment):

#     police_line=''
#     for i in range(0, 255 // len(police_line_ment)):
#         police_line=police_line + f'{police_line_ment} '
#     pk_print(f'{police_line.upper()}')


def recmd_console_color():
    import inspect
    import os
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_interface_graphic_user import get_display_info
    import ipdb
    import clipboard
    func_n = inspect.currentframe().f_code.co_name
    colors = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']
    while 1:
        try:
            for color_bg in colors:
                for color_text in colors:
                    if color_bg != color_text:
                        os.system('cls')
                        for setting_key, setting_value in get_display_info().items():
                            pass
                            # pk_print(f'setting_key: {setting_key}  ,setting_value: {setting_value}  ')
                        # pk_print(f"color {color_bg}{color_text}")
                        for i in range(0, 32):
                            pk_print('', print_color='blue')
                        to_right_nbsp = ''
                        for i in range(0, 150):
                            to_right_nbsp = to_right_nbsp + ' '
                        pk_print(f"{to_right_nbsp}color {color_bg}{color_text}", print_color='blue')
                        for i in range(0, 32):
                            pk_print('', print_color='blue')
                        os.system(f"color {color_bg}{color_text}")
                        clipboard.copy(f'color {color_bg}{color_text}')

                        ipdb.set_trace()

        except Exception as e:
            pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
            # ctrl c 가 입력이 제대로 되지 않는 현상이 있어 ctrl c 로 콘솔을 종료하는데 불편...이는 어떻게 해결하지? 일단 코드 반응속도는 마음에 드는데...


def make_matrix_console():
    import inspect
    import os
    import subprocess
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    os.system('color 0A')
    os.system('color 02')
    while 1:
        lines = subprocess.check_output('dir /b /s /o /a-d', shell=True).decode('utf-8').split("\n")
        for line in lines:
            if "" != line:
                if os.getcwd() != line:
                    pk_print(lines, print_color='blue')
        pk_sleep(seconds=60)


# 이 메소드를 만들면서 권한을 얻는 여러가지 방법을 stack over flow 를 따라 시도해보았으나 적다한 해결책을 찾지 못함. pyautogui 로 시도 방법은 남아있으나
# 일단은 regacy 한 방법으로 임시로 해결해두었다.
def update_global_pkg_alba():
    import inspect
    import os
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import UNDERLINE, D_PROJECT
    func_n = inspect.currentframe().f_code.co_name
    local_pkg = rf"{D_PROJECT}\pkg_alba"
    global_pkg = rf"C:\Python312\Lib\site-packages\pkg_alba"
    updateignore_txt = rf"{D_PROJECT}\pkg_alba\updateignore.txt"
    try:
        if os.path.exists(global_pkg):
            # remove시도
            # shutil.rmtree(global_pkg)

            # remove시도
            # for file in os.scandir(global_pkg):
            # os.remove(file.path)

            # 덮어쓰기
            # src= local_pkg
            # dst =os.path.dirname(global_pkg)
            # os.system(f"echo y | copy {src} {dst}")
            # shutil.copytree(local_pkg, os.path.dirname(global_pkg))
            cmd = f'echo y | xcopy "{local_pkg}" "{global_pkg}" /k /e /h /exclude:{updateignore_txt} >nul'
            os.system(cmd)

            pk_print(f'{cmd}', print_color='blue')
            pk_print(f"{UNDERLINE}", print_color='blue')
            return "REPLACED global pkg_alba AS local_pkg"
        else:
            return "pkg_alba NOT FOUND AT GLOBAL LOCATION"

    except Exception as e:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')


def merge_video_and_sound(f_v, f_a):
    import inspect
    import os
    import subprocess
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_VIDEOES_MERGED, F_FFMPEG_EXE
    func_n = inspect.currentframe().f_code.co_name

    pk_print(f'다운로드 d 생성')
    d_nx_list = ["storage"]
    for d_nx in d_nx_list:
        if not is_d(rf'./{d_nx}'):
            os.makedirs(rf'{d_nx}')

    pk_print(rf'merge voiceless video and audio only video ')  # yotube 에서 고해상도 음성 없는 영상과 음성을 받아 하나의 영상으로 merge
    dst = D_VIDEOES_MERGED
    paths = [os.path.abspath(dst), os.path.basename(f_v)]
    f_va = os.path.join(*paths)
    pk_print(rf'f_v : {f_v}', print_color='blue')
    pk_print(rf'f_a : {f_a}', print_color='blue')
    pk_print(rf'f_va : {f_va}', print_color='blue')

    pk_print(f'ffmpeg.exe 위치 설정')
    f_ffmpeg_exe = F_FFMPEG_EXE
    trouble_characters = ['Ä']
    trouble_characters_alternatives = {'Ä': 'A'}
    for trouble_character in trouble_characters:
        f_v = f_v.replace(trouble_character, trouble_characters_alternatives[trouble_character])
        f_a = f_a.replace(trouble_character, trouble_characters_alternatives[trouble_character])
        f_va = f_va.replace(trouble_character, trouble_characters_alternatives[trouble_character])
        pk_print(f'f명 변경 시도')
        try:
            if trouble_character in f_va:
                os.rename(f_v,
                          f_v.replace(trouble_character, trouble_characters_alternatives[trouble_character]))
                os.rename(f_a,
                          f_a.replace(trouble_character, trouble_characters_alternatives[trouble_character]))
        except Exception as e:
            pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')

    pk_print(f' f머지 시도')
    try:
        pk_print(rf'echo y | "{f_ffmpeg_exe}" -i "{f_v}" -i "{f_a}" -c copy "{f_va}"', print_color='blue')
        lines = subprocess.check_output(
            rf'echo y | "{f_ffmpeg_exe}" -i "{f_v}" -i "{f_a}" -c copy "{f_va}"', shell=True).decode(
            'utf-8').split("\n")
        for line in lines:
            pk_print(line, print_color='blue')
    except Exception as e:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')

    pk_print(rf'다운로드 및 merge 결과 확인 시도', print_color='blue')
    try:
        pk_print(rf'explorer "{f_va}"', print_color='blue')
        subprocess.check_output(rf'explorer "{f_va}"', shell=True).decode('utf-8').split("\n")
    except Exception as e:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')

    pk_print(f' 불필요 리소스 삭제 시도')
    try:
        if os.path.exists(f_va):
            subprocess.check_output(rf'echo y | del /f "{f_v}"', shell=True).decode('utf-8').split("\n")
            lines = subprocess.check_output(rf'echo y | del /f "{f_a}"', shell=True).decode('utf-8').split("\n")
            for line in lines:
                pk_print(line, print_color='blue')
    except Exception as e:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')


def run_project_docker_base(f, dockerfile_script_list):
    import os
    from pkg_py.pk_core_constants import D_PROJECT, STAMP_TRY_GUIDE
    from pkg_py.pk_core_constants import D_PROJECT_FASTAPI
    from pkg_py.pk_core_constants import D_HOME
    from pkg_py.pk_colorful_cli_util import pk_print

    def write_dockerfile(f, f_dockerfile_script_list):
        f_dockerfile_script_list = get_list_added_suffix_each_element(working_list=f_dockerfile_script_list, suffix='\n')
        ensure_pnx_made(pnx=f, mode='f', script_list=f_dockerfile_script_list)

    # ensure wsl
    config_remote_os = {}
    wsl_distro_n = "Ubuntu-24.04"
    config_remote_os['os_distro_n'] = wsl_distro_n
    config_remote_os['ip'] = get_wsl_ip(wsl_distro_n)
    config_remote_os['port'] = ensure_and_get_wsl_port(wsl_distro_n)
    config_remote_os['user_n'] = get_wsl_user_n(wsl_distro_n)
    config_remote_os['pw'] = get_wsl_pw(wsl_distro_n)
    config_remote_os['local_ssh_public_key'] = os.path.join(D_HOME, ".ssh", "id_ed25519.pub")
    config_remote_os['local_ssh_private_key'] = os.path.expanduser("~/.ssh/id_ed25519")
    ensure_wsl_distro_installed(wsl_distro_n=wsl_distro_n)
    ensure_wsl_distro_session(wsl_distro_n=wsl_distro_n)

    ip = config_remote_os['ip']
    port = config_remote_os['port']
    user_n = config_remote_os['user_n']

    ensure_ssh_public_key_to_remote_os(**config_remote_os)
    ensure_remote_os_as_nopasswd(**config_remote_os)
    if LTA:
        pk_print(f'''{STAMP_TRY_GUIDE} ssh -p {port} {user_n}@{ip} {'%%%FOO%%%' if LTA else ''}''')

    # make dockerfile
    ensure_pnx_made(pnx=f, mode='f')

    # write dockerfile
    write_dockerfile(f=f, f_dockerfile_script_list=dockerfile_script_list)

    # send dockerfile via scp 
    cmd_to_remote_os(cmd=f'scp -av --delete -e "ssh -i ~/.ssh/id_ed25519" {D_PROJECT} {user_n}@{ip}:~/Downloads/{get_nx(D_PROJECT)}', **config_remote_os)
    # mkr. # todo

    # send dockerfile via rsync
    # install_ubuntu_pkg_to_remote_os_via_apt(ubuntu_pkg_n='rsync', **config_remote_os)
    D_PROJECT = get_pnx_wsl_unix_style(pnx=D_PROJECT_FASTAPI)
    # cmd_to_remote_os(cmd=f'rsync -av --delete -e "ssh -i ~/.ssh/id_ed25519" {d_project} {user_n}@{ip}:~/Downloads/{get_nx(d_project)}', **config_remote_os)
    # cmd_to_remote_os(cmd=f'rsync -av --delete {d_project} ~/Downloads/', **config_remote_os)

    # import ipdb
    # ipdb.set_trace()
    # while 1:
    #     # todo: 등록된 함수명 조회 with idx
    #     # print_pk_func_list_with_idx()
    #     # if user_cmd = "f 13":
    #     #     pk_copy(str_working=pk_input())
    #     import ipdb
    #     ipdb.set_trace()
    #     # ctrl v

    # install docker deamon
    # install_ubuntu_pkg_to_remote_os_via_apt(ubuntu_pkg_n='docker', **config_remote_os)

    # start docker deamon
    cmd_to_remote_os(cmd=f'sudo service docker start', **config_remote_os)

    # edit dockerfile
    # if LTA:
    #     cmd_to_os(cmd=rf'code "{f}"')

    # build docker
    f_nx = get_nx(f)
    f_n = get_n(f)
    f_docker_img_n = rf'{f_n}'
    f_docker_tag_version = rf''  # 생략 시 latest
    # f_docker_tag_version=rf':1.0'
    f_docker_tag_n = rf'{f_docker_img_n}{f_docker_tag_version}'
    cmd_to_remote_os(cmd=rf"docker build -t {f_docker_tag_n} -f ~/Downloads/{os.path.basename(D_PROJECT)}/{f_nx} .", **config_remote_os)
    std_out_str, std_err_str = cmd_to_remote_os(cmd=rf"ls ~/Downloads/{os.path.basename(D_PROJECT)}/{f_nx}", **config_remote_os)
    pk_print(f'''std_out_str={std_out_str} {'%%%FOO%%%' if LTA else ''}''')
    raise
    # cmd_to_remote_os(cmd=rf"ls", **config_remote_os)
    # cmd_to_remote_os(cmd=rf"ls ~/Downloads/{os.path.basename(D_PROJECT)}/{f_nx}", **config_remote_os)
    # cmd_to_remote_os(cmd=rf"ls ~/Downloads/{os.path.basename(D_PROJECT)}/{f_nx}", **config_remote_os)
    # raise
    # cmd_to_remote_os(cmd=rf"pwd", **config_remote_os)

    # docker run
    f_n = get_n(f)
    docker_container_n = rf'{f_n}'
    cmd_list = [
        f"sudo docker run --rm -d \\",
        f"--name {docker_container_n} {f_docker_img_n} \\",
        # f"-p <로컬_포트>: <컨테이너_포트>\\",
        # f"-v ~/Downloads/mariadb_data:/var/lib/mysql \\",  # 볼륨 마운트
        # f"mariadb \\",  # exec 할 이미지 (선택적)
    ]
    cmd = get_str_from_list(working_list=cmd_list)
    cmd_to_remote_os(cmd=cmd, **config_remote_os)

    # check docker container
    # cmd_to_os(cmd=rf"wsl docker ps -a")  # 중지된 컨테이너 포함

    # 이 설정을 완료하면
    # WSL Docker deamon tcp://0.0.0.0:2375에서 외부 요청 수신대기
    config_content = """{
        "hosts": ["unix:///var/run/docker.sock", "tcp://0.0.0.0:2375"]
    }"""
    cmd_to_remote_os_with_pubkey(cmd=rf"sudo sh -c 'echo \"{config_content}\" | tee /etc/docker/daemon.json'", **config_remote_os)
    cmd_to_remote_os_with_pubkey(cmd=rf"sudo service docker restart", **config_remote_os)

    # wsl docker_ip
    std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd=f"docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' {docker_container_n}")  # 이거되나?
    # std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd=f"docker inspect -f '{{{{range .NetworkSettings.Networks}}}}{{{{.IPAddress}}}}{{{{end}}}}' {f_docker_container_name}")
    docker_ip = std_out_list[0]
    pk_print(f'''docker_ip="{docker_ip}"  {'%%%FOO%%%' if LTA else ''}''')

    # wsl 내부 docker deamon 제어(wsl 외부에서)
    # Docker SDK # TCP로 노출 또는 Unix 소켓
    client = docker.DockerClient(base_url=rf"tcp://{docker_ip}:2375")  # Docker deamon 에 연결 (WSL 외부에서)
    print(client.info())  # Docker 정보 확인

    ensure_pnx_removed(f)

    # send_f(f=f_dockerfile, ip=xc)


# def elapsed(function):
#     def wrapper(*args, **kwargs):
#         time_s=time.time()
#         function(*args, **kwargs)
#         time_e=time.time()
#         mesured_time=time_e - time_s
#         pk_print(f'측정시간은 {mesured_time} 입니다')
#         pk_print(f'측정시간은 {mesured_time} 입니다')
#     return wrapper


def replace_with_auto_no(template_str: str, word_monitored: str, auto_cnt_starting_no=0):
    """
    input
    --------
    -----1--
    ---1----
    ---1----
    -------1
    ouput
    --------
    -----1--
    ---2----
    ---3----
    -------4
    """
    line_splited_by_word_monitored_list = template_str.split(word_monitored)

    line_list_filtered = []
    for index, line_splited_by_word_monitored in enumerate(line_splited_by_word_monitored_list):
        if index != len(line_splited_by_word_monitored_list) - 1:
            line_list_filtered.append(line_splited_by_word_monitored + str(auto_cnt_starting_no))
            auto_cnt_starting_no = auto_cnt_starting_no + 1
        else:
            line_list_filtered.append(line_splited_by_word_monitored)
    lines_new_as_str = "".join(line_list_filtered)
    return lines_new_as_str


def replace_with_auto_no_orderless(contents: str, unique_word: str, auto_cnt_starting_no=0):
    import inspect
    import re
    func_n = inspect.currentframe().f_code.co_name
    # pk_print(str_working="항상 필요했던 부분인데 만들었다. 편하게 개발하자. //웹 서비스 형태로 아무때서나 접근이되면 더 좋을 것 같다.  웹 개발툴 을 만들어 보자")
    before = unique_word
    after = 0 + auto_cnt_starting_no
    contents_new = []
    # lines=contents.split("\n")
    lines = contents.strip().split("\n")  # 문제 없긴 했는데,  어떻게 되나 실험해보자 안되면 위의 코드로 주석 스와핑할것.
    for line in lines:
        # pk_print(line)
        # pk_print(before)
        # pk_print(str(after))
        after = after + 1

        line_new = re.sub(str(before), str(after), str(line))
        # pk_print(line_new)
        contents_new.append(line_new)

    # pk_print(str_working="str list to str")
    delimiter = "\n"
    contents_new_as_str = delimiter.join(contents_new)
    return contents_new_as_str


#
# def move_with_overwrite(src: str, dst: str):
#     pk_print(f"{inspect.currentframe().f_code.co_name}()")
#     try:
#         # 목적지에 있는 중복타겟 삭제
#         os.remove(dst)
#     except FileNotFoundError as e:
#         pass
#     except Exception:
#         pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
#     try:
#         # 목적지로 타겟 이동
#         os.rename(src, dst)
#     except Exception:
#         pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')


# def raise_error(str: str):
#     import inspect
#     import shutil
#     func_n = inspect.currentframe().f_code.co_name
#     raise shutil.Error(str)


def push_pnx_to_github(d_working, git_repo_url, commit_msg, branch_n):
    from pkg_py.pk_colorful_cli_util import pk_print
    from colorama import init as pk_colorama_init
    pk_colorama_init(autoreset=True)
    pk_print(f'''commit_msg={commit_msg} {'%%%FOO%%%' if LTA else ''}''')
    if not is_internet_connected():
        return
    if not does_pnx_exist(pnx=d_working):
        ensure_pnx_made(pnx=d_working, mode='d')
    pk_chdir(d_dst=d_working)
    d_git = rf"{d_working}/.git"
    std_list = None
    state_done = [0, 0, 0, 0]
    while 1:
        if state_done[0] == 0:
            if not does_pnx_exist(pnx=d_git):
                std_list = cmd_to_os(cmd=rf'git init')
                continue
        state_done[0] = 1
        pk_print(f'''state_done={state_done} {'%%%FOO%%%' if LTA else ''}''', print_color='green')
        if state_done[1] == 0:
            std_list = cmd_to_os(cmd=rf'git add .')  # git add * 과는 약간 다름.
            # signiture_list = ["The following paths are ignored by one of your .gitignore files:"]
            if not len(std_list) == 0:
                pk_print(working_str=rf'''{'%%%FOO%%%' if LTA else ''}''', print_color='red')
                continue
            # if not any(str_working in std_list for str_working in signiture_list):
            #     continue
        state_done[1] = 1
        pk_print(f'''state_done={state_done} {'%%%FOO%%%' if LTA else ''}''', print_color='green')
        if state_done[2] == 0:
            std_list = cmd_to_os(cmd=rf'git commit -m "{commit_msg}"')
            std_list = cmd_to_os(cmd=rf'git commit -m "{commit_msg}"')
            signiture_list = ["nothing to commit, working tree clean"]
            if not any(str_working in std_list for str_working in signiture_list):
                pk_print(working_str=rf'''{'%%%FOO%%%' if LTA else ''}''', print_color='red')
                continue
        state_done[2] = 1
        pk_print(f'''state_done={state_done} {'%%%FOO%%%' if LTA else ''}''', print_color='green')
        if state_done[3] == 0:
            std_list = cmd_to_os(cmd=rf'git push origin {branch_n}')
            signiture_list = ["Everything up-to-date", "branch 'main' set up to track 'origin/main'."]
            if not any(str_working in std_list for str_working in signiture_list):
                continue
        state_done[3] = 1
        pk_print(f'''state_done={state_done} {'%%%FOO%%%' if LTA else ''}''', print_color='green')
        break


def ensure_input_preprocessed(working_str, upper_seconds_limit, return_default):
    # 이거 windows 에서망 동작하는 함수?
    import time
    from pkg_py.pk_colorful_cli_util import pk_print
    pk_time_s = time.time()
    user_input = None
    while 1:
        elapsed = time.time() - pk_time_s
        if elapsed >= upper_seconds_limit:
            pk_print(f'''elapsed >= upper_seconds_limit {'%%%FOO%%%' if LTA else ''}''')
            pk_print(f'''user_input={user_input} {'%%%FOO%%%' if LTA else ''}''')
            if not user_input:
                return return_default
            else:
                return user_input
        user_input = pk_input_with_timeout(working_str=rf'{working_str}', timeout_secs=int(upper_seconds_limit - elapsed))
        if user_input is None:
            user_input = ""
        user_input = user_input.strip()
        if user_input == "":
            return return_default
        elif user_input != "":
            return user_input


def pk_toggle_lta_from_pk_config_toml_v1():
    try:
        config_file = F_PK_CONFIG_TOML

        with open(config_file, 'r', encoding='utf-8') as file:
            lines = file.readlines()

        found = False
        for i, line in enumerate(lines):
            if line.startswith("LOCAL_TEST_ACTIVATE"):
                found = True
                current_value = int(line.split('=')[1].strip())
                new_value = 0 if current_value == 1 else 1
                lines[i] = f"LOCAL_TEST_ACTIVATE = {new_value}\n"
                print(f"LOCAL_TEST_ACTIVATE is now set to {new_value}.")
                break

        if not found:
            print("Error: 'LOCAL_TEST_ACTIVATE' not found in config file.")
            return

        with open(config_file, 'w', encoding='utf-8') as file:
            file.writelines(lines)

        print(f"LTA value successfully toggled and saved to {config_file}.")

    except Exception as e:
        print(f"Error: {e}")


def back_up_f_without_duplication_at_f_location(f: str) -> str:
    import os
    import shutil
    import re
    from pkg_py.pk_colorful_cli_util import pk_print  # 사용자 정의 함수
    if not os.path.isfile(f):
        pk_print(f"[ERROR][BACKUP] File not found: {f}", print_color='red')
        raise FileNotFoundError(f"File not found: {f}")
    base_p, f_nx = os.path.split(f)
    f_n, f_x = os.path.splitext(f_nx)
    pattern = re.compile(rf"^{re.escape(f_n)} \((\d+)\)\.bak$")
    existing_nums = []
    try:
        for name in os.listdir(base_p):
            m = pattern.fullmatch(name)
            if m:
                existing_nums.append(int(m.group(1)))
    except Exception as e:
        pk_print(f"[WARN] Failed to scan directory: {e}", print_color='red')
    try:
        next_num = max(existing_nums, default=0) + 1
        candidate = os.path.join(base_p, f"{f_n} ({next_num}).bak")
        shutil.copy2(f, candidate)
        pk_print(f"[BACKUP] {candidate}", print_color='green')
        return candidate
    except Exception as e:
        pk_print(f"[ERROR][BACKUP] Failed to create backup: {e}", print_color='red')
        raise


def pk_toggle_pk_config_key(key):
    # pk_config의 value가 bool인 경우만 사용가능

    def get_pk_config_for_toggling(key) -> int:
        from pkg_py.pk_colorful_cli_util import pk_print
        import tomllib
        try:
            with open(F_PK_CONFIG_TOML, 'rb') as f:
                config = tomllib.load(f)
            return int(config.get(key, 0))
        except Exception as e:
            pk_print(f"{key} {e}", print_color='red')
            return -1

    def set_pk_config_for_toggling(key, new_value: int):
        import toml  # toml:    쓰기 기능 추천
        import tomllib  # tomllib: 파싱/읽기 전용, binary 모드로 읽어야 하는 이유?
        try:
            assert new_value in (0, 1), "value must be 0 or 1"
            back_up_f_without_duplication_at_f_location(F_PK_CONFIG_TOML)
            with open(F_PK_CONFIG_TOML, 'rb') as f_obj:
                config = tomllib.load(f_obj)

            config[key] = new_value
            with open(F_PK_CONFIG_TOML, 'w', encoding='utf-8') as f_obj:
                toml.dump(config, f_obj)

            print(f"set {key} = {new_value}")
        except Exception as e:
            print(f"set {key} = {new_value} {e}")

    try:
        current = get_pk_config_for_toggling(key)
        if current == -1:
            return
        new_value = 0 if current == 1 else 1
        set_pk_config_for_toggling(key, new_value)

    except Exception as e:
        print(f"[ERROR][toggle] {e}")


def assist_to_upload_pnx_to_git(d_working, git_repo_url, branch_n):
    from pkg_py.pk_colorful_cli_util import pk_print
    pk_print(f'''d_working={d_working} {'%%%FOO%%%' if LTA else ''}''')
    loop_cnt = 1
    while 1:
        try:
            if loop_cnt == 1:
                commit_msg = ensure_input_preprocessed(working_str=f"commit_msg=", upper_seconds_limit=60, return_default=f"feat: make save point by auto at {get_time_as_('%Y-%m-%d %H:%M')}")
                push_pnx_to_github(d_working=d_working, git_repo_url=git_repo_url, commit_msg=commit_msg, branch_n=branch_n)
                loop_cnt = loop_cnt + 1
            if not ensure_d_size_stable(d_working, limit_seconds=30):
                if ensure_d_size_stable(d_working, limit_seconds=30):
                    pk_print("📂 change stable after 📂 change detected")
                    commit_msg = ensure_input_preprocessed(working_str=f"commit_msg=", upper_seconds_limit=60, return_default=f"feat: make save point by auto at {get_time_as_('%Y-%m-%d %H:%M')}")
                    push_pnx_to_github(d_working=d_working, git_repo_url=git_repo_url, commit_msg=commit_msg, branch_n=branch_n)
        except:
            import traceback
            pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
            break


def download_pnx_to_git_v1(d_working, git_repo_url, commit_msg, branch_n):
    import traceback
    from colorama import init as pk_colorama_init
    from pkg_py.pk_colorful_cli_util import pk_print

    pk_colorama_init(autoreset=True)

    try:
        if not does_pnx_exist(pnx=d_working):
            ensure_pnx_made(pnx=d_working, mode='d')

        d_git = rf"{d_working}/.git"

        if not does_pnx_exist(pnx=d_git):
            std_list = cmd_to_os(f'git clone -b {branch_n} {git_repo_url} {d_working}')
            pk_debug_state_for_py_data_type('%%%CLONE%%%', std_list)

            if any("fatal:" in line.lower() for line in std_list):
                pk_print(f"Git clone 실패: {std_list}", print_color='red')
                return
        else:
            pk_chdir(d_dst=d_working)
            std_list = cmd_to_os(f'git pull origin {branch_n}')
            pk_debug_state_for_py_data_type('%%%PULL%%%', std_list)

            if any("fatal:" in line.lower() for line in std_list):
                pk_print(f"Git pull 실패: {std_list}", print_color='red')
                return

        pk_print(f"Git 작업 완료: {d_working} {'%%%FOO%%%' if LTA else ''}", print_color='green')

    except Exception:
        pk_print(f"{traceback.format_exc()} {'%%%FOO%%%' if LTA else ''}", print_color='red')


def download_pnx_to_git_v2(d_working, git_repo_url, commit_msg, branch_n):
    import traceback
    import threading
    from colorama import init as pk_colorama_init
    from pkg_py.pk_colorful_cli_util import pk_print

    pk_colorama_init(autoreset=True)

    def ask_user_yes_no(msg, timeout=5):
        pk_print(f"{msg} (y/n, {timeout}초 내 응답): ", print_color='yellow')
        result = {'answer': None}

        def _get_input():
            try:
                result['answer'] = input().strip().lower()
            except Exception:
                result['answer'] = None

        thread = threading.Thread(target=_get_input)
        thread.daemon = True
        thread.start()
        thread.join(timeout)

        if result['answer'] is None:
            pk_print("시간 초과: 응답이 없어 작업을 건너뜁니다.", print_color='red')
            return 0

        return result['answer'] == 'y'

    try:
        if not does_pnx_exist(pnx=d_working):
            ensure_pnx_made(pnx=d_working, mode='d')

        d_git = rf"{d_working}/.git"

        if not does_pnx_exist(pnx=d_git):
            std_list = cmd_to_os(f'git clone -b {branch_n} {git_repo_url} {d_working}')
            pk_debug_state_for_py_data_type('%%%CLONE%%%', std_list)

            if any("fatal:" in line.lower() for line in std_list):
                pk_print(f"Git clone 실패: {std_list}", print_color='red')
                return
        else:
            pk_chdir(d_dst=d_working)
            std_list = cmd_to_os(f'git pull origin {branch_n}')
            pk_debug_state_for_py_data_type('%%%PULL%%%', std_list)

            if any("couldn't find remote ref" in line.lower() for line in std_list):
                pk_print(f"브랜치 '{branch_n}' 이(가) 원격 레포지토리에 없습니다.", print_color='red')
                if ask_user_yes_no(f"브랜치 '{branch_n}' 를 새로 만드시겠습니까?", timeout=10):
                    std_list = cmd_to_os(f'git checkout -b {branch_n}')
                    pk_debug_state_for_py_data_type('%%%CHECKOUT_NEW_BRANCH%%%', std_list)

                    std_list = cmd_to_os(f'git push -u origin {branch_n}')
                    pk_debug_state_for_py_data_type('%%%PUSH_NEW_BRANCH%%%', std_list)

                    if any("error:" in line.lower() or "failed to push" in line.lower() for line in std_list):
                        pk_print(f"브랜치 푸시 실패: {std_list}", print_color='red')

                        # 빈 커밋 생성 여부 질의
                        if ask_user_yes_no("커밋이 없어서 푸시에 실패한 것 같습니다. 빈 커밋을 생성할까요?", timeout=10):
                            std_list = cmd_to_os('git commit --allow-empty -m "init empty commit"')
                            pk_debug_state_for_py_data_type('%%%EMPTY_COMMIT%%%', std_list)

                            std_list = cmd_to_os(f'git push -u origin {branch_n}')
                            pk_debug_state_for_py_data_type('%%%PUSH_AFTER_EMPTY_COMMIT%%%', std_list)

                            if any("error:" in line.lower() or "failed to push" in line.lower() for line in std_list):
                                pk_print(f"빈 커밋 후 푸시도 실패했습니다: {std_list}", print_color='red')
                                return
                        else:
                            pk_print("사용자가 빈 커밋 생성을 취소했습니다.", print_color='red')
                            return
                else:
                    pk_print("사용자가 브랜치 생성을 취소했습니다.", print_color='red')
                    return
            elif any("fatal:" in line.lower() for line in std_list):
                pk_print(f"Git pull 실패: {std_list}", print_color='red')
                return

        pk_print(f"Git 작업 완료: {d_working} {'%%%FOO%%%' if LTA else ''}", print_color='green')

    except Exception:
        pk_print(f"{traceback.format_exc()} {'%%%FOO%%%' if LTA else ''}", print_color='red')


def download_pnx_to_git_v3(d_working, git_repo_url, commit_msg, branch_n):
    import traceback
    import threading
    import time
    # from colorama import init as pk_colorama_init
    from pkg_py.pk_colorful_cli_util import pk_print

    # pk_colorama_init(autoreset=True)

    def ask_user_yes_no(msg, timeout=10):
        pk_print(f"{msg} (y/n, {timeout}초 내 응답): ", print_color='yellow')
        result = {'answer': None}

        def _get_input():
            try:
                result['answer'] = input().strip().lower()
            except Exception:
                result['answer'] = None

        def _countdown():
            for i in reversed(range(1, timeout + 1)):
                pk_print(f"⏳ 남은 시간: {i}초", print_color='cyan')
                time.sleep(1)

        input_thread = threading.Thread(target=_get_input)
        timer_thread = threading.Thread(target=_countdown)
        input_thread.daemon = True
        timer_thread.daemon = True
        input_thread.start()
        timer_thread.start()

        input_thread.join(timeout)

        if result['answer'] is None:
            pk_print("시간 초과: 응답이 없어 작업을 건너뜁니다.", print_color='red')
            return 0

        return result['answer'] == 'y'

    try:
        if not does_pnx_exist(pnx=d_working):
            ensure_pnx_made(pnx=d_working, mode='d')

        d_git = rf"{d_working}/.git"

        if not does_pnx_exist(pnx=d_git):
            std_list = cmd_to_os(f'git clone -b {branch_n} {git_repo_url} {d_working}')
            pk_debug_state_for_py_data_type('%%%CLONE%%%', std_list)

            if any("fatal:" in line.lower() for line in std_list):
                pk_print(f"Git clone 실패: {std_list}", print_color='red')
                return
        else:
            pk_chdir(d_dst=d_working)
            std_list = cmd_to_os(f'git pull origin {branch_n}')
            pk_debug_state_for_py_data_type('%%%PULL%%%', std_list)

            if any("couldn't find remote ref" in line.lower() for line in std_list):
                pk_print(f"브랜치 '{branch_n}' 이(가) 원격 레포지토리에 없습니다.", print_color='red')
                if ask_user_yes_no(f"브랜치 '{branch_n}' 를 새로 만드시겠습니까?"):
                    std_list = cmd_to_os(f'git checkout -b {branch_n}')
                    pk_debug_state_for_py_data_type('%%%CHECKOUT_NEW_BRANCH%%%', std_list)

                    std_list = cmd_to_os(f'git push -u origin {branch_n}')
                    pk_debug_state_for_py_data_type('%%%PUSH_NEW_BRANCH%%%', std_list)

                    if any("error:" in line.lower() or "failed to push" in line.lower() for line in std_list):
                        pk_print(f"브랜치 푸시 실패: {std_list}", print_color='red')

                        if ask_user_yes_no("커밋이 없어서 푸시에 실패한 것 같습니다. 빈 커밋을 생성할까요?"):
                            std_list = cmd_to_os('git commit --allow-empty -m "init empty commit"')
                            pk_debug_state_for_py_data_type('%%%EMPTY_COMMIT%%%', std_list)

                            std_list = cmd_to_os(f'git push -u origin {branch_n}')
                            pk_debug_state_for_py_data_type('%%%PUSH_AFTER_EMPTY_COMMIT%%%', std_list)

                            if any("error:" in line.lower() or "failed to push" in line.lower() for line in std_list):
                                pk_print(f"빈 커밋 후 푸시도 실패했습니다: {std_list}", print_color='red')
                                return
                        else:
                            pk_print("사용자가 빈 커밋 생성을 취소했습니다.", print_color='red')
                            return
                else:
                    pk_print("사용자가 브랜치 생성을 취소했습니다.", print_color='red')
                    return
            elif any("fatal:" in line.lower() for line in std_list):
                pk_print(f"Git pull 실패: {std_list}", print_color='red')
                return

        pk_print(f"Git 작업 완료: {d_working} {'%%%FOO%%%' if LTA else ''}", print_color='green')

    except Exception:
        pk_print(f"{traceback.format_exc()} {'%%%FOO%%%' if LTA else ''}", print_color='red')


def download_pnx_to_git(d_working, git_repo_url, commit_msg, branch_n):
    download_pnx_to_git_v3(d_working, git_repo_url, commit_msg, branch_n)


def save_all_drive_pnxs_to_txt_f():  # 이 함수는 Everything.exe 를 대체할 f탐색기 용도로 만들었으나 거의 필요 없을 것 같다. 관심d만 확인하는 것으로 충분해 보인다.
    """모든 f d에 대한 정보를 텍스트 f로 저장하는 함수"""
    import os
    from pkg_py.pk_core_constants import Encoding, D_HOME, UNDERLINE, D_PROJECT
    from pkg_py.pk_colorful_cli_util import pk_print

    # 윈도우냐 아니야에 따라
    # os.system('chcp 65001 >nul')
    # os.system('export LANG=en_US.UTF-8 >nul')

    opening_d = os.getcwd()
    proper_tree_txt = rf"{D_PROJECT}\pkg_all_tree\proper_tree.txt"
    all_tree_txt = rf"{D_PROJECT}\pkg_all_tree\all_tree.txt"
    if not os.path.exists(os.path.dirname(all_tree_txt)):
        os.makedirs(os.path.dirname(all_tree_txt))
        # os.system(f'echo. >> "{all_tree_txt}"')
        os.system(f'echo. >> "{all_tree_txt}" >nul')
        os.system(f'echo. >> "{proper_tree_txt}" >nul')
    with open(file=all_tree_txt, mode='w', encoding=Encoding.UTF8.value) as f:
        f.write(" ")
    with open(file=proper_tree_txt, mode='w', encoding=Encoding.UTF8.value) as f:
        f.write(" ")

    drives = "foo"

    f_cnt = 0
    f = open(D_PROJECT + '\\all_list.txt', 'a', encoding=Encoding.UTF8.value)  # >>  a    > w   각각 대응됨.
    for drive in drives:
        pk_chdir(drive)
        for root, d_nx_list, f_nx_list in os.walk(os.getcwd()):  # 여기 또 os.getcwd() 있는 부분 수정하자..
            for f_nx in f_nx_list:
                f_cnt = f_cnt + 1
                f.write(str(f_cnt) + " " + os.path.join(root, f_nx) + "\n")
    f.close()  # close() 를 사용하지 않으려면 with 문을 사용하는 방법도 있다.
    pk_print(f"{UNDERLINE}{UNDERLINE}all_list.txt writing e", print_color='blue')
    pk_print(f"{UNDERLINE}{UNDERLINE}all_list_proper.txt rewriting s", print_color='blue')
    texts_black = [
        rf"C:\$WinREAgent",
        rf"C:\mingw64",
        rf"C:\PerfLogs",
        rf"C:\Program Files (x86)",
        rf"C:\Program Files",
        rf"C:\ProgramData",
        rf"C:\Temp",
        rf"C:\Users\All Users",
        rf"C:\Windows\servicing",
        rf"C:\Windows\SystemResources",
        rf"C:\Windows\WinSxS",
        rf"C:\Users\Default",
        rf"C:\Users\Public",
        rf"C:\Windows.old",
        rf"C:\Windows",
        rf"C:\$Recycle.Bin",
        rf"D:\$RECYCLE.BIN",
        rf"E:\$RECYCLE.BIN",
        rf"E:\$Recycle.Bin",
        rf"F:\$RECYCLE.BIN",
        rf"{D_HOME}\AppData",
    ]
    texts_white = [
        ".mkv",
    ]
    f = open(rf'{D_PROJECT}\all_list.txt', 'r+', encoding=Encoding.UTF8.value)
    f2 = open(rf'{D_PROJECT}\all_list_proper.txt', 'a', encoding=Encoding.UTF8.value)
    lines_cnt = 0
    while 1:
        line = f.readline()
        if not line:
            break
        lines_cnt = lines_cnt + 1
        if any(text_black not in line for text_black in texts_black):
            # pk_print(line)
            if any(text_white in line for text_white in texts_white):
                # pk_print(line.split("\n")[0] + " o")
                f2.write(line.split("\n")[0] + " o " + "\n")
                # pk_print('o')
                pass
            else:
                # pk_print(line.split("\n")[0] + " x")
                # f2.write(line.split("\n")[0] + " x "+"\n")
                # pk_print('x')
                pass
    f.close()
    f2.close()
    pk_print(f"{UNDERLINE}{UNDERLINE}all_list_proper.txt rewriting e", print_color='blue')

    pk_print(f"{UNDERLINE}{UNDERLINE}files opening s", print_color='blue')
    pk_chdir(os.getcwd())

    # 윈도우냐 아니냐
    os.system("chcp 65001 >nul")
    os.system('export LANG=en_US.UTF-8 >nul')

    # os.system("type all_list.txt")
    # os.system("explorer all_list.txt")
    os.system("explorer all_list_proper.txt")
    pk_print(f"{UNDERLINE}{UNDERLINE}files opening e", print_color='blue')

    # os.system('del "'+os.getcwd()+'\\all_list.txt"')
    # mk("all_list.txt")
    pk_print(f"{UNDERLINE}{UNDERLINE}e", print_color='blue')


def get_line_cnt_of_f(f: str):
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    try:
        line_cnt = 0
        # f 변경 감지 이슈: linecache 모듈은 f의 변경을 감지하지 못합니다.
        # f이 변경되었을 때에도 이전에 캐시된 내용을 반환하여 오래된 정보를 사용할 수 있습니다.
        # 실시간으로 f의 변경을 감지해야 하는 경우에는 정확한 결과를 얻기 어려울 수 있습니다.
        # line_cnt=len(linecache.getlines(pnx_todo))
        # pk_print(f'line_cnt:{line_cnt}')  캐시된 내용을 반환하기 때문에. 실시간 정보가 아니다

        # 이 코드는 실시간으로 f의 변경을 감지 처리 되도록 수정, 단, f이 크면 성능저하 이슈 있을 수 있다.
        with open(file=f, mode='r', encoding="UTF-8") as file:
            # whole_contents=file.readlines()
            # pk_print(whole_contents)
            # line_cnt=len(whole_contents)
            # line_cnt=list(en umerate(file))[-1][0] + 1
            line_cnt = file.read().count("\n") + 1
        return line_cnt
    except FileNotFoundError:
        pk_print("f을 찾을 수 없었습니다", print_color='blue')
        pass
    except Exception:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')


def move_mouse(x_abs: float, y_abs: float, duration=1):
    import pyautogui
    # func_n = inspect.currentframe().f_code.co_name
    pyautogui.moveTo(x_abs, y_abs, duration)


def move_mouse_rel_x(x_rel: float, y_rel: float):
    import inspect
    import pyautogui
    func_n = inspect.currentframe().f_code.co_name
    pyautogui.move(x_rel, y_rel)


def get_current_mouse_abs_info():
    import inspect
    import pyautogui
    func_n = inspect.currentframe().f_code.co_name
    coordination = pyautogui.position()
    coordination = str(coordination)
    coordination = coordination.replace("Point(x=", "")
    coordination = coordination.replace("y=", "")
    coordination = coordination.replace(")", "")
    coordination = coordination.replace(" ", "")
    x = coordination.split(",")[0]
    y = coordination.split(",")[1]
    return x, y


def open_mouse_info():
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    # pyautogui.mouseInfo()


def pk_press(*presses: str, interval=0.0):
    from pkg_py.pk_colorful_cli_util import pk_print
    import pyautogui
    while 1:
        # single key press
        if len(presses) == 1:
            if "+" in presses[0]:
                key_list = []
                key_list = presses[0].split("+")
                key_list = get_list_striped_element(key_list)
                pyautogui.hotkey(*key_list, interval=interval)
                tmp = ' + '.join(i for i in presses)
                pk_print(working_str=rf'''{tmp}  {'%%%FOO%%%' if LTA else ''}''')
                break
            if presses == "pgup":
                presses = "pageup"
            elif presses == "pgdn":
                presses = "pagedown"
            for i in pyautogui.KEYBOARD_KEYS:
                if str(i) == str(presses[0]):
                    pyautogui.press(str(presses[0]), interval=interval)
                    pk_print(working_str=rf'''{i}  {'%%%FOO%%%' if LTA else ''}''')
                    break
                else:
                    pass
        # hotkey press
        else:
            pyautogui.hotkey(*presses, interval=interval)
            tmp = ' + '.join(i for i in presses)
            pk_print(working_str=rf'''{tmp}  {'%%%FOO%%%' if LTA else ''}''')
        # pk_sleep(milliseconds=100)
        break


#
# def get_400px_screenshot(milliseconds=0):

#     """pyautogui, 마우스의 위치 주변 가로 세로 400 px  400 px 로 스크린샷 찍어서 저장하는 코드"""
#     # 재우기
#     pk_sleep(milliseconds=milliseconds)
#
#     # 현재 마우스 위치 가져오기
#     x, y=pyautogui.position()
#     width=400
#     height=400
#     left=x - width / 2  # height/2 일수도 있음
#     top=y - height / 2  # 여기도 마찬가지 일수 있음
#
#     # 스크린샷 찍기
#     pygui=pyautogui.screenshot(region=(left, top, width, height))
#
#     # 스크린샷 저장
#     server_time=get_time_as_('%Y_%m_%d_%H_%M_%S')
#     screenshot_png=rf'{PROJECT_D}\pkg_png\screenshot_{server_time}.png'
#     try:
#         os.makedirs(os.path.dirname(screenshot_png))
#     except FileExistsError:
#         pass
#     pygui.save(screenshot_png)
#     pygui.show(screenshot_png)


def collect_img_for_autogui():
    import inspect
    import sys
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PKG_PNG
    from pkg_py.pk_interface_graphic_user import print_as_gui
    func_n = inspect.currentframe().f_code.co_name
    server_time = get_time_as_('%Y_%m_%d_%H_%M_%S')
    func_n_server_time_png = rf'{D_PKG_PNG}\{func_n}_{server_time}.png'
    f = func_n_server_time_png
    f_p = get_p(func_n_server_time_png)
    file_nx = get_nx(func_n_server_time_png)
    ensure_pnx_made(f_p, mode="d")
    try:
        pk_press("win", "shift", "s", interval=0.5)
        key = "ctrl+s"
        if not is_keyboard_pressed_within_time_limit(key_plus_key=key, time_limit=60):
            pk_print(rf"[red] 클릭감지타임아웃 {key}")
        pk_sleep(milliseconds=500)
        pk_sleep(milliseconds=500)
        pk_press("ctrl", "l", interval=0.5)
        pk_sleep(milliseconds=300)
        pk_copy(working_str=f_p)
        pk_sleep(milliseconds=300)
        pk_press("enter")
        pk_sleep(milliseconds=300)
        print_as_gui(ment="클립보드에 추천f명을 저장해두었습니다")
        key = "left"
        if not is_mouse_button_click_within_time_limit(key="left", time_limit=60):
            ment_error = rf"[red] 클릭감지타임아웃 {key}"
            # raise FridayLogicError(ment_error)
            pk_print(ment_error)
        write_fast(file_nx)
        pk_sleep(milliseconds=300)
        # press("enter")
        pk_sleep(milliseconds=300)
        if does_pnx_exist(pnx=f):
            cmd = rf"taskkill -im ScreenSketch.exe"
        text_editor = 'explorer.exe'
        cmd = f'{text_editor} "{f_p}" '
        cmd_to_os(cmd=cmd)
    except:
        traceback.print_exc(file=sys.stdout)


def write_fast(string: str):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    pk_sleep(milliseconds=500)
    copy_and_paste_with_keeping_clipboard(string)
    pk_print(rf"{string}", print_color='blue')


def write_like_person(str_working: str, interval=0.04):  # interval 낮을 수록 빠름 # cmd.exe 를 admin 으로 열면 클립보드가 막혀있음.
    import inspect

    from pkg_py.pk_colorful_cli_util import pk_print
    import pyautogui
    func_n = inspect.currentframe().f_code.co_name

    pyautogui.write(str_working, interval=interval)  # 한글 미지원.
    pk_print(rf"{str_working}", print_color='blue')


def write(string: str, milliseconds=500):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    pk_sleep(milliseconds=milliseconds)
    copy_and_paste_with_keeping_clipboard(string)
    pk_print(rf"{string}", print_color='blue')


def ask_to_wrtn(question: str):
    import inspect
    from pkg_py.pk_core_constants import D_PROJECT
    func_n = inspect.currentframe().f_code.co_name
    while 1:
        # 페이지 열기
        url = "https://wrtn.ai/"
        cmd = f'explorer  "{url}"  >nul'
        cmd_to_os_like_person_as_admin(cmd)

        # 크롬 창 활성화
        src_pid: int = get_pids(process_img_n="chrome.exe")  # chrome.exe pid 가져오기
        ensure_window_to_front(pid=src_pid)

        # 크롬 기본 배율로 변경
        pk_press('ctrl', '0')

        # 광고닫기 버튼 클릭
        f_png = rf"{D_PROJECT}\pkg_png\ask_to_wrtn_ad_close.png"
        click_center_of_img_recognized_by_mouse_left(img_pnx=f_png, loop_limit_cnt=10, is_zoom_toogle_mode=True)

        # 프롬프트 콘솔 클릭(광고 없어도 진행)
        f_png = rf"{D_PROJECT}\pkg_png\ask_to_wrtn.png"
        if click_center_of_img_recognized_by_mouse_left(img_pnx=f_png, loop_limit_cnt=50, is_zoom_toogle_mode=True):
            # 질문 작성 및 확인
            write_fast(question)
            pk_press('enter')

        # 뤼튼 프롬프트 콘솔 최하단 이동 버튼 클릭
        break


def find_direction_via_naver_map(destination: str):
    import inspect
    from pkg_py.pk_core_constants import D_PROJECT
    func_n = inspect.currentframe().f_code.co_name
    while 1:
        # 배경화면으로 나가기(옵션로직)
        # press("win", "m")
        # press("win", "m")
        # sleep(10)

        # 페이지 열기
        # url="https://map.naver.com/"
        url = "https://map.naver.com/p/directions"
        cmd = f'explorer  "{url}"  >nul'
        cmd_to_os_like_person_as_admin(cmd)
        pk_sleep(300)

        # 크롬 창 활성화
        pid_chrome_exe = get_pids(process_img_n="chrome.exe")  # chrome.exe pid 가져오기
        ensure_window_to_front(pid=pid_chrome_exe)
        pk_sleep(30)

        # 반쪽화면 생성(옵션로직)
        # press("alt", "up")
        # press("alt", "left")

        # 출발지 입력 클릭
        f_png = rf"{D_PROJECT}\pkg_png\find_direction_via_naver_direction.png"
        click_center_of_img_recognized_by_mouse_left(img_pnx=f_png, loop_limit_cnt=100, is_zoom_toogle_mode=True)
        pk_sleep(30)

        # 한가람한양아파트상가 입력
        write_fast("한가람한양아파트상가")
        pk_sleep(30)
        pk_press('enter')
        pk_sleep(300)
        pk_press('tab')
        pk_sleep(30)

        # 목적지 입력
        write_fast(destination)
        pk_sleep(30)
        pk_press('down')
        pk_press('enter')

        # 길찾기 클릭
        pk_press('tab')
        pk_press('tab')
        pk_press('tab')
        pk_press('enter')

        # 작업마침 알림
        pk_speak_v2(working_str='길찾기가 시도되었습니다', comma_delay=0.98)
        break


def empty_recycle_bin():
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_HOME

    func_n = inspect.currentframe().f_code.co_name

    # logging
    cmd_to_os_like_person_as_admin(rf'echo y | del {D_HOME}\AppData\Roaming\Microsoft\Windows\Recent')
    cmd_to_os_like_person_as_admin('PowerShell.exe -NoProfile -cmd Clear-RecycleBin -Confirm:$false')
    # 휴지통 삭제 (외장하드까지)
    # for %%a in (cdefghijk L mnopqrstuvwxyz) do (
    # 존재하는 경우 %%a:\$RECYCLE.BIN for /f "tokens=* usebackq" %%b in (`"dir /a:d/b %%a:\$RECYCLE.BIN\"`) do rd / q/s "%%a:\$RECYCLE.BIN\%%~b"
    # 존재하는 경우 %%a:\RECYCLER for /f "tokens=* usebackq" %%b in (`"dir /a:d/b %%a:\RECYCLER\"`) do rd /q/s "%% a:\RECYCLER\%%~b"
    # )

    # 가끔 휴지통을 열어볼까요?
    # pk_print(str_working="숨김 휴지통 열기")
    # cmd='explorer c:\$RECYCLE.BIN'
    # run_via_cmd_exe(cmd=cmd)
    # 외장하드 숨김 휴지통 을 보여드릴까요
    # explorer c:\$RECYCLE.BIN
    # explorer d:\$RECYCLE.BIN
    # explorer e:\$RECYCLE.BIN
    # explorer f:\$RECYCLE.BIN

    # speak_ment_experimental(f'휴지통을 비웠습니다', comma_delay=0.98, thread_join_mode=True)
    pk_print(f'''휴지통을 비웠습니다"''')


#
# def pk_print(string: str, is_app_instance_mode=False, input_text_default="", auto_click_positive_btn_after_seconds=3):
#     pk_print(string)
#     # print_as_gui(ment, auto_click_positive_btn_after_seconds=1)
#     # print_as_gui(ment, auto_click_positive_btn_after_seconds=0)
#     # pk_sleep(milliseconds=500)
#     # pk_sleep(milliseconds=400)
#     # pk_sleep(milliseconds=350)
#     # pk_sleep(milliseconds=300)


def click_mouse_left_btn(x_abs=None, y_abs=None, doubleclick_mode=False):
    import inspect
    import pyautogui
    func_n = inspect.currentframe().f_code.co_name
    if doubleclick_mode == True:
        clicks = 2
    else:
        clicks = 1
    if x_abs and y_abs:
        pyautogui.click(button='left', clicks=clicks, interval=0, x=x_abs, y=y_abs)
    else:
        pyautogui.click(button='left', clicks=clicks, interval=0)


def click_mouse_right_btn(abs_x=None, abs_y=None):
    import inspect
    import pyautogui
    func_n = inspect.currentframe().f_code.co_name
    if abs_x and abs_y:
        pyautogui.click(button='right', clicks=1, interval=0)
    else:
        pyautogui.click(button='right', clicks=1, interval=0, x=abs_x, y=abs_y, )


def ask_to_google(question: str):
    from pkg_py.pk_colorful_cli_util import pk_print
    # str preprocess
    question = question.replace(" ", "+")
    question = question.strip()

    # search in google
    cmd = f'explorer "https://www.google.com/search?q={question}"  >nul'
    cmd_to_os(cmd=cmd)
    pk_print(f'''{cmd}  {'%%%FOO%%%' if LTA else ''}''', print_color="blue")

    # move window to front
    window_title_seg = rf"{question} - Google"
    while 1:
        ensure_window_to_front(window_title_seg=window_title_seg)
        if is_front_window_title(window_title_seg=window_title_seg):
            break


def ask_to_chatGPT(question: str):
    from pkg_py.pk_colorful_cli_util import pk_print
    # todo : ref : not ready
    pk_print(f'''this service is not ready  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
    return

    # str preprocess
    question = question.replace(" ", "+")
    question = question.strip()

    # search in chatGPT
    # todo : candi : chatGPT api 사용
    # todo : candi : selenium, cloudflare 사용
    # todo : final : chatGPT api 사용
    # cmd = f'explorer "https://www.google.com/search?q={question}"  >nul'
    # cmd_to_os(cmd=cmd)
    # pk_print(f'''{cmd}  {'%%%FOO%%%' if LTA else ''}''', print_color="blue"))

    # move window to front
    window_title_seg = rf"ChatGPT"
    while 1:
        ensure_window_to_front(window_title_seg=window_title_seg)
        if is_front_window_title(window_title_seg=window_title_seg):
            break


def get_img_when_img_recognized_succeed(img_abspath, recognize_loop_limit_cnt=0, is_zoom_toogle_mode=False):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_interface_graphic_user import GuiUtil
    import pyautogui
    func_n = inspect.currentframe().f_code.co_name
    # speak("화면 이미지 분석을 시도합니다")
    GuiUtil.pop_up_as_complete(title="화면이미지분석 시도 전 보고", ment="화면 이미지 분석을 시도합니다", auto_click_positive_btn_after_seconds=1)

    pk_press('ctrl', '0', interval=0.15)  # 이미지 분석 시 크롬 zoom 초기화(ctrl+0)

    # 고해상도/다크모드 에서 시도
    for i in range(0, 9):
        pk_press('ctrl', '+')

    chrome_zoom_step = 0

    # 루프카운트 제한 n번 default 0번 으로 설정
    func_n = inspect.currentframe().f_code.co_name
    loop_cnt = 0
    # recognize_loop_limit_cnt=recognize_loop_limit_cnt
    if recognize_loop_limit_cnt == 0:
        while 1:
            # 인식률 및 속도 개선 시도
            # pip install opencv-python # 이것은 고급 기능이 포함되지 않은 Python용 OpenCV의 미니 버전입니다. 우리의 목적에는 충분합니다.
            # confidence=0.7(70%)유사도를 낮춰 인식률개선시도, region 낮춰 속도개선시도, grayscale 흑백으로 판단해서 속도개선시도,
            # open cv 설치했는데 적용안되고 있음. 재부팅도 하였는 데도 안됨.
            # xy_infos_of_imgs=pyautogui.locateOnScreen(img_abspath, confidence=0.7, grayscale=True)
            # debug_as_gui(xy_infos_of_imgs is None)
            pk_print("화면 이미지 인식 시도 중...")
            loop_cnt = loop_cnt + 1
            try:
                img = pyautogui.locateOnScreen(img_abspath, confidence=0.7, grayscale=True)
                pk_print(type(img), print_color='blue')
                pk_print(img, print_color='blue')
                pk_print(img is not None, print_color='blue')
                if img is not None:
                    return img
                else:
                    pk_print(f"화면 이미지 분석 중...")
                    pk_print(img_abspath, print_color='blue')
                    pk_sleep(milliseconds=15)
                    if is_zoom_toogle_mode == True:
                        if chrome_zoom_step == 14:
                            chrome_zoom_step = 0
                        elif chrome_zoom_step < 7:
                            pk_press('ctrl', '-')
                            chrome_zoom_step = chrome_zoom_step + 1
                        elif 7 <= chrome_zoom_step:
                            pk_press('ctrl', '+')
                            chrome_zoom_step = chrome_zoom_step + 1
            except pyautogui.ImageNotFoundException:
                pk_print(f"{loop_cnt}번의 화면인식시도를 했지만 인식하지 못하였습니다")
                pass
    else:
        while 1:
            loop_cnt = loop_cnt + 1
            pk_print("화면 이미지 인식 시도 중...")
            if recognize_loop_limit_cnt == loop_cnt:
                pk_print(f"{loop_cnt}번의 화면인식시도를 했지만 인식하지 못하였습니다")
                return None
            try:
                img = pyautogui.locateOnScreen(img_abspath, confidence=0.7, grayscale=True)
                pk_print(type(img), print_color='blue')
                pk_print(img, print_color='blue')
                pk_print(img is not None, print_color='blue')
                if img is not None:
                    return img
            except:
                pk_print(img_abspath, print_color='blue')
                pk_sleep(milliseconds=10)
                if is_zoom_toogle_mode == True:
                    if chrome_zoom_step == 14:
                        chrome_zoom_step = 0
                    elif chrome_zoom_step < 7:
                        pk_press('ctrl', '-')
                        chrome_zoom_step = chrome_zoom_step + 1
                    elif 7 <= chrome_zoom_step:
                        pk_press('ctrl', '+')
                        chrome_zoom_step = chrome_zoom_step + 1


def click_center_of_img_recognized_by_mouse_left(img_pnx: str, loop_limit_cnt=0, is_zoom_toogle_mode=False):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    img = get_img_when_img_recognized_succeed(img_pnx, loop_limit_cnt, is_zoom_toogle_mode)
    if not img is None:
        center_x = img.left + (img.width / 2)
        center_y = img.top + (img.height / 2)
        move_mouse(x_abs=center_x, y_abs=center_y)
        click_mouse_left_btn(x_abs=center_x, y_abs=center_y)
        return 1
    else:
        return 0


async def shoot_custom_screenshot_via_asyncio():
    import inspect
    import sys
    import traceback
    from pkg_py.pk_core_constants import D_PKG_TXT
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_interface_graphic_user import should_i_do
    func_n = inspect.currentframe().f_code.co_name
    while 1:
        try:
            timestamp = get_time_as_('%Y_%m_%d_%H_%M_%S')
            PKG_IMAGE = PKG_IMAGE
            positivie = "Positive"
            negative = "Negative"
            user_input = None
            hostname = get_hostname()
            pk_print(working_str=rf'''hostname="{hostname}"  {'%%%FOO%%%' if LTA else ''}''')

            token_hostname_desktop = get_token_from_f_txt(f_token=rf'{D_PKG_TXT}\token_hostname_desktop.txt', initial_str="")
            token_hostname_a2z_galaxybook = get_token_from_f_txt(f_token=rf'{D_PKG_TXT}\token_hostname_a2z_galaxybook.txt', initial_str="")
            if token_hostname_a2z_galaxybook in hostname:
                user_input = input("저장할 스크린샷의 키f명을 입력하세요:")
            if token_hostname_desktop in hostname:
                txt_clicked, function, txt_written = should_i_do(
                    prompt=rf"저장할 스크린샷의 키f명을 입력하세요",
                    btn_list=[positivie, negative],
                    function=None,
                    auto_click_negative_btn_after_seconds=30,
                    title=f"{func_n}()",
                    input_box_mode=True,
                )
                if txt_clicked != positivie:
                    return
                user_input = txt_written
            user_input = user_input.strip()
            user_input = user_input.replace(" ", "_")
            f_png_nx = rf'screenshot_{user_input}_{timestamp}.png'
            f_png = rf'{PKG_IMAGE}\{f_png_nx}'
            import asyncio
            await asyncio.sleep(2)

            # snipping tool exec
            pk_press("win", "shift", "s", interval=0.5)

            if is_keyboard_pressed_within_time_limit("ctrl+s", time_limit=10):
                if not does_pnx_exist(pnx=PKG_IMAGE):
                    ensure_pnx_made(pnx=PKG_IMAGE, mode="d")
            else:
                return

            await asyncio.sleep(1)  # milliseconds 로 하면 좋겠음.
            pk_press("ctrl", "l")
            await asyncio.sleep(1)
            write_like_person(PKG_IMAGE, interval=0.015)
            await asyncio.sleep(1)
            pk_press("enter")
            await asyncio.sleep(1)
            if "DESKTOP-UGLEIND" in hostname:  # windows 11인 경우같다
                for i in range(0, 7):
                    pk_press("tab")
            else:
                for i in range(0, 4):
                    pk_press("tab")
            write(f_png_nx)
            await asyncio.sleep(1)
            pk_press("enter")
            await asyncio.sleep(1)
            if does_pnx_exist(pnx=f_png):
                pk_print(working_str=rf'''f_png="{f_png}"  {'%%%FOO%%%' if LTA else ''}''')

                # Snipping Tool.ink 종료
                cmd = rf"taskkill -im SnippingTool.exe"
                cmd_to_os(cmd=cmd, mode="a")
                break
        except:
            traceback.print_exc(file=sys.stdout)


def speak_that_service_is_in_preparing():
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    pk_speak_v2(working_str="아직 준비되지 않은 서비스 입니다", comma_delay=0.98)


def on_right_click(x, y, button, pressed):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pynput import mouse
    if pressed and button == mouse.Button.right:
        click_detected = True  # 클릭 감지 상태 업데이트
        pk_print("마우스 우클릭 감지됨!")
        return 0  # 마우스 왼쪽 클릭 감지되면 Listener 종료


def on_left_click(x, y, button, pressed):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pynput import mouse
    if pressed and button == mouse.Button.left:
        click_detected = True  # 클릭 감지 상태 업데이트
        pk_print("마우스 왼쪽 클릭 감지됨!")
        return 0  # 마우스 왼쪽 클릭 감지되면 Listener 종료


#
# def detect_mouse_click(time_limit=10):
#     """10초 이내에 마우스 왼쪽 클릭을 감지하는 함수.
#         timeout (int): 클릭 감지를 위한 대기 시간 (초).
#         bool: 클릭이 감지되면 True, 그렇지 않으면 False.
#     """
#     time_s=time.time()
#     print_as_gui("10초 이내에 마우스 왼쪽 클릭을 해주세요..." ,auto_click_positive_btn_after_seconds=2)
#     while (time.time() - time_s) < time_limit:
#         if keyboard.is_pressed('left'):
#             print_as_gui("마우스 왼쪽 클릭 감지됨!")
#             return 1
#         sleep(seconds=0.1)  # CPU 사용량을 줄이기 위해 잠시 대
#     print_as_gui("타임아웃! 클릭이 감지되지 않았습니다.")
#     return 0


def translate_eng_to_kor(question: str):
    import sys
    import traceback
    from pkg_py.pk_core_constants import D_PROJECT
    import pyautogui
    if not is_internet_connected():
        raise
    try:
        while 1:
            try:
                question = question.strip('""')
            except AttributeError:
                break
            pk_press("win", "m")

            # 구글 번역 페이지로 이동
            url = "https://www.google.com/search?q=eng+to+kor"
            cmd = f'explorer "{url}" >nul'
            cmd_to_os_like_person_as_admin(cmd)

            # 크롬 창 활성화
            target_pid: int = get_pids(process_img_n="chrome.exe")  # chrome.exe pid 가져오기
            ensure_window_to_front(pid=target_pid)

            # 텍스트를 입력하세 클릭
            f_png = rf"{D_PROJECT}\pkg_png\eng to kor.png"
            click_center_of_img_recognized_by_mouse_left(img_pnx=f_png, is_zoom_toogle_mode=True, loop_limit_cnt=100)

            # 번역할 내용 작성
            write_fast(question)

            # 글자수가 많으면 text to voice icon 이 잘려서 보이지 않음. 이는 이미지의 객체 인식이 불가능해지는데
            # 스크롤를 내려서 이미지 인식을 가능토록
            if len(question) > 45:
                pyautogui.vscroll(-15)
            pk_sleep(30)

            # text to voice icon
            f_png = rf"{D_PROJECT}\pkg_png\text to voice icon.png"
            click_center_of_img_recognized_by_mouse_left(img_pnx=f_png, is_zoom_toogle_mode=True, loop_limit_cnt=100)

            # 종료
            break
    except:
        traceback.print_exc(file=sys.stdout)


def translate_kor_to_eng(question: str):
    import sys
    import traceback
    from pkg_py.pk_core_constants import D_PROJECT
    import pyautogui
    if not is_internet_connected():
        raise
    try:
        while 1:
            try:
                question = question.strip('""')
            except AttributeError:
                break
            pk_press("win", "m")

            # 페이지 열기
            url = "https://www.google.com/search?q=kor+to+eng"
            cmd = f'explorer "{url}" >nul'
            cmd_to_os_like_person_as_admin(cmd)

            # 크롬 창 활성화
            target_pid = get_pids(process_img_n="chrome.exe")  # chrome.exe pid 가져오기
            ensure_window_to_front(pid=target_pid)

            # Enter Text 클릭
            f_png = rf"{D_PROJECT}\pkg_png\kor to eng.png"
            click_center_of_img_recognized_by_mouse_left(img_pnx=f_png, is_zoom_toogle_mode=True, loop_limit_cnt=100)

            # 번역할 내용 작성
            write_fast(question)

            # 글자수가 많으면 text to voice icon 이 잘려서 보이지 않음. 이는 이미지의 객체 인식이 불가능해지는데
            # 스크롤를 내려서 이미지 인식을 가능토록
            if len(question) > 45:
                pyautogui.vscroll(-15)
            pk_sleep(30)

            # text to voice icon
            f_png = rf"{D_PROJECT}\pkg_png\text to voice icon.png"
            click_center_of_img_recognized_by_mouse_left(img_pnx=f_png, is_zoom_toogle_mode=True, loop_limit_cnt=100)

            break
    except:
        traceback.print_exc(file=sys.stdout)


def run_cmd_exe_as_admin():
    import inspect
    import sys
    import traceback
    func_n = inspect.currentframe().f_code.co_name
    try:
        while 1:
            # run.exe 관리자모드로 exec
            cmd_to_os_like_person_as_admin('PowerShell -cmd "Start-Process cmd -Verb RunAs"')

            # 네 클릭
            # f_png=rf"{PROJECT_D}\pkg_png\run cmd exe.png"
            # click_center_of_img_recognized_by_mouse_left(img_abspath=f_png)

            # 루프 종료
            break
    except:
        traceback.print_exc(file=sys.stdout)


def copy_and_paste_with_keeping_clipboard(prompt, wsl_mode=False):
    import inspect

    from pkg_py.pk_colorful_cli_util import pk_print
    # copy & paste 기능이 끝났을 때 기존의 클립보드를 유지
    func_n = inspect.currentframe().f_code.co_name

    # paste for backup
    txt_bkup = get_str_from_clipboard()
    txt_bkup_list = txt_bkup.split("\n")
    print_iterable_as_vertical(item_iterable=txt_bkup_list, item_iterable_n="txt_bkup_list")

    # copy
    pk_copy(working_str=prompt)
    pk_print(working_str=rf'''prompt={prompt}  {'%%%FOO%%%' if LTA else ''}''')

    # paste
    if wsl_mode == True:
        pk_press("ctrl", "c")
        pk_press("ctrl", "shift", "v")
    else:
        pk_press("ctrl", "v")

    # copy for restore
    pk_copy(working_str=txt_bkup)


def get_count_args(func):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    return func.__code__.co_argcount


def get_list_replaced_from_list_that_have_special_characters(target: [str], replacement: str):  # from [str] to [str] # 문제있어보임.
    import re

    return [re.sub(pattern=r'[^a-zA-Z0-9가-힣\s]', repl='', string=string) for string in target]


def get_str_replaced_special_characters(target: str, replacement: str):  # str to str
    import re

    target_replaced = re.sub(pattern=r'[^a-zA-Z0-9가-힣\s]', repl=replacement, string=target)  # 정규표현식을 사용하여 특수문자(알파벳, 숫자, 한글, 공백을 제외한 모든 문자) remove
    return target_replaced


def get_all_pid_and_process_name():
    import inspect
    import win32gui  # pywin32
    import win32process
    func_n = inspect.currentframe().f_code.co_name
    """모든 프로세스명 돌려주는 함수"""
    process_info = ""

    def enum_windows_callback(hwnd, _):
        import psutil
        # todo : ref : func_n 출력 하지 말자
        # func_n=inspect.currentframe().f_code.co_name
        nonlocal process_info
        if win32gui.IsWindowVisible(hwnd):
            _, pid = win32process.GetWindowThreadProcessId(hwnd)
            try:
                process = psutil.Process(pid)
                process_name = process.name()
                process_info += f"창 핸들: {hwnd}, pid: {pid}, process_name: {process_name}\n"
            except psutil.NoSuchProcess:
                pass

    win32gui.EnumWindows(enum_windows_callback, None)
    return process_info


def get_pid_by_process_name_legacy(process_name: str):
    import inspect
    from pkg_py.pk_interface_graphic_user import print_as_gui
    func_n = inspect.currentframe().f_code.co_name
    # Q.how to activate certain program window at python?
    pids: str = get_all_pid_and_process_name()
    # debug_as_gui(f"pids:\n\n{pids}")
    pids: list[str] = [i for i in pids.split("\n") if is_pattern_in_prompt(prompt=i, pattern=process_name)]  # 프로세스명이 target_process_name 인 경우만 추출
    pids: str = pids[0].split(",")[1].replace("pid:", "").strip()  # strip() 은 특정 문자를 remove를 위해서 만들어짐. 단어를 remove하기 위해서는 replace() 가 더 적절하다고 chatGPT 는 말한다.
    target_pid = int(pids)  # 추출된 target_process_name 의 pid
    print_as_gui(f"target_process_name 프로세스 정보\n\n{target_pid}")
    return target_pid


def get_process_name_by_pid(pid):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    try:
        data = cmd_to_os(cmd=f'tasklist | findstr "{pid}"')
        return data[0].split(" ")[0]
    except:
        return 0


#
# def get_pids(process_img_n: str):
#     func_n = inspect.currentframe().f_code.co_name
#     pk_print(str_working=rf'''{pk_core_constants.UNDERLINE}{func_n}()  {'%%%FOO%%%' if LTA else ''}''')
#     while 1:
#         cmd = f"tasklist | findstr {process_img_n}"
#         pids = cmd_to_os(cmd=cmd)
#         # debug_as_gui(f"pids:\n\n{pids}")
#         cnts: [int] = []
#         for i in pids:
#             cnts.append(i.count(" "))  # str 내의 특정문자의 개수를 cnts에 저장
#         try:
#             max_cnt = max(cnts)
#         except ValueError:
#             pk_print(f'''"f"{process_img_n}에 대한 현재 exec 중인 pid 가 없는 것 같습니다""''')
#             break
#         for i in range(0, max_cnt):  # max(cnts):  pids 요소별 가장 " " 가 많이 든 요소의 개수
#             pids: [str] = [i.replace("  ", " ") for i in pids]  # 공백 remove
#
#         pids_ = []
#         for i in pids:
#             if i.strip() != "\"":
#                 if i.strip() != "":
#                     # pids_.append(i.split(" "))  # 리스트 요소 내 "" 인 경우 remove, \" 인 경우 remove
#                     pids_.append(list(map(str, i.split(" "))))  # 리스트 요소 내 "" 인 경우 remove, \" 인 경우 remove
#         pids = pids_
#
#         pid_and_size = {}
#         for i in pids:
#             pid_and_size[i[1]] = i[4]  # pid 와 size 를 튜플로 나눠 담았는데 이부분 생략하고 처음부터 남아 담아도 되었을 것 같은데
#
#         pids = []
#         sizes = []
#         for pid, size in pid_and_size.items():
#             pids.append(pid)
#             sizes.append(size)
#
#         # for pid, size in pid_and_size.items():  # 프로세스명이 중복일 때 size 가 큰 프로세스의 pid를 리턴
#         #     if size == max(sizes):
#         #         # pk_print(f"pid : {pid}", print_color='blue)
#         #         return int(pid)
#
#         return pids


def get_pids(process_img_n=None, pid=None):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name

    if process_img_n is not None and pid is not None:
        pk_print(rf"{func_n}() 동작 조건 불충족")
        return

    if process_img_n != None:
        cmd = f"tasklist | findstr {process_img_n}"
        std_list = cmd_to_os(cmd=cmd)
        pids = get_list_leaved_element_pattern(items=std_list, pattern=r'^\S+\s+(\d+)\s+[A-Za-z]')
        return pids
    elif pid != None:
        cmd = f'taskkill /f /pid {pid}"'
        std_list = cmd_to_os(cmd=cmd)
        pids = get_list_leaved_element_pattern(items=std_list, pattern=r'^\S+\s+(\d+)\s+[A-Za-z]')
        return pids
    else:
        cmd = f'taskkill'
        std_list = cmd_to_os(cmd=cmd)
        pids = std_list
        return pids


def get_max_pid(process_img_n: str):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    pids = get_pids(process_img_n=process_img_n)

    pk_print(f'''pids="{pids}"  {'%%%FOO%%%' if LTA else ''}''')

    return max(pids)


def chrome_remote_desktop(hostname):
    import inspect
    from pkg_py.pk_core_constants import D_PKG_TXT
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PROJECT
    func_n = inspect.currentframe().f_code.co_name
    f_func_n_txt = rf'{D_PROJECT}\pkg_txt\{func_n}.txt'

    # 페이지 열기
    # url="https://remotedesktop.google.com/access/session/7dc038af-5992-1938-470a-8f85923ab286"
    url = 'https://remotedesktop.google.com/access'
    cmd_to_os(cmd=f'explorer "{url}"')
    pk_print(working_str=rf'''url="{url}"  {'%%%FOO%%%' if LTA else ''}''')

    # 창 앞으로 이동
    ensure_window_to_front(window_title_seg="Chrome")

    # chrome 창 탭 중 해당 url로 이동
    # move_chrome_tab_by_url(url_to_move=url)

    # 클릭
    click_string(string=hostname)

    # PIN 입력
    token_chrome_remote_pin_encoded = get_token_from_f_txt(f_token=rf'{D_PKG_TXT}\token_chrome_remote_pin.txt', initial_str="")
    token_chrome_remote_pin = decode_via_pk_system(token_chrome_remote_pin_encoded)
    write(token_chrome_remote_pin, milliseconds=5000)
    pk_press("enter")


def translate_eng_to_kor_via_googletrans(text: str):  # 수정할것 update 되었다는데 googletrans 업데이트 해보자
    if not is_internet_connected():
        raise
    # translater=Translator()
    # text_translated=translater.translate([text_eng.split(".")], dest='ko')
    # for translation in text_translated:
    #     print(translation.origin, ' ->> ', translation.text)
    # debug_as_gui(context=text_translated, is_app_instance_mode=True)

    # naver papago api 서비스는 2024 년 종료가 된다...
    # translator=Translator(service_urls=['translate.google.com', 'translate.google.co.kr'],user_agent='Mozilla/5.0 (Windows NT 10.0;  x64; Win64)', time_limit=random.randint(0, 99) / 10)
    # tmp=translator.translate(text, src="ko", dest="en")
    # print(rf'tmp : {tmp}')
    # print(rf'type(tmp) : {type(tmp)}')
    # print(rf'len(tmp) : {len(tmp)}')
    # pk_system_ipdb.set_trace()

    # 한수훈 씨가 만든 모듈 같다. 무료이다. 단, 안정성 보장은 안되며, google 로 부터 ip가 차단이 될 수 있다.
    # 단일 텍스트의 최대 글자수 제한은 15k입니다. 이거 로직으로 제한 하도록.
    # 약간 시간적인 트릭도 넣을 것
    # <Translated src=ko dest=en text=Good evening. pronunciation=Good evening.>
    # translator.translate('안녕하세요.', dest='ja')
    # <Translated src=ko dest=ja text=こんにちは。 pronunciation=Kon'nichiwa.>
    # translator.translate('veritas lux mea', src='la')
    # <Translated src=la dest=en text=The truth is my light pronunciation=The truth is my light>
    # 2023 12 31 01 11 현재시각기준 안된다

    # translator=Translator()
    # translator.detect('이 문장은 한글로 쓰여졌습니다.')
    # # <Detected lang=ko confidence=0.27041003>
    # translator.detect('この文章は日本語で書かれました。')
    # # <Detected lang=ja confidence=0.64889508>
    # translator.detect('This sentence is written in English.')
    # # <Detected lang=en confidence=0.22348526>
    # translator.detect('Tiu frazo estas skribita en Esperanto.')
    # # <Detected lang=eo confidence=0.10538048>


# def translate_kor_to_eng_foo(request: str):
#     func_n = inspect.currentframe().f_code.co_name
#     translator = Translator()
#     text_translated = translator.translate(str(request), src='ko', dest='en')
#     print_as_gui(ment=text_translated)


def keyDown(key: str):
    import inspect
    import pyautogui
    func_n = inspect.currentframe().f_code.co_name
    pyautogui.keyDown(key)


def keyUp(key: str):
    import inspect
    import pyautogui
    func_n = inspect.currentframe().f_code.co_name
    pyautogui.keyUp(key)


# def get_font_name_for_mataplot(font_abspath):
#     func_n=inspect.currentframe().f_code.co_name
#
#     # mataplot 폰트캐시 삭제
#     cache_dir=matplotlib.get_cachedir()
#     for file in os.listdir(cache_dir):
#         if file.endswith('.json'):
#             os.remove(os.path.join(cache_dir, file))
#
#     # local font 를 mataplot 폰트 위치로 복사
#     pnx_new=rf"{os.path.dirname(matplotlib.matplotlib_fname())}\fonts\ttf\{os.path.basename(font_abspath)}"
#     if not os.path.exists(pnx_new):
#         xcopy_with_overwrite(pnx_todo=font_abspath, future_pnx_todo=pnx_new)
#     font_name=mataplotlig_fontmanager.FontProperties(fname=pnx_new).get_name()
#     return font_name


def get_weekday_as_english():
    from datetime import datetime
    now = datetime.now()
    weekdays_korean = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
    return weekdays_korean[now.weekday()]


def get_comprehensive_weather_information_from_web():
    import inspect
    import re
    import threading
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_interface_graphic_user import GuiUtil

    if not is_internet_connected():
        raise
    browser_debug_mode = False
    try:
        while 1:
            title = ""
            ment_about_naver_weather = ''
            results_about_naver_weather = ''
            results_about_nationwide_ultrafine_dust = ''
            ment_about_geo = ''
            results_about_geo = ''
            ment_about_pm_ranking = ''
            results_about_pm_ranking = ''

            async def crawl_pm_ranking():
                func_n = inspect.currentframe().f_code.co_name
                driver = None
                try:
                    driver = get_driver_selenium(browser_debug_mode=browser_debug_mode)
                    ment = '미세먼지랭킹 웹사이트 크롤링 결과'
                    global ment_about_pm_ranking
                    ment_about_pm_ranking = ment
                    target_url = f'https://www.dustrank.com/air/air_dong_detail.php?addcode=41173103'
                    pk_print(rf'''target_url="{target_url}"  {'%%%FOO%%%' if LTA else ''}''')
                    driver.get(target_url)
                    page_src = driver.page_source
                    from bs4 import BeautifulSoup
                    soup = BeautifulSoup(page_src, "lxml")
                    results = soup.find_all("table", class_="datatable")  # <table class="datatable">foo!</div>
                    soup = BeautifulSoup(str(results), "lxml")
                    results = soup.find_all("table")[-1]
                    soup = BeautifulSoup(str(results), "lxml")
                    results = soup.find_all("table")[-1].text
                    results = results.split("\n")  # 리스트
                    results = [x for x in results if x.strip()]
                    results = [x for x in results if x.strip(",")]
                    head_1 = results[1]
                    head_2 = results[2]
                    pattern = r'(\d{2}-\d{2}-\d{2} \d{2}:\d{2})([가-힣]+\(\d+\))([가-힣]+\(\d+\))'  # 정규식을 () 로 부분 부분 묶으면 tuple 형태로 수집할 수 있다.
                    body = re.findall(pattern, results[3])
                    body = list(body)  # tuple to list
                    body = [list(item) for item in body]  # LIST 내 ITEM 이 TUPLE 일 때 ITEM 을 LIST 로 변환 #의도대로 잘 변했으~

                    # 리스트 요소를 3개 단위로 개행하여 str 에 저장
                    body_ = ""
                    for i in range(0, len(body), 1):
                        body_ = body_ + body[i][0] + body[i][1] + body[i][2] + "\n"
                    body = body_
                    # body="\n".join(body) # list to str
                    results = f"{head_1}\t{head_2}\n{body}"

                    global results_about_pm_ranking
                    results_about_pm_ranking = results
                    pk_print(working_str=rf'''results_about_pm_ranking="{results_about_pm_ranking}"  {'%%%FOO%%%' if LTA else ''}''')
                except:
                    pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
                    # driver.close()
                    driver.quit()

            async def crawl_nationwide_ultrafine_dust():
                func_n = inspect.currentframe().f_code.co_name
                driver = get_driver_selenium(browser_debug_mode=browser_debug_mode)

                # # '전국초미세먼지'(bs4 way)
                ment = '전국초미세먼지  크롤링 결과'
                global title
                title = ment
                target_url = 'https://search.naver.com/search.naver?where=nexearch&sm=tab_etc&qvt=0&query=전국초미세먼지'
                pk_print(target_url, print_color='blue')
                driver.get(target_url)
                page_src = driver.page_source
                from bs4 import BeautifulSoup
                soup = BeautifulSoup(page_src, "lxml")
                results: any
                # results=soup.find_all("body")
                from bs4 import ResultSet
                results: ResultSet = soup.find_all("div", class_="detail_box")
                results: str = results[0].text
                results: str = results.replace("지역별 초미세먼지 정보", "")
                results: str = results.replace("관측지점 현재 오전예보 오후예보", "")
                results: str = results.replace("", "")
                results___: [str] = results.split(" ")
                results___: [str] = [x for x in results___ if x.strip(" ") and x.strip("") and x.strip("\"") and x.strip("\'") and x.strip("\'\'")]  # 불필요 리스트 요소 remove ( "" , "\"", " " ...)

                # 리스트 요소를 4개 단위로 개행하여 str 에 저장
                results_: str = ""
                for i in range(0, len(results___), 4):
                    if i == len(results___):
                        pass
                    results_ = f"{results_}\t{results___[i]}\t{results___[i + 1]}\t{results___[i + 2]}\t{results___[i + 3]}\n"
                results___ = results_
                global results_about_nationwide_ultrafine_dust
                results_about_nationwide_ultrafine_dust = results___
                pk_print(working_str=rf'''results_about_nationwide_ultrafine_dust="{results_about_nationwide_ultrafine_dust}"  {'%%%FOO%%%' if LTA else ''}''')

            async def crawl_naver_weather():
                func_n = inspect.currentframe().f_code.co_name
                driver = get_driver_selenium(browser_debug_mode=browser_debug_mode)
                # '동안구 관양동 날씨 정보'(bs4 way)
                ment = '네이버 동안구 관양동 날씨 크롤링 결과'

                global ment_about_naver_weather
                ment_about_naver_weather = ment
                target_url = 'https://search.naver.com/search.naver?where=nexearch&sm=top_hty&fbm=1&ie=utf8&query=동안구+관양동+날씨'
                pk_print(target_url, print_color='blue')
                driver.get(target_url)
                page_src = driver.page_source
                from bs4 import BeautifulSoup
                soup = BeautifulSoup(page_src, "lxml")
                from bs4 import ResultSet
                results: ResultSet = soup.find_all("div", class_="status_wrap")
                results: str = results[0].text
                # 리스트 요소 변경
                results: str = results.replace("오늘의 날씨", "오늘의날씨")
                results: str = results.replace(" 낮아요", "낮아요")
                results: str = results.replace(" 높아요", "높아요")
                results: str = results.replace(" 체감", "체감온도")
                results_refactored = results.split(" ")
                results_refactored: [str] = [x for x in results_refactored if x.strip(" ") and x.strip("") and x.strip("\"") and x.strip("\'") and x.strip("\'\'")]  # 불필요 리스트 요소 remove ( "" , "\"", " " ...)
                results_refactored: [str] = [x for x in results_refactored if x.strip("현재")]  # 리스트 요소 "오늘의"
                # 리스트 내 특정문자와 동일한 요소의 바로 뒷 요소를 가져와 딕셔너리에 저장 # 데이터의 key, value 형태가 존재하면서 순번이 key 다음 value 형태로 잘 나오는 경우 사용.
                keys_predicted = ['온도', '체감온도', '습도', '서풍', '동풍', '남풍', '북풍', '북서풍', '미세먼지', '초미세먼지', '자외선', '일출', '오늘의날씨']
                results_: dict = {}
                for i in range(len(results_refactored) - 1):
                    for key_predicted in keys_predicted:
                        if results_refactored[i] == key_predicted:
                            key = results_refactored[i]
                            value = results_refactored[i + 1]
                            results_[key] = value
                results_refactored = results_

                # results: [str]=str(results_)  # dict to str (개행을 시키지 않은)

                results: str = "\n".join([f"{key}: {value}" for key, value in results_refactored.items()])  # dict to str (개행을 시킨)

                global results_about_naver_weather
                results_about_naver_weather = results
                pk_print(working_str=rf'''results_about_naver_weather="{results_about_naver_weather}"  {'%%%FOO%%%' if LTA else ''}''')

            async def crawl_geo_info():
                func_n = inspect.currentframe().f_code.co_name
                # '지역 정보'(bs4 way)
                driver = get_driver_selenium(browser_debug_mode=browser_debug_mode)
                ment = '지역정보 크롤링 결과'
                global ment_about_geo
                ment_about_geo = ment
                # target_url='https://map.naver.com/p'
                target_url = 'https://www.google.com/search?q=현재위치'
                pk_print(target_url, print_color='blue')
                driver.get(target_url)
                page_src = driver.page_source
                from bs4 import BeautifulSoup
                soup = BeautifulSoup(page_src, "lxml")
                results: any
                # results=soup.find_all("body")
                from bs4 import ResultSet
                results: ResultSet = soup.find_all("span", class_="BBwThe")  # 지역정보 한글주소
                # results: ResultSet=soup.find_all("span", class_="fMYBhe") # 지역정보 영어주소
                results: str = results[0].text

                global results_about_geo
                results_about_geo = results
                pk_print(working_str=rf'''results_about_geo="{results_about_geo}"  {'%%%FOO%%%' if LTA else ''}''')

            def run_async_loop1():
                import asyncio
                func_n = inspect.currentframe().f_code.co_name
                try:
                    func_n = inspect.currentframe().f_code.co_name
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    loop.run_until_complete(crawl_pm_ranking())
                except:
                    pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')

            def run_async_loop2():
                import asyncio
                func_n = inspect.currentframe().f_code.co_name
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                loop.run_until_complete(crawl_nationwide_ultrafine_dust())

            def run_async_loop3():
                import asyncio
                func_n = inspect.currentframe().f_code.co_name
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                loop.run_until_complete(crawl_naver_weather())

            def run_async_loop4():
                import asyncio
                func_n = inspect.currentframe().f_code.co_name
                # pk_print(f"def {inspect.currentframe().f_code.co_name}() is running...")
                func_n = inspect.currentframe().f_code.co_name
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                loop.run_until_complete(crawl_geo_info())

            thread1 = threading.Thread(target=run_async_loop1)
            thread1.start()

            thread2 = threading.Thread(target=run_async_loop2)
            thread2.start()

            thread3 = threading.Thread(target=run_async_loop3)
            thread3.start()

            thread4 = threading.Thread(target=run_async_loop4)
            thread4.start()

            # 모든 쓰레드 끝날때 까지 대기
            thread1.join()
            thread2.join()
            thread3.join()
            thread4.join()

            pk_speak_v2(working_str='날씨에 대한 웹크롤링 및 데이터 분석이 성공되었습니다', comma_delay=0.98)
            # 함수가 break 로 끝이 나면 창들이 창을 닫아야 dialog 들이 사라지도록 dialog 를 global 처리를 해두었음.
            global dialog4
            global dialog3
            global dialog2
            global dialog1
            dialog3 = GuiUtil.CustomQdialog(title=f"{ment_about_naver_weather}", prompt=f"{results_about_naver_weather}")
            dialog2 = GuiUtil.CustomQdialog(title=f"{title}", prompt=f"{results_about_nationwide_ultrafine_dust}")
            dialog1 = GuiUtil.CustomQdialog(title=f"{ment_about_geo}", prompt=f"{results_about_geo}")
            dialog4 = GuiUtil.CustomQdialog(title=f"{ment_about_pm_ranking}", prompt=f"{results_about_pm_ranking}")
            dialog1.show()
            dialog2.show()
            dialog3.show()
            dialog4.show()
            break
    except:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')


def back_up_pnx_list_biggest():
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import BIGGEST_PNXS
    func_n = inspect.currentframe().f_code.co_name
    pk_print(f"biggest_pnxs에 대한 백업을 시도합니다")
    for biggest_target in BIGGEST_PNXS:
        compress_pnx_via_bz(f'{biggest_target}')


def back_up_pnx_list_smallest():
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import SMALLEST_PNXS
    func_n = inspect.currentframe().f_code.co_name
    pk_print(f"smallest_pnxs에 대한 백업을 시도합니다")
    for target in SMALLEST_PNXS:
        compress_pnx_via_bz(f'{target}')


def classify_pnxs_between_smallest_pnxs_biggest_pnxs():
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_HOME, BIGGEST_PNXS, SMALLEST_PNXS
    func_n = inspect.currentframe().f_code.co_name
    pk_print(f'백업할 f들의 크기를 분류합니다.')
    pnxs = [
        rf"{D_HOME}\Desktop\services\helper-from-youtube-url-to-webm",
        rf"{D_HOME}\Desktop\services",
    ]
    pk_print(f'biggest_pnxs(300 메가 초과), smallest_pnxs(300 메가 이하) 분류 시도')
    for target in pnxs:
        target_size_megabite = get_target_megabite(target.strip())
        print(target_size_megabite)
        if target_size_megabite <= 300:
            SMALLEST_PNXS.append(target.strip())

        elif 300 < target_size_megabite:
            BIGGEST_PNXS.append(target.strip())
        else:
            pk_print(f'{target.strip()}pass', print_color='blue')

    pk_print(f'smallest_target 출력')
    # pnxs 에서 biggest_pnxs 과 일치하는 것을 소거 시도
    smallest_pnxs = [i for i in pnxs if i not in BIGGEST_PNXS]
    for target in SMALLEST_PNXS:
        print(target)

    pk_print(f'biggest_target 출력')
    for target in BIGGEST_PNXS:
        print(target)
    pass


def gather_pnxs_special():
    from pkg_py.pk_core_constants import D_DOWNLOADS

    import inspect
    import os
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PROJECT
    func_n = inspect.currentframe().f_code.co_name
    d_func_n = rf"{D_PROJECT}\{func_n}"  # func_n_d 에 저장
    ensure_pnx_made(pnx=d_func_n, mode="d")

    open_pnx_by_ext(pnx=d_func_n)

    if not is_window_opened(window_title_seg=func_n):
        open_pnx_by_ext(pnx=d_func_n)

    starting_d = get_d_working()

    dst = d_func_n
    if not os.path.exists(dst):
        return
    services = os.path.dirname(dst)
    pk_chdir(services)
    storages = []
    cmd = rf'dir /b /s "{D_DOWNLOADS}"'
    lines = cmd_to_os_like_person_as_admin(cmd)
    for line in lines:
        if line.strip() != "":
            storages.append(line.strip())

    pk_print(rf'archive_py 는 storage 목록 에서 제외')
    withouts = ['archive_py']
    for storage in storages:
        for without in withouts:
            if is_pattern_in_prompt(prompt=storage, pattern=without, with_case_ignored=False):
                storages.remove(storage)
    for storage in storages:
        print(storage)

    pk_print(rf'이동할 storage 목록 중간점검 출력 시도')
    for storage in storages:
        print(os.path.abspath(storage))

    if not storages:
        pk_print(rf'이동할 storage 목록 이 없어 storage 이동을 할 수 없습니다')
    else:
        pk_print(rf'이동할 storage 목록 출력 시도')
        for storage in storages:
            print(os.path.abspath(storage))
        pk_print(rf'목적지 생성 시도')
        if not os.path.exists(dst):
            os.makedirs(dst)
        for storage in storages:
            # print(src)
            try:
                pk_print(rf'storage 이동 시도')
                move_pnx(storage, dst)
            except FileNotFoundError:
                pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')

            except Exception as e:
                pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')

    pk_chdir(starting_d)


def kill_process_via_hard_coded():
    nxs = [
        # "python.exe", # 프로그램 스스로를 종료시켜는 방법
        "alsong.exe",
        "cortana.exe",
        "mysqld.exe",
        "KakaoTalk.exe",
        "OfficeClickToRun.exe",
        "TEWebP.exe",
        "TEWeb64.exe",
        "TEWebP64.exe",
        "AnySign4PC.exe",
    ]
    for nx in nxs:
        kill_process_via_wmic(process_img_n=nx)


def run_up_and_down_game():
    import inspect
    import random
    from pkg_py.pk_interface_graphic_user import should_i_do
    func_n = inspect.currentframe().f_code.co_name
    correct_answer: int = random.randint(1, 100)
    left_oportunity: int = 10
    ment = f"<UP AND DOWN GAME>\n\nFIND CORRECT NUMBER"
    pk_speak_v2(working_str=ment, comma_delay=1.0)

    txt_clicked, function, txt_written = should_i_do(
        prompt=ment,
        btn_list=["START", "EXIT"],
        function=None,
        auto_click_negative_btn_after_seconds=30,
        title=f"{func_n}()",
        input_box_mode=False,
    )
    if txt_clicked != "START":
        return

    user_input = None
    is_game_strated = False
    btn_txt_clicked = txt_clicked

    if btn_txt_clicked == "START":
        ment = f"START IS PRESSED, LETS START GAME"
        pk_speak_v2(working_str=ment, comma_delay=0.98, thread_join_mode=True)
        while left_oportunity >= 0:
            if left_oportunity == 0:
                ment = f"LEFT CHANCE IS {left_oportunity} \nTAKE YOUR NEXT CHANCE."
                pk_speak_v2(working_str=ment, comma_delay=0.98)

                txt_clicked, function, txt_written = should_i_do(
                    prompt=ment,
                    btn_list=["EXIT"],
                    function=None,
                    auto_click_negative_btn_after_seconds=None,
                    title=f"{func_n}()",
                    #                    input_box_mode=True,
                )
                if txt_clicked == "EXIT":
                    return

                break
            elif is_game_strated == False or user_input is None:

                ment = f"TYPE NUMBER BETWEEN 1 TO 100"
                if user_input is None:
                    ment = rf"{ment} AGAIN"
                pk_speak_v2(working_str=ment, comma_delay=0.98)
                txt_clicked, function, txt_written = should_i_do(
                    prompt=ment,
                    btn_list=["SUBMIT", "EXIT"],
                    function=None,
                    auto_click_negative_btn_after_seconds=None,
                    title=f"{func_n}()",
                    input_box_mode=True,
                )
                if txt_clicked == "EXIT":
                    return

                user_input = is_user_input_required(txt_written)
                if user_input is not None:
                    left_oportunity = left_oportunity - 1
                is_game_strated = True
            elif user_input == correct_answer:
                ment = f"CONGRATULATIONS\n\nYOUR NUMBER IS {correct_answer}\nTHIS IS ANSWER\n\nSEE YOU AGAIN"
                pk_speak_v2(working_str=ment, comma_delay=0.98)

                txt_clicked, function, txt_written = should_i_do(
                    prompt=ment,
                    btn_list=["SUBMIT", "EXIT"],
                    function=None,
                    auto_click_negative_btn_after_seconds=None,
                    title=f"{func_n}()",
                    input_box_mode=True,
                )
                if txt_clicked == "EXIT":
                    return

            elif correct_answer < user_input:
                ment = f"YOUR NUMBER IS {user_input}\n\nYOU NEED DOWN\n\nYOUR LEFT CHANCE IS {left_oportunity}"
                pk_speak_v2(working_str=ment, comma_delay=0.98)

                txt_clicked, function, txt_written = should_i_do(
                    prompt=ment,
                    btn_list=["SUBMIT", "EXIT"],
                    function=None,
                    auto_click_negative_btn_after_seconds=None,
                    title=f"{func_n}()",
                    input_box_mode=True,
                )
                if txt_clicked == "EXIT":
                    return

                user_input = is_user_input_required(txt_written)
                if user_input is not None:
                    left_oportunity = left_oportunity - 1
            elif correct_answer > user_input:
                ment = f"YOUR NUMBER IS {user_input}\n\nYOU NEED UP\n\nYOUR LEFT CHANCE IS {left_oportunity}"
                pk_speak_v2(working_str=ment, comma_delay=0.98)

                txt_clicked, function, txt_written = should_i_do(
                    prompt=ment,
                    btn_list=["SUBMIT", "EXIT"],
                    function=None,
                    auto_click_negative_btn_after_seconds=None,
                    title=f"{func_n}()",
                    input_box_mode=True,
                )
                if txt_clicked == "EXIT":
                    return

                user_input = is_user_input_required(txt_written)
                if user_input is not None:
                    left_oportunity = left_oportunity - 1
    else:
        return


def get_state_from_f_pk_config_toml(pk_state_address):
    from pkg_py.pk_colorful_cli_util import pk_print
    if LTA:
        pk_print(f'''pk_state_address={pk_state_address} {'%%%FOO%%%' if LTA else ''}''')
    pk_toml_address_list = pk_state_address.split('/')
    level_1_dict_n = ""
    level_2_dict_n = ""
    level_3_dict_n = ""
    try:
        level_1_dict_n = pk_toml_address_list[0]
        level_2_dict_n = pk_toml_address_list[1]
        level_3_dict_n = pk_toml_address_list[2]
    except:
        pk_print(f'''{len(pk_toml_address_list)} is idx limit. {'%%%FOO%%%' if LTA else ''}''')

    level_1_dict = {}
    level_2_dict = {}
    level_3_dict = {}
    # todo
    try:
        level_1_dict = toml.load(F_PK_CONFIG_TOML)[level_1_dict_n]
    except KeyError:
        pk_print(f'''level_1_dict={level_1_dict}에 해당하는 key 가 없습니다. {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        return None
    try:
        level_2_dict = level_1_dict[level_2_dict_n]
    except KeyError:
        return None
    if len(pk_toml_address_list) == 2:
        level_2_dict = level_1_dict[level_2_dict_n]
        return level_2_dict
    try:
        level_3_dict = level_2_dict[level_3_dict_n]
    except KeyError:
        return None
    if len(pk_toml_address_list) == 3:
        level_3_dict = level_2_dict[level_3_dict_n]
        return level_3_dict


def assist_to_do_pk_schedule():
    from pkg_py.pk_colorful_cli_util import pk_print
    from colorama import init as pk_colorama_init

    pk_colorama_init(autoreset=True)

    loop_cnt = 0
    while 1:
        ment = f'pk scheduler loop {loop_cnt} is started'
        pk_print(f"{ment}")
        if loop_cnt == 0:
            # speak_ment_experimental(ment=ment, comma_delay=0.98, thread_join_mode=True)
            guide_to_check_routines()

        # 특정시간에 OS 부팅
        # should_i_do(ment="백업할 타겟들을 크기에 따라 분류를 해둘까요?", function=classify_pnxs_between_smallest_pnxs_biggest_pnxs, auto_click_positive_btn_after_seconds=10)
        # should_i_do(ment="백업할 타겟들을 크기에 따라 분류를 해둘까요?", function=classify_pnxs_between_smallest_pnxs_biggest_pnxs, auto_click_negative_btn_after_seconds=5)

        # mkr_특정시간에 한번
        # if is_same_time(time1=get_time_as_('%Y_%m_%d_%H_%M_%S_%f'), time2=datetime(year=2024, month=10, day=31, hour=22, minute=27 , second=0)):
        #     print_as_gui(ment="약속된 시간이 되었습니다.")

        # yyyy = get_time_as_('%Y')
        # MM = get_time_as_('%m')
        # dd = get_time_as_('%d')
        # HH = get_time_as_('%H')
        # mm = get_time_as_('%M')
        # ss = get_time_as_('%S')
        yyyy = '2024'
        daily_greeting = None
        if is_month(mm=3) and is_day(dd=22):
            daily_greeting = get_state_from_f_pk_config_toml(pk_state_address=f"state_pk_schedule/{yyyy}_{get_time_as_('%m')}_{get_time_as_('%d')}_daily_greeting")
            if daily_greeting:
                daily_greeting = 0
                set_state_from_f_pk_config_toml(pk_state_address=f"state_pk_schedule/{yyyy}_{get_time_as_('%m')}_{get_time_as_('%d')}_daily_greeting", pk_state_value=daily_greeting)
            if daily_greeting == 0:
                daily_greeting = 1
                set_state_from_f_pk_config_toml(pk_state_address=f"state_pk_schedule/{yyyy}_{get_time_as_('%m')}_{get_time_as_('%d')}_daily_greeting", pk_state_value=daily_greeting)
        if daily_greeting:
            ment = f'{yyyy} happy today! good lock for you!'
            pk_print(f'''{ment} {'%%%FOO%%%' if LTA else ''}''', print_color='green')

        # if is_midnight():  # 자정이면 초기화
        #     state_toml = toml.load(F_PK_CONFIG_TOML)["state_pk_schedule"]
        #     state_toml[f'{yyyy}_{get_time_as_('%m')}_{get_time_as_('%d')}_greeting'] = 0
        #     with open(F_PK_CONFIG_TOML, "w") as f:
        #         toml.dump(state_toml, f)

        if is_newyear():
            state_toml = toml.load(F_PK_CONFIG_TOML)["state_pk_schedule"]
            state_yearly_greeting = state_toml[f'{yyyy}_{get_time_as_('%m')}_{get_time_as_('%d')}_newyear_greeting']
            if not state_yearly_greeting:
                state_toml[f'{yyyy}_{get_time_as_('%m')}_{get_time_as_('%d')}_newyear_greeting'] = 0
                state_yearly_greeting = 0
            if state_yearly_greeting == 0:
                state_toml[f'{yyyy}_{get_time_as_('%m')}_{get_time_as_('%d')}_newyear_greeting'] = 1
                state_yearly_greeting = 1
            if state_yearly_greeting == 1:
                ment = f'{yyyy} happy new year! good lock for you!'
                pk_print(f'''{ment} {'%%%FOO%%%' if LTA else ''}''', print_color='green')
                pk_speak(working_str=ment)

        if is_christmas():
            state_toml = toml.load(F_PK_CONFIG_TOML)["state_pk_schedule"]
            state_christmas_greeting = state_toml[f'{yyyy}_{get_time_as_('%m')}_{get_time_as_('%d')}_christmas_greeting']
            if not state_christmas_greeting:
                state_christmas_greeting = 0
                state_toml[f'{yyyy}_{get_time_as_('%m')}_{get_time_as_('%d')}_christmas_greeting'] = state_christmas_greeting
                return 0
            if state_christmas_greeting == 0:
                state_christmas_greeting = 1
                state_toml[f'{yyyy}_{get_time_as_('%m')}_{get_time_as_('%d')}_christmas_greeting'] = state_yearly_greeting
                return 1
            if state_yearly_greeting == 1:
                ment = f'{yyyy} happy christmas! good lock for you!'
                pk_print(f'''{ment} {'%%%FOO%%%' if LTA else ''}''', print_color='green')
                pk_speak(working_str=ment)

        # mkr_매시간 한시간에한번
        #     랜덤미션
        #      do_random_schedules()

        # # mkr_스케쥴러_트리거 : 하루에 24번
        # back_up_pnxs_to_deprecated_via_text_file()

        # # mkr_0시에서 24시 사이, # 분단위 스케쥴,
        # if 0 <= int(HH) <= 24 and int(ss) == 0:
        #     monitor_target_edited_and_back_up(pnx_todo=pk_system_ARCHIVE_TOML)  # seconds_performance_test_results : ['11.95sec', '26.78sec', '11.94sec', '3.7sec', '11.72sec']
        #     if int(HH) == 6 and int(mm) == 30:
        #         # speak_ments(f'{int(HH)} 시 {int(mm)}분 루틴을 시작합니다', sleep_after_play=0.65, thread_join_mode=True)  # 쓰레드가 많아지니 speak() 하면서 부정확한 재생이 늘어났다. 쓰레드의 정확한 타이밍 제어가 필요한 것 같다. 급한대로 thread_join_mode 를 만들었다)
        #         # speak_ments(f'아침음악을 준비합니다, 아침음악을 재생할게요', sleep_after_play=0.65, thread_join_mode=True)
        #         pass
        #     if int(HH) == 7 and int(mm) == 30:
        #         # speak_ments(f'{int(HH)} 시 {int(mm)}분 루틴을 시작합니다', sleep_after_play=0.65, thread_join_mode=True)
        #         # speak_ments('지금 나가지 않는다면 지각할 수 있습니다, 더이상 나가는 것을 지체하기 어렵습니다', sleep_after_play=0.65, thread_join_mode=True)
        #         pass
        #
        #     if int(HH) == 8 and int(mm) == 50:
        #         # speak_ments(f'{int(HH)} 시 {int(mm)}분 루틴을 시작합니다', sleep_after_play=0.65, thread_join_mode=True)
        #         # speak_ments('업무시작 10분전입니다, 업무준비를 시작하세요, 업무 전에 세수와 양치는 하셨나요', sleep_after_play=0.65, thread_join_mode=True)
        #         pass
        #
        #     if int(HH) == 9:
        #         # speak_ments(f'{int(mm)}시 정각, 루틴을 시작합니다', sleep_after_play=0.65, thread_join_mode=True)
        #         # speak_ments('근무시간이므로 음악을 종료합니다', sleep_after_play=0.65, thread_join_mode=True)
        #         pass
        #     if int(HH) == 11 and int(mm) == 30:
        #         # # speak_ments('용량이 큰 약속된 타겟들을 백업을 수행 시도합니다', sleep_after_play=0.65, thread_join_mode=True)
        #         # back_up_biggest_pnxs()
        #         # # speak_ments('용량이 작은 약속된 타겟들을 백업을 수행 시도합니다', sleep_after_play=0.65, thread_join_mode=True)
        #         # back_up_smallest_pnxs()
        #         # # speak_ments('흩어져있는 storage 들을 한데 모으는 시도를 합니다', sleep_after_play=0.65, thread_join_mode=True)
        #         # gather_storages()
        #         pass
        #     if int(HH) == 22 and int(mm) == 10:
        #         speak_ment_experimental('씻으실 것을 추천드립니다, 샤워루틴을 수행하실 것을 추천드립니다', comma_delay=0.98, thread_join_mode=True)  # 샤워루틴 확인창 띄우기
        #     if int(HH) == 22 and int(mm) == 30:
        #         speak_ment_experimental('건강을 위해서 지금 씻고 주무실 것을 추천드려요', comma_delay=0.98, thread_join_mode=True)
        #         speak_ment_experimental('건강을 위해서 24시에 최대 절전 모드에 예약이 되었습니다', comma_delay=0.98, thread_join_mode=True)
        #     if int(HH) == 23 and int(mm) == 55:
        #         speak_ment_experimental('5분 뒤 최대 절전 모드로 진입합니다', comma_delay=0.98, thread_join_mode=True)
        #     if int(HH) == 24 and int(mm) == 0:
        #         speak_ment_experimental(f'자정이 되었습니다', comma_delay=0.98, thread_join_mode=True)
        #         speak_ment_experimental('최대 절전 모드에 진입합니다', comma_delay=0.98, thread_join_mode=True)
        #         back_up_target(pnx_todo=SERVICE_D)
        #         enter_power_saving_mode()
        #     if int(HH) == 2 and int(mm) == 0:
        #         speak('새벽 두시입니다', after_delay=0.55)
        #         speak('지금부터 예약된 최대 절전 모드에 진입합니다', after_delay=1)
        #     if int(mm) % 15 == 0:
        #         # speak_ments(f'15분 간격 루틴을 시작합니다', sleep_after_play=0.65, thread_join_mode=True)
        #         # speak_ments(f'랜덤 스케줄을 시작합니다', sleep_after_play=0.65, thread_join_mode=True)
        #         do_random_schedules()
        #         # speak_ments(f'프로젝트 d 싱크를 시작합니다', sleep_after_play=0.65, thread_join_mode=True)
        #     if int(mm) % 30 == 0:
        #         # speak_ments(f'30분 간격 루틴을 시작합니다', sleep_after_play=0.65, thread_join_mode=True)
        #         # speak_ments(f'깃허브로 파이썬 아카이브 프로젝트 백업을 시도합니다', sleep_after_play=0.65, thread_join_mode=True)
        #         # git_push_by_auto()
        #         monitor_target_edited_and_sync(pnx_todo=SERVICE_D)  # seconds_performance_test_results : ['28.46sec', '27.53sec', '2.85sec', '2.9sec', '2.91sec']
        #     if int(mm) % 60 == 0:
        #         # speak_ments(f'1시간 간격 루틴을 시작합니다', sleep_after_play=0.65, thread_join_mode=True)
        #         should_i_do(ment="쓰레기통을 비울까요?", function=empty_recycle_bin, auto_click_negative_btn_after_seconds=10)
        #         should_i_do(ment="오늘 시간정보를 말씀드릴까요?", function=speak_today_time_info, auto_click_negative_btn_after_seconds=10)
        #         monitor_target_edited_and_sync(pnx_todo=SERVICE_D)  # seconds_performance_test_results : ['28.46sec', '27.53sec', '2.85sec', '2.9sec', '2.91sec']

        # mkr_ 23시에서 5시 사이, 30초 마다
        # if (23 <= int(HH) <= 24 or 0 <= int(HH) <= 5) and int(ss) % 30 == 0:
        #     guide_to_sleep() #최대절전모드 가이드

        # yyyy = get_time_as_('%Y')
        # MM = get_time_as_('%m')
        # dd = get_time_as_('%d')
        # HH = get_time_as_('%H')
        # mm = get_time_as_('%M')
        # ss = get_time_as_('%S')

        # update_state_to_sql(SCHECLUER_CFG)
        # pickle 에 상태를 저장
        # checklist = [] 를 pickle 에 저장 # 상태초기화시기 : 프로그램 런타임 시
        # pk_schedule.db # 상태초기화시기 : 프로그램 런타임 시
        # config.toml /pk_schedule / # 상태초기화시기 : 프로그램 런타임 시
        # context # 상태초기화시기 : 프로그램 실행 시
        # checklist = []
        # bring checklist
        # checklist.append(line)
        # print_magenta(rf'''checklist={checklist}''')
        # print_magenta(rf'''len(checklist)={len(checklist)}''')

        # 매월 월에한번
        #     DbTomlUtil.update_db_toml(key=DbTomlUtil.get_db_toml_key(unique_id=unique_id), value=False)

        # 1년에 한번 수행 아이디어
        # random_schedule.json 에서 leaved_max_count를 읽어온다
        # leaved_max_count=10 이면 년에 1씩 깍아서 수행
        # leaved_max_count=0 이면 올해에는 더이상 수행하지 않음
        # leaved_max_count 를 random_schedule_tb.toml 에 저장

        # - 1시간 뒤 시스템 종료 예약 기능
        # - 즉시 시스템 종료 시도 기능
        # - 시간 시현기능 기능(autugui 이용)
        #   ment ='pc 정밀검사를 한번 수행해주세요'
        #   pk_print(ment)
        # - 하드코딩된 스케줄 작업 수행 기능
        # - 미세먼지 웹스크래핑 기능
        # - 초미세먼지 웹스크래핑 기능
        # - 종합날씨 웹스크래핑 기능
        # - 습도 웹스크래핑 기능
        # - 체감온도 웹스크래핑 기능
        # - 현재온도 웹스크래핑 기능
        # - 음악재생 기능
        # - 영상재생 기능

        pk_sleep(milliseconds=200)
        ment = f'pk scheduler loop {loop_cnt} is ended'
        pk_print(f"{ment}")
        loop_cnt = loop_cnt + 1


def set_state_from_f_pk_config_toml(pk_state_address, pk_state_value):
    from pkg_py.pk_colorful_cli_util import pk_print
    pk_toml_address_list = pk_state_address.split('/')
    if LTA:
        pk_print(f'''pk_state_address={pk_state_address} {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''pk_state_value={pk_state_value} {'%%%FOO%%%' if LTA else ''}''')
    level_1_dict_n = ""
    level_2_dict_n = ""
    level_3_dict_n = ""
    try:
        level_1_dict_n = pk_toml_address_list[0]
        level_2_dict_n = pk_toml_address_list[1]
        level_3_dict_n = pk_toml_address_list[2]
    except:
        if LTA:
            pk_print(f'''{len(pk_toml_address_list)} is idx limit. in setter {'%%%FOO%%%' if LTA else ''}''')

    level_1_dict = {}
    level_2_dict = {}
    level_3_dict = {}
    try:
        level_1_dict = toml.load(F_PK_CONFIG_TOML)[level_1_dict_n]
    except KeyError:
        pk_print(f'''level_1_dict={level_1_dict}에 해당하는 key 가 없어 생성합니다. {'%%%FOO%%%' if LTA else ''}''')
        level_1_dict = toml.load(F_PK_CONFIG_TOML)[level_1_dict]
        with open(F_PK_CONFIG_TOML, "w") as f:
            toml.dump(level_1_dict, f)
    try:
        level_2_dict = level_1_dict[level_2_dict_n]
    except KeyError:
        pk_print(f'''level_2_dict_n={level_2_dict_n}에 해당하는 key 가 없어 생성합니다. {'%%%FOO%%%' if LTA else ''}''')
        level_1_dict[level_2_dict_n] = pk_state_value
        with open(F_PK_CONFIG_TOML, "w") as f:
            toml.dump(level_1_dict, f)
    if len(pk_toml_address_list) == 2:
        level_1_dict[level_2_dict_n] = pk_state_value
        with open(F_PK_CONFIG_TOML, "w") as f:
            toml.dump(level_1_dict, f)
    try:
        level_3_dict = level_2_dict[level_3_dict_n]
    except KeyError:
        pk_print(f'''level_3_dict_n={level_3_dict_n}에 해당하는 key 가 없어 생성합니다. {'%%%FOO%%%' if LTA else ''}''')
        level_2_dict[level_3_dict_n] = pk_state_value
        with open(F_PK_CONFIG_TOML, "w") as f:
            toml.dump(level_2_dict, f)
    if len(pk_toml_address_list) == 3:
        level_2_dict[level_3_dict_n] = pk_state_value
        with open(F_PK_CONFIG_TOML, "w") as f:
            toml.dump(level_2_dict, f)


def run_console_blurred():
    import sys
    from pkg_py.pk_interface_graphic_user import GuiUtil
    import pyautogui
    from PySide6.QtWidgets import QApplication
    while 1:
        pyautogui.FAILSAFE = False

        q_application = QApplication(sys.argv)

        # 프로그램 코어진입 with 프로그램exec 동의요청
        # dialog=GuiUtil.CustomDialog(q_application=q_application, q_wiget=GuiUtil.CustomQdialog(ment=f"다음의 프로젝트 d에서 자동화 프로그램이 시작됩니다\n{PROJECT_D}", btns=["exec 동의", "exec 하지 않기"], auto_click_positive_btn_after_seconds=10), is_app_instance_mode=True)
        # if dialog.btn_txt_clicked == "exec 동의":
        #     print(PROJECT_D)
        #     chdir(PROJECT_D)
        #     run_console_blurred_core_as_scheduler(q_application)
        # if dialog.btn_txt_clicked == "exec 하지 않기":
        #     raise

        # 프로그램 코어진입 without 프로그램exec 동의요청
        window = GuiUtil.RpaProgramMainWindow(q_application)
        q_application.exec()

        break


def crawl_html_href(url: str):
    import inspect
    import random
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import UNDERLINE
    from pkg_py.pk_interface_graphic_user import GuiUtil
    pk_print(f"{UNDERLINE}{inspect.currentframe().f_code.co_name}", print_color='blue')
    # 최하단으로 스크롤 이동 처리를 추가로 해야함. 그렇지 않으면 기대하는 모든 영상을 크롤링 할 수 없음..귀찮..지만 처리했다.

    browser_debug_mode = False

    # url 전처리
    url = url.strip()

    # driver 설정
    pk_print(f"get_driver_selenium(browser_debug_mode=True) 수행 중...", print_color='blue')
    driver = get_driver_selenium(browser_debug_mode=browser_debug_mode)

    pk_print(f"driver.get(target_url) 수행 중...", print_color='blue')
    target_url = url
    driver.get(target_url)

    # 자동제어 브라우저 화면 초기 로딩 random.randint(1,n) 초만큼 명시적 대기
    n = 2
    seconds = random.randint(1, n)
    pk_print(f"자동제어 브라우저 화면 초기 로딩 중... {seconds} seconds", print_color='blue')
    driver.implicitly_wait(seconds)  # 처음페이지 로딩이 끝날 때까지 약 random.randint(1,n)초 대기

    # 최하단으로 자동 스크롤, 페이지 최하단에서 더이상 로딩될 dom 객체가 없을 때 까지
    pk_print("스크롤 최하단으로 이동 중...", print_color='blue')
    scroll_cnt = 0
    previous_scroll_h = None
    current_scroll_h = None
    scroll_maxs_monitored = []
    while 1:
        if current_scroll_h is not None and previous_scroll_h is not None:
            if previous_scroll_h == current_scroll_h:
                scroll_maxs_monitored.append(True)
                # break

        # 로딩타이밍 제어가 어려워 추가한 코드. n번 모니터링.
        n = 6  # success
        if len(scroll_maxs_monitored) == n:
            if all(scroll_maxs_monitored) == True:  # [bool] bool list 내 요소가 모두 true 인지 확인
                pk_print(working_str="스크롤 최하단으로 이동되었습니다", print_color='blue')
                break

        # previous_scroll_h 업데이트
        # previous_scroll_h=driver.execute_script("return document.body.scrollHeight")
        previous_scroll_h = driver.execute_script("return document.documentElement.scrollHeight")

        # 가능한만큼 스크롤 최하단으로 이동
        # driver.find_element(By.CSS_SELECTOR, 'body').send_keys(Keys.PAGE_DOWN)  # page_down 을 누르는 방법, success
        # driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")# JavaScript 로 스크롤 최하단으로 이동, 네이버용 코드?
        driver.execute_script("window.scrollTo(0, document.documentElement.scrollHeight);")  # JavaScript 로 스크롤 최하단으로 이동, 유튜브용 코드?
        # sleep(seconds=2)  # 스크롤에 의한 추가적인 dom 객체 로딩 대기, 여러가지 예제를 보니, 일반적으로 2 초 정도 두는 것 같음. 2초 내에 로딩이 되지 않을 때도 있는데.
        pk_sleep(milliseconds=500)  # 스크롤에 의한 추가적인 dom 객체 로딩 대기, success, 지금껏 문제 없었음.

        # previous_scroll_h=driver.execute_script("return document.body.scrollHeight")
        current_scroll_h = driver.execute_script("return document.documentElement.scrollHeight")

        scroll_cnt = scroll_cnt + 1

        pk_print(f'{scroll_cnt}번 째 스크롤 성공 previous_scroll_h : {previous_scroll_h} current_scroll_h : {current_scroll_h}   previous_scroll_h==current_scroll_h : {previous_scroll_h == current_scroll_h}', print_color='blue')

    page_src = driver.page_source
    from bs4 import BeautifulSoup
    soup = BeautifulSoup(page_src, "lxml")
    driver.close()

    # 모든 태그 가져오기
    # tags=soup.find_all()
    # for tag in tags:
    #     print(tag)

    # body 리소스 확인 : success
    # bodys=soup.find_all("body")
    # for body in bodys:
    #     print(f"body:{body}")

    # 이미지 태그 크롤링
    # images=soup.find_all("img")
    # for img in images:
    #     img_url=img.get("src")
    #     pk_print(str_working="Image URL:", img_url)
    #
    # 스크립트 태그 크롤링
    # scripts=soup.find_all("script")
    # for script in scripts:
    #     script_url=script.get("src")
    #     pk_print(str_working="Script URL:", script_url)
    #
    # # 스타일시트 크롤링
    # stylesheets=soup.find_all("link", rel="stylesheet")
    # for stylesheet in stylesheets:
    #     stylesheet_url=stylesheet.get("href")
    #     pk_print(str_working="Stylesheet URL:", stylesheet_url)

    # 특정 태그의 class 가 "어쩌구" 인
    # div_tags=soup.find_all("div", class_="어쩌구")

    # a 태그 크롤링
    # a_tags=soup.find_all("a")
    # results=""
    # for a_tag in a_tags:
    #     hrefs=a_tag.get("href")
    #     if hrefs is not None and hrefs != "":
    #         # pk_print(str_working="href", hrefs)
    #         results=f"{results}{hrefs}\n"

    # 변수에 저장 via selector
    # name=soup.select('a#video-title')
    # video_url=soup.select('a#video-title')
    # view=soup.select('a#video-title')

    # name, video_url 에 저장 via tag_name and id
    name = soup.find_all("a", id="video-title")
    video_url = soup.find_all("a", id="video-title")

    # 유튜브 주소 크롤링 및 진행률 표시 via tqdm, 14 초나 걸리는데. 성능이 필요할때는 여러개의 thread 로 처리해보자.
    a_tags = soup.find_all("a")

    # success
    # debug_as_gui(f"{len(a_tags)}")

    # results를 str으로 처리
    # results=""
    # a_tags_cnt =0
    # with tqdm(total=total_percent,ncols=79 , desc= "웹 크롤링 진행률") as process_bar:
    #     for a_tag in a_tags:
    #         hrefs=a_tag.get("href")
    #         if hrefs is not None and hrefs != "" and "/watch?v=" in hrefs :
    #             if hrefs not in results:
    #                 results=f"{results}{hrefs}\n"
    #                 a_tags_cnt=a_tags_cnt + 1
    #         sleep(seconds=0.06)
    #         process_bar.update(total_percent/len(a_tags))

    # fail
    # if process_bar.total == 90:
    #     speak_ments(ment='웹 크롤링이 90퍼센트 진행되었습니다. 잠시만 기다려주세요', sleep_after_play=0.65)

    # results를 list 으로 처리, list 으로만 처리하고 str 으로 변형하는 처리를 추가했는데 3초나 빨라졌다. 항상 list 로 처리를 하자.
    results = []
    a_tags_cnt = 0
    for a_tag in a_tags:
        hrefs = a_tag.get("href")
        if hrefs is not None and hrefs != "" and "/watch?v=" in hrefs:
            if hrefs not in results:
                results.append(hrefs)
                a_tags_cnt = a_tags_cnt + 1
    results = DataStructureUtil.add_prefix_to_string_list(results, 'https://www.youtube.com')  # string list 의 요소마다 suffix 추가
    results = "\n".join(results)  # list to str

    # fail
    # dialog=GuiUtil.CustomQdialog(title=f"크롤링결과보고", ment=f"{results}", btns=[YES], auto_click_positive_btn_after_seconds="")
    # dialog.exec()

    # fail
    # GuiUtil.pop_up_as_complete(title="크롤링결과보고", ment=f"{results}")

    # success
    # debug_as_gui(f"{results}") # 테스트용 팝업    GuiUtil 로 옮기는 게 나을 지 고민 중이다.

    # success
    # 비동기로 진행 가능
    global dialog
    dialog = GuiUtil.CustomQdialog(title=f"크롤링결과보고", prompt=f"({a_tags_cnt}개 추출됨)\n\n{results}")
    dialog.show()


def crawl_youtube_video_title_and_url(url: str):
    import inspect
    import tqdm
    from pkg_py.pk_interface_graphic_user import GuiUtil
    func_n = inspect.currentframe().f_code.co_name

    browser_debug_mode = False

    # url 전처리
    url = url.strip()

    # driver 설정
    total_percent = 100
    driver = get_driver_selenium(browser_debug_mode=browser_debug_mode)
    with tqdm(total=total_percent, ncols=79, desc="driver 설정 진행률") as process_bar:
        global title
        title = 'html  href 크롤링 결과'
        target_url = url
        driver.get(target_url)
        page_src = driver.page_source
        from bs4 import BeautifulSoup
        soup = BeautifulSoup(page_src, "lxml")
        pk_sleep(seconds=0.0001)
        process_bar.update(total_percent)
    driver.close()

    # 변수에 저장 via tag_name and id
    name = soup.find_all("a", id="video-title")
    video_url = soup.find_all("a", id="video-title")

    # list 에 저장
    name_list = []
    url_list = []
    # view_list=[]
    for i in range(len(name)):
        name_list.append(name[i].text.strip())
        # view_list.append(view[i].get('aria-label').split()[-1])
    for i in video_url:
        url_list.append('{}{}'.format('https://www.youtube.com', i.get('href')))

    # dict 에 저장
    # youtubeDic={
    #     '제목': name_list,
    #     '주소': url_list,
    #     # '조회수': view_list
    # }

    # csv 에 저장
    # youtubeDf=pd.DataFrame(youtubeDic)
    # youtubeDf.to_csv(f'{keyword}.csv', encoding='', index=False)

    # str 에 저장
    results_list = []
    for index, url in enumerate(url_list):
        results_list.append(f"{name_list[index]}   {url_list[index]}")
    results_str = "\n".join(results_list)  # list to str

    # fail
    # dialog=GuiUtil.CustomQdialog(title=f"크롤링결과보고", ment=f"{results}", btns=[YES], auto_click_positive_btn_after_seconds="")
    # dialog.exec()

    # fail
    # GuiUtil.pop_up_as_complete(title="크롤링결과보고", ment=f"{results}")

    # success
    # debug_as_gui(f"{results}") # 테스트용 팝업    GuiUtil 로 옮기는 게 나을 지 고민 중이다.

    # success
    # 비동기로 진행 가능
    global dialog
    dialog = GuiUtil.CustomQdialog(title=f"크롤링결과보고", prompt=f"({len(url_list)}개 url 추출됨)\n\n{results_str}")
    dialog.show()


def crawl_youtube_playlist(url: str):
    import inspect
    import tqdm
    from pkg_py.pk_interface_graphic_user import GuiUtil
    func_n = inspect.currentframe().f_code.co_name

    # url 전처리
    url = url.strip()

    # driver 설정
    total_percent = 100
    driver = get_driver_selenium(browser_debug_mode=False)
    with tqdm(total=total_percent, ncols=79, desc="driver 설정 진행률") as process_bar:
        global title
        title = 'html  href 크롤링 결과'
        target_url = url
        driver.get(target_url)
        page_src = driver.page_source
        from bs4 import BeautifulSoup
        soup = BeautifulSoup(page_src, "lxml")
        pk_sleep(seconds=0.0001)
        process_bar.update(total_percent)
    driver.close()

    names = soup.find_all("a", id="video-title")
    hrefs = soup.find_all("a", id="video-title")
    # hrefs=copy.deepcopy(names)

    # list 에 저장
    name_list = []
    href_list = []
    # view_list=[]
    for i in range(len(names)):
        name_list.append(names[i].text.strip())
        # view_list.append(view[i].get('aria-label').split()[-1])
    for i in hrefs:
        href_list.append('{}{}'.format('https://www.youtube.com', i.get('href')))

    # str 에 저장
    result_list = []
    for index, url in enumerate(href_list):
        # results_list.append(f"{name_list[index]}   {hrefs_list[index]}")
        result_list.append(f"{href_list[index]}")  # href 만 출력
    results_str = "\n".join(result_list)

    # fail
    # dialog=GuiUtil.CustomQdialog(title=f"크롤링결과보고", ment=f"{results}", btns=[YES], auto_click_positive_btn_after_seconds="")
    # dialog.exec()

    # fail
    # GuiUtil.pop_up_as_complete(title="크롤링결과보고", ment=f"{results}")

    # success
    # debug_as_gui(f"{results}") # 테스트용 팝업    GuiUtil 로 옮기는 게 나을 지 고민 중이다.

    # success
    # 비동기로 진행 가능
    global dialog
    dialog = GuiUtil.CustomQdialog(title=f"크롤링결과보고", prompt=f"({len(href_list)}개 playlist 추출됨)\n\n{results_str}")
    dialog.show()


def should_i_crawl_a_tag_href():
    import inspect
    from pkg_py.pk_core_class import PkMents2025
    from pkg_py.pk_interface_graphic_user import GuiUtil
    func_n = inspect.currentframe().f_code.co_name
    while 1:

        url = ""

        dialog = GuiUtil.CustomQdialog(prompt="해당 페이지의 href 를 크롤링할까요?", btn_list=[YES, NO], input_box_mode=True, input_box_text_default=url)
        dialog.exec()
        btn_txt_clicked = dialog.btn_txt_clicked

        if btn_txt_clicked == PkMents2025.YES:
            crawl_html_href(url=dialog.input_box.text())
            break
        else:
            break


def should_i_crawl_youtube_video_title_and_url():
    import inspect
    from pkg_py.pk_core_class import PkMents2025
    from pkg_py.pk_interface_graphic_user import GuiUtil
    func_n = inspect.currentframe().f_code.co_name
    while 1:

        # 테스트용
        keyword = 'blahblah'
        url = f'https://www.youtube.com/results?search_query={keyword}'

        dialog = GuiUtil.CustomQdialog(prompt="해당 페이지의 video title, video url을 크롤링할까요?", btn_list=[YES, NO], input_box_mode=True, input_box_text_default=url)
        dialog.exec()
        btn_txt_clicked = dialog.btn_txt_clicked

        if btn_txt_clicked == PkMents2025.YES:
            crawl_youtube_video_title_and_url(url=dialog.input_box.text())
            break
        else:
            break


def should_i_crawl_youtube_playlist():
    from pkg_py.pk_core_class import PkMents2025
    from pkg_py.pk_interface_graphic_user import GuiUtil
    while 1:
        # 테스트용
        keyword = 'blahblah'
        url = f'https://www.youtube.com/@{keyword}/playlists'

        dialog = GuiUtil.CustomQdialog(prompt="해당 페이지의 video title, video url을 크롤링할까요?", btn_list=[YES, NO], input_box_mode=True, input_box_text_default=url)
        dialog.exec()
        btn_txt_clicked = dialog.btn_txt_clicked

        if btn_txt_clicked == PkMents2025.YES:
            crawl_youtube_playlist(url=dialog.input_box.text())
            break
        else:
            break


def should_i_explorer():
    from pkg_py.pk_core_class import PkMents2025
    from pkg_py.pk_interface_graphic_user import GuiUtil
    while 1:
        dialog = GuiUtil.CustomQdialog(prompt="해당위치의 타겟을 exec 할까요?", btn_list=[YES, NO], input_box_mode=True, input_box_text_default=pk_paste())
        dialog.exec()
        btn_txt_clicked = dialog.btn_txt_clicked
        input_box_text = dialog.input_box.text()
        if btn_txt_clicked == PkMents2025.YES:
            pnx = input_box_text
            cmd = rf"explorer {pnx}"
            cmd_to_os(cmd=cmd, mode="a")
            break
        else:
            break


def should_i_rsync():  # todo : chore : wsl rsync 로 교체
    import inspect
    from pkg_py.pk_core_constants import D_PROJECT_PARENTS
    from pkg_py.pk_core_class import PkMents2025
    from pkg_py.pk_interface_graphic_user import GuiUtil
    func_n = inspect.currentframe().f_code.co_name
    # text_promised=pk_paste()
    text_promised = D_PROJECT_PARENTS
    while 1:
        dialog = GuiUtil.CustomQdialog(prompt="해당위치의 타겟을 싱크할까요?", btn_list=[YES, NO], input_box_mode=True, input_box_text_default=text_promised)
        dialog.exec()
        btn_txt_clicked = dialog.btn_txt_clicked

        # txt_written 에 데이터 저장
        txt_written = dialog.input_box.text()

        # txt_written 데이터 전처리
        # "  C:\projects\services  " ->> "C:\projects\services"
        txt_written = txt_written.strip()
        # "C:\projects\services" ->> C:\projects\services
        if txt_written.startswith("\""):
            if txt_written.endswith("\""):
                txt_written = txt_written.replace("\"", "", 1)
                # txt_written=txt_written[:-(len("\""))] + "${add suffix test}" # 이코드는 add suffix 만들 때 활용하자
                txt_written = txt_written[:-(len("\""))] + ""

        pnx = txt_written
        pnx_todo_sync = rf"{pnx}_sync"
        pnx_todo_sync_zip = rf"{pnx}_sync.zip"

        if btn_txt_clicked == PkMents2025.YES:
            copy_pnx_from_local_os_to_remote_os_via_rsync(d_pnx=pnx)
            break
        else:
            break


def download_video_from_web2():
    from pkg_py.pk_core_constants import D_PROJECT
    if not is_internet_connected():
        raise
    while 1:
        f_png = rf"{D_PROJECT}\pkg_png\download_video_via_chrome_extensions1.png"
        is_image_finded = click_center_of_img_recognized_by_mouse_left(img_pnx=f_png, loop_limit_cnt=100)
        if is_image_finded:
            pk_sleep(30)
            pk_press("ctrl", "f")
            pk_press("end")
            pk_press("ctrl", "a")
            pk_press("backspace")
            write_fast("save")
            pk_press("enter")
            pk_press("enter")
            pk_press("esc")
            pk_press("enter")
            f_png = rf"{D_PROJECT}\pkg_png\download_video_via_chrome_extensions2.png"
            is_image_finded = click_center_of_img_recognized_by_mouse_left(img_pnx=f_png, loop_limit_cnt=100)
            if is_image_finded:
                pk_press("shift", "w")
            else:
                pk_speak_v2(working_str="이미지를 찾을 수 없어 해당 자동화 기능을 마저 진행할 수 없습니다", comma_delay=0.98)
        else:
            pk_speak_v2(working_str="이미지를 찾을 수 없어 해당 자동화 기능을 마저 진행할 수 없습니다", comma_delay=0.98)
        break
    pass


def gather_empty_d(d_working: str, d_dst=None):
    import os
    from pkg_py.pk_colorful_cli_util import pk_print
    """
    d_src에서 빈 d를 찾아 d_dst 로 이동하는 함수.
    """
    if d_dst is None:
        d_dst = r"D:\[]\[empty]"

    ensure_pnx_made(pnx=d_dst, mode="d")  # 대상 d 생성

    if not is_d(d_working):
        pk_print(f"'{d_working}' is not a valid d.", print_color='red')
        return

    #  1. 빈 d를 찾아 이동 (한 번만 exec )
    for root, d_nx_list, f_nx_list in os.walk(d_working, topdown=False):
        if not d_nx_list and not f_nx_list and is_empty_d(root):
            move_pnx(pnx=root, d_dst=d_dst)

    #  2. 빈 트리(리프 d)를 이동 후 remove
    pk_print(f"d_working={d_working}  {'%%%FOO%%%' if LTA else ''}")

    if is_empty_tree(d_working):  # d_src 전체를 검사
        for root, d_nx_list, _ in os.walk(d_working, topdown=True):
            for d_nx in d_nx_list:
                d_working = os.path.abspath(os.path.join(root, d_nx))
                if is_leaf_d(d_working):
                    move_pnx(pnx=d_working, d_dst=d_dst)


def get_kor_from_eng(english_word: str):
    translating_dictionary = {
        "id": "아이디",
        "pw": "패스워드",
        "e mail": "이메일",
    }
    result = ""
    try:
        result = translating_dictionary[english_word]
    except:
        result = english_word
    return result


def raise_exception_after_special_charcater_check(value, inspect_currentframe_f_code_co_name, ignore_list: [str] = None):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    if is_containing_special_characters(value, ignore_list):
        word_english = inspect_currentframe_f_code_co_name
        word_english = word_english.replace('validate_', "")
        word_english = word_english.replace("_", " ")
        word_english = word_english.strip()
        word_korean = get_kor_from_eng(english_word=word_english)
        ment = f"유효한 {word_korean}이(가) 아닙니다. 특수문자가 없어야 합니다 {value}"
        from fastapi import HTTPException
        raise HTTPException(status_code=400, detail=ment)


def merge_f_excel_list(d):
    import inspect
    import os
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_MERGED_EXCEL_FILE
    func_n = inspect.currentframe().f_code.co_name
    try:
        # xls 에서 xlsx로 변환 # openpyxl 은 xls 지원안함.  xlsx 가 더 최신기술.
        f_to_merge_ext = ".xls"
        f_list = [rf"{d}\{file}" for file in os.listdir(d) if f_to_merge_ext in get_x(file)]
        for f in f_list:
            convert_xls_to_xlsx(f)

        # 합병할 f의 목록을 리스트에 저장
        f_to_merge_ext = ".xlsx"
        f_list_to_merge = [f"{d}/{file}" for file in os.listdir(d) if f_to_merge_ext in get_x(file)]
        [print(item) for item in f_list_to_merge]
        print(rf'type(file_list) : {type(f_list_to_merge)}')
        print(rf'len(file_list) : {len(f_list_to_merge)}')

        # f합병할 작업공간 제어
        # wb_new=openpyxl.Workbook()
        # ws1=wb_new.active
        # ws2=wb_new.create_sheet("result")
        # files_cnt=len(files_to_merge)

        # 엑셀 병합 및 저장
        f_merged = F_MERGED_EXCEL_FILE
        merged_cnt = 0
        import pandas as pd
        merged_df = pd.DataFrame()
        for file_path in f_list_to_merge:
            # df=pd.read_excel(file_path, engine="openpyxl")  # 엑셀 f 읽기
            # df=pd.read_excel(file_path, engine="openpyxl", header=0, usecols=[0, 1, 2,3])  # fail, sheet_name="Sheet1"  여러 시트가 있을 경우 시트명을 직접 입력하여 dataframe화 # usecols=[0, 2]  컬럼선택
            # df=pd.read_excel(file_path, engine="openpyxl", header=0, usecols=[1, 2,3])  # fail,   sheet_name="Sheet1"  여러 시트가 있을 경우 시트명을 직접 입력하여 dataframe화 # usecols=[0, 2]  컬럼선택
            df = pd.read_excel(file_path, engine="openpyxl")  # success, 근데 sheet1 만 되고 sheet2 는 무시 된다.

            # 첫줄 remove
            # df=df.iloc[1:]  # 이번 데이터 구조상, 첫줄 을 제외한 나머지 데이터 선택

            # 마지막줄 remove
            # df=df.iloc[:-1]  # 이번 데이터 구조상, 마지막줄 제외한 나머지 데이터 선택

            merged_df = pd.concat([merged_df, df], ignore_index=True)  # 두 데이터프레임 병합

            merged_cnt = merged_cnt + 1

        print(rf'''merge_files_cnt : {merged_cnt + 1}''')
        print(rf'''merged_df : ''')
        print(rf'''{merged_df}''')
        print(rf'''merged_cnt : {merged_cnt}''')
        print(rf'''merged_file : {f_merged}''')
        try:
            merged_df.to_excel(f_merged)  # success
            # pd.ExcelWriter(merged_file, engine= "openpyxl") # fail, 확장자 잘못 저장했나?
            # open_pnx(merged_file)
            open_pnx_by_ext(pnx=f_merged)
        except PermissionError:
            pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
            pk_print(f"{func_n}() 엑셀f이 열려있을 수 있습니다. 닫고 머지를 다시 시도해 주세요", print_color='red')
        except Exception as e:
            pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
            pk_print(f"{func_n}() \n {traceback.format_exc()}", print_color='red')
    except:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')


def download_youtube_list(via_f_txt=None, video_url_list=None):
    import inspect
    from urllib.parse import quote
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PROJECT
    func_n = inspect.currentframe().f_code.co_name
    f_func_n_txt = rf'{D_PROJECT}\pkg_txt\{func_n}.txt'
    ensure_pnx_made(pnx=f_func_n_txt, mode="f")

    if via_f_txt is None and video_url_list is None:
        pk_print(rf"{func_n}() 동작 조건 불충족")
        return

    if via_f_txt is True and video_url_list is None:
        if not is_window_opened(window_title_seg=func_n):
            cmd_to_os(cmd=rf"explorer {f_func_n_txt}")
        video_url_list = get_list_from_f(f=f_func_n_txt)
        video_url_list = get_list_removed_element_contain_prompt(working_list=video_url_list, prompt="#")

    elif via_f_txt is None and video_url_list is None:
        video_url_list = get_list_via_user_input(ment=rf"다운로드할 유튜브 리스트를 \n 단위로 입력하세요", func_n=func_n)

    elif video_url_list is not None:
        video_url_list = video_url_list
    else:
        pk_print(f'''  {'%%%FOO%%%' if LTA else ''} ''', print_color='red')
        return

    video_url_list = get_list_removed_by_removing_runtine(working_list=video_url_list)
    print_iterable_as_vertical(item_iterable=video_url_list, item_iterable_n="urls")
    pk_print(rf'''len(urls)="{len(video_url_list)}"''')
    if len(video_url_list) == 0:
        return
    string_playlist_positive = 'list='
    for url in video_url_list:
        if string_playlist_positive in url:
            encoded_url = quote(url, safe=':/?&=')
            from pytube import Playlist
            playlist = Playlist(encoded_url)
            pk_print(working_str=rf'''playlist="{playlist}"  {'%%%FOO%%%' if LTA else ''}''')
            pk_print(working_str=rf'''playlist.title="{playlist.title}"  {'%%%FOO%%%' if LTA else ''}''')
            pk_print(working_str=rf'''len(playlist.video_urls)="{len(playlist.video_urls)}"  {'%%%FOO%%%' if LTA else ''}''')
            for index, video in enumerate(playlist.videos, start=1):
                pk_print(working_str=rf'''video.watch_url="{video.watch_url}"  {'%%%FOO%%%' if LTA else ''}''')
                download_youtube_videos(urls=[video.watch_url])
        else:
            download_youtube_videos(urls=[url])


def print_user_input_organized_duplicated_hashed():
    import sys
    from pkg_py.pk_colorful_cli_util import pk_print, print_magenta
    from pkg_py.pk_interface_graphic_user import GuiUtil
    import pyautogui
    from PySide6.QtWidgets import QApplication
    import clipboard
    pyautogui.FAILSAFE = False
    q_application = QApplication(sys.argv)
    while 1:
        # input_box_txt_default=""
        input_box_txt_default = "##2025 #2024 #2024 #2024 #2024 #2027 #2025 #hacks#2024 #hacks#2024 #hacks#2024 #hacks#2024 #hacks#2024 #hacks#2024 #hacks #스프레이부스 RC making #압축봉활용 #ORGANIZER #과탄산소다 #커스텀 #diy #DIY #청소 #2027 10 42 스프레이부스 #가구커스텀 #2024 Drawing #2025 건축 #건축커스텀"
        texts = input_box_txt_default.split("#")
        texts_removed_duplication: [str] = []
        dialog = GuiUtil.CustomQdialog(prompt="정리정돈하고 싶은 텍스트를 입력해주세요", btn_list=["진행", "종료"], input_box_mode=True, input_box_text_default=input_box_txt_default)
        dialog.exec()
        btn_txt_clicked = dialog.btn_txt_clicked
        pk_print(btn_txt_clicked, print_color='blue')
        if btn_txt_clicked == "진행":
            user_input = dialog.input_box.text()
            texts = user_input.split("#")
            hashtag_as_year = f'{get_time_as_("%Y")} '
            texts = [item.replace("##", "#") for item in texts]  # mkr_replace_list_element_each
            texts = [hashtag_as_year] + texts  # mkr_add_element_to_list_as_front_element
            texts = [x for x in texts if x is not None]
            texts = get_list_striped_element(working_list=texts)  # mkr_strip_list_element_each
            texts = [item for item in texts if item and item.strip()]  # mkr_remove_list_element_as_""
            for text in texts:
                if text not in texts_removed_duplication:
                    if text is not None:
                        texts_removed_duplication.append(text)
            texts = texts_removed_duplication
            texts_contained_no = [text for text in texts if any(char.isdigit() for char in text)]
            # texts_contained_no=sorted(texts_contained_no, reverse=False)  # mkr_sort_list_element_by_accend_order
            texts_contained_no = sorted(texts_contained_no, reverse=True)  # mkr_sort_list_element_by_decent_order
            texts_not_contained_no = [text for text in texts if text not in texts_contained_no]
            texts = texts_contained_no + texts_not_contained_no  # 숫자있는 요소를 앞쪽에 배열
            texts = ["#" + item for item in texts]  # mkr_add_prefix_to_list_element_each
            texts = " ".join(texts)  # mkr_convert_from_list_to_str
            print_magenta(f'''texts={texts}''')

            clipboard.copy(texts)
            dialog = GuiUtil.CustomQdialog(prompt=f"클립보드로 붙여넣기 되었습니다", btn_list=["닫기"], auto_click_positive_btn_after_seconds=0)
            dialog.exec()
            raise
        elif btn_txt_clicked == "종료":
            raise


def merge_silent_mp3_and_ment_mp3_and_ment__mp3_via_ffmepeg(ment_mp3, ment__mp3):
    import os
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_SILENT_MP3
    """
    앞부분 소리가 들리지 않는 현상
    전체 소리가 다 들려야 하는데
    앞부분의 단어가 들리지 않은채로 소리가 들린다.
    음악f의 앞부분에 빈소리를 추가
    ffmpeg를 이용하여 silent.mp3(1초간 소리가 없는 mp3 f)을 소리를 재생해야할 mp3 f의 앞부분에 합쳐서 재생
    """
    silent_mp3 = F_SILENT_MP3
    if not os.path.exists(silent_mp3):
        pk_print(rf"사일런트 mp3 f({silent_mp3})이 없습니다")
        raise
    if not os.path.exists(ment_mp3):
        cmd = rf'echo y | "ffmpeg" -i "concat:{os.path.abspath(silent_mp3)}|{os.path.abspath(ment__mp3)}" -acodec copy -metadata "title=Some Song" "{os.path.abspath(ment_mp3)}" -map_metadata 0:-1  >nul 2>&1'
        cmd_to_os_like_person_as_admin(cmd)


# def pk_speak_ment_without_async_experimental_v1(working_str, after_delay=1.00):
#     import inspect
#     import os
#     import traceback
#     import pyglet
#     from pkg_py.pk_colorful_cli_util import pk_print
#     from pkg_py.pk_core_constants import D_PROJECT
#     '''
#     이 함수를 많이 쓸 수록 프로그램이 느려진다, 왜냐하면 말하는 속도 < 처리 속도
#     '''
#
#     # 음소거 모드
#     # print_ment_light_yellow("음소거 모드를 exec 중입니다")
#     # ment="`"
#
#     func_n = inspect.currentframe().f_code.co_name
#     working_str = str(working_str)
#     working_str = working_str.strip()
#     pk_print(working_str=rf'''ment_string="{working_str}"  {'%%%FOO%%%' if LTA else ''}''', print_color='blue')
#     if is_containing_special_characters_with_thread(text=working_str):
#         working_str = remove_special_characters(text=working_str)
#     if working_str == "":
#         return None
#     try:
#         while 1:
#             ments = []
#             if "," in working_str:  # , 를 넣으면 나누어 읽도록 업데이트
#                 ments = working_str.split(",")
#                 for working_str in ments:
#                     pk_speak_v2(working_str=working_str, comma_delay=0.98)
#                 break
#             if type(working_str) == str:
#                 # while is_speak_as_async_running:
#                 #     pk_print(f"def {inspect.currentframe().f_code.co_name}() 에 대한 다른 쓰레드를 기다리는 중입니다")
#                 #     pass
#                 # is_speak_as_async_running=True # 쓰레드상태 사용 중으로 업데이트
#
#                 cache_mp3 = rf'{D_PROJECT}\pkg_mp3'
#                 ensure_pnx_made(pnx=cache_mp3, mode="d")
#
#                 # "ment 전처리, 윈도우 경로명에 들어가면 안되는 문자들 공백으로 대체"
#                 working_str = get_str_replaced_special_characters(target=working_str, replacement=" ")
#                 working_str = working_str.replace("\n", " ")
#
#                 # f 없으면 생성
#                 ment__mp3 = rf'{cache_mp3}\{working_str}_.mp3'
#                 ment_mp3 = rf'{cache_mp3}\{working_str}.mp3'
#                 if not os.path.exists(ment_mp3):
#                     if not os.path.exists(ment__mp3):
#                         from gtts import gTTS
#                         if "special_characters" in what_does_this_consist_of(text=working_str):
#                             gtts = gTTS(text=working_str, lang='ko')
#                             gtts.save(ment__mp3)
#                         elif "kor" in what_does_this_consist_of(text=working_str):
#                             gtts = gTTS(text=working_str, lang='ko')
#                             gtts.save(ment__mp3)
#                         elif "eng" in what_does_this_consist_of(text=working_str):
#                             gtts = gTTS(text=working_str, lang='en')
#                             gtts.save(ment__mp3)
#                         elif "jpn" in what_does_this_consist_of(text=working_str):
#                             gtts = gTTS(text=working_str, lang='ja')
#                             gtts.save(ment__mp3)
#                         else:
#                             gtts = gTTS(text=working_str, lang='ko')
#                             gtts.save(ment__mp3)
#                 try:
#                     merge_silent_mp3_and_ment_mp3_and_ment__mp3_via_ffmepeg(ment_mp3, ment__mp3)
#                 except Exception:
#                     pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
#
#                 try:
#                     # 자꾸 프로세스 세션을 빼앗기 때문에 불편한 코드
#                     # os.system(rf'start /b cmd /c call "{ment_mp3}" >nul 2>&1')
#
#                     # 프로세스 세션을 빼앗지 않고 mp3재생하는 다른 방법
#                     # playsound.playsound(os.path.abspath(ment_mp3))
#
#                     # pk_print(rf'프로세스 세션을 빼앗지 않고 mp3재생')
#                     ment_mp3 = os.path.abspath(ment_mp3)
#                     try:
#                         # 재생
#                         source = pyglet.media.load(ment_mp3)
#                         # pyglet_player=pyglet_player
#                         # pyglet_player.queue(source)
#                         source.play()  # 웃긴다 이거 이렇게는 재생이 된다.
#
#                         length_of_mp3 = get_length_of_mp3(ment_mp3)
#                         # sleep(seconds=length_of_mp3 * 0.65)
#                         # sleep(seconds=length_of_mp3 * 0.75)
#                         # sleep(seconds=length_of_mp3 * 0.85)
#                         # sleep(seconds=length_of_mp3 * 0.95)
#                         # sleep(seconds=length_of_mp3 * 1.05)
#                         # sleep(seconds=length_of_mp3 * 1.00)
#                         pk_sleep(seconds=length_of_mp3 * after_delay)
#
#                         return length_of_mp3
#                         # is_speak_as_async_running=False # 쓰레드상태 사용종료로 업데이트
#                     except FileNotFoundError:
#                         pk_print(f"{ment_mp3} 재생할 f이 없습니다", print_color='blue')
#                     except:
#                         pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
#                         break
#
#                     pk_print("before_mp3_length_used_in_speak_as_async 업데이트")
#                     length_of_mp3 = round(float(get_length_of_mp3(ment_mp3)), 1)
#                     PREVIOUS_MP3_LENGTH_USED_IN_SPEAK_AS_ASYNC = length_of_mp3
#
#                 except Exception:
#                     pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
#
#                 # pk_print(rf'불필요 f 삭제')
#                 os.system(f'echo y | del /f "{ment__mp3}" >nul 2>&1')
#
#                 # pk_print(rf'중간로깅')
#                 pk_print(f"TTS 재생시도")
#             break
#     except Exception:
#         pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')


def speak_today_info_as_korean():
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    yyyy = get_time_as_('%Y')
    MM = get_time_as_('%m')
    dd = get_time_as_('%d')

    pk_speak(working_str=f'{int(yyyy)}년 {int(MM)}월 {int(dd)}일', after_delay=0.95)


def pk_back_up_pnx(pnx_working, d_dst):
    from pkg_py.pk_colorful_cli_util import pk_print

    if not does_pnx_exist(pnx=pnx_working):
        pk_print(working_str=rf'''{'%%%FOO%%%' if LTA else ''}''', print_color='red')
        return

    # 용량을 확인하고 부족하면 95프로 이면 휴지통을 비울것을 가이드 하고
    # 하면안될것 같다고 이야기해줘

    # 압축
    return compress_pnx(src=pnx_working, dst=d_dst)


def pk_back_up_pnx_without_venv_and_idea(pnx_working, d_dst, with_timestamp=1):
    # done : compress f_rar without .venv and .idea
    # done : save f_rar without timestamp
    from pkg_py.pk_colorful_cli_util import pk_print
    if not does_pnx_exist(pnx=pnx_working):
        pk_print(working_str=rf'''not does_pnx_exist  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        return

    # 압축
    return compress_pnx_without_venv_and_idea_via_rar(pnx=pnx_working, d_dst=d_dst, with_timestamp=with_timestamp)


def back_up_pnx_list_from_f_txt(dst):
    import inspect
    from pkg_py.pk_core_constants import D_PKG_TXT, D_PROJECT
    func_n = inspect.currentframe().f_code.co_name
    f_txt = rf'{D_PROJECT}\pkg_txt\{func_n}.txt'
    ensure_pnx_made(pnx=D_PKG_TXT, mode="d")
    ensure_pnx_made(pnx=f_txt, mode="f")
    # open_pnx(f_func_n_txt)
    texts = get_list_from_f(f=f_txt)
    texts = get_list_deduplicated(working_list=texts)
    texts = get_list_striped_element(working_list=texts)
    for text in texts:
        pk_back_up_pnx(pnx_working=text, d_dst=dst)


# def hold_console():
#     func_n = inspect.currentframe().f_code.co_name
#     os.system("cmd /k")


def chcp_65001():
    import os
    os.system("chcp 65001 >nul")


def kill_process_via_taskkill(process_name=None, pid=None, debug_mode=True):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name

    if process_name is not None or pid is not None:
        pk_print(rf"{func_n}() 동작 조건 충족")
    else:
        pk_print(rf"{func_n}() 동작 조건 불충족")
        return

    cmd = None
    if process_name != None:
        cmd = f'taskkill /f /im {process_name}"'
    elif pid != None:
        cmd = f'taskkill /f /pid {pid}"'
    cmd_to_os(cmd=cmd)


def rerun_pnx(my_name):  # 종료용이름 시작용이름 이 다름 따로 수집해서 코딩 필요
    import inspect

    func_n = inspect.currentframe().f_code.co_name
    kill_process_via_taskkill(process_name=my_name)
    pk_sleep(milliseconds=200)  # 최적화 테스트 필요
    cmd = rf'start "{my_name}"'
    cmd_to_os(cmd=cmd, mode="a")


def mstsc(ip=None, port=3389):
    import inspect
    # 내부망에서 유동ip일때 ip대신 hostname 추천
    func_n = inspect.currentframe().f_code.co_name
    # cmd=f'mstsc /v:{ip}:{port} /admin /w:640 /h:350 /multimon /NoConsentPrompt'
    # cmd=f'mstsc /admin /w:960 /h:540 /v:{ip}:{port} /multimon /NoConsentPrompt'
    # cmd=f'mstsc /admin /w:960 /h:540 /v:{ip}:{port} /multimon /NoConsentPrompt'
    # cmd=f'mstsc /admin /w:960 /h:1080 /v:{ip}:{port} /multimon /NoConsentPrompt'
    cmd = f'mstsc /v:{ip}:{port} /admin /w:1024 /h:768 /multimon '
    cmd_to_os(cmd, mode='a')


@pk_measure_seconds
def get_d_working_in_python():
    import os
    d_current = os.getcwd()
    return d_current


@pk_measure_seconds
def pwd():
    print(())


def build_pk_project_via_pyinstaller():
    import os
    from pkg_py.pk_core_constants import D_PROJECT, D_VENV
    from pkg_py.pk_colorful_cli_util import pk_print

    # 프로젝트 d로 이동
    os.chdir(D_PROJECT)

    if does_pnx_exist(pnx=D_VENV):
        pk_print(f"{D_VENV} d가 있습니다")

        # 현재d의 불필요한 타겟들을 삭제
        items_useless = [
            rf"{D_PROJECT}\pk.exe",
            rf"{D_PROJECT}\build",
            rf"{D_PROJECT}\dist",
            rf"{D_PROJECT}\_internal",
            rf"{D_PROJECT}\dist.zip",
            rf"{D_PROJECT}\pk.spec",
        ]
        for item in items_useless:
            remove_pnx_parmanently(pnx=item)

        # pip 업그레이드
        cmd_to_os(cmd="python -m pip install --upgrade pip")

        # pip 업그레이드
        cmd_to_os(cmd="pip install pyinstaller --upgrade")

        if not LTA:
            cmd_to_os(cmd=rf"python -m PyInstaller -i .\pkg_png\icon.PNG pk_test_test.py")

        if LTA:
            cmd_to_os(cmd=rf'echo d | xcopy ".\pkg_mp3" ".\dist\pk_test_test\_internal\pkg_mp3" /e /h /k /y')

        # f = f'{D_PROJECT}/pk_temp.py'
        # write_f(f)

        # 가상환경을 활성화하고, 그 후에 파이썬 스크립트 exec
        # run

        # pk_temp.py
        # os.remove(f)

    else:
        pk_print(f"{D_VENV} d가 없습니다")


def get_nxs_without_walking(mode=None, d_src=None):
    import os
    if d_src is None:
        d_src = os.getcwd()  # 현재 작업 d로 설정

    # 절대경로로 변환
    d_src = os.path.abspath(d_src)

    # 리스트로 결과를 받기 위한 변수
    f_list = []
    d_list = []

    # os.scandir() 사용하여 더 빠르게 항목 탐색
    try:
        with os.scandir(d_src) as it:
            for entry in it:
                if entry.is_dir():  # d일 경우
                    d_list.append(entry.name)  # d 이름 추가
                elif entry.is_file():  # f일 경우
                    f_list.append(entry.name)  # f 이름 추가
    except FileNotFoundError:
        print(f"d '{d_src}'을 찾을 수 없습니다.")
        return []

    # 원하는 mode에 따라 f, d, 혹은 둘 다 반환
    if mode == "f":
        return f_list
    elif mode == "d":
        return d_list
    else:
        return f_list + d_list


def get_pnx_list(with_walking: int, mode=None, d_working=None):
    import os
    if with_walking == 1:
        if d_working is None:
            d_working = os.getcwd()

        f_list = []
        d_list = []

        for root, d_nx_list, f_nx_list in os.walk(d_working):
            d = os.path.abspath(root)
            d_list.append(d)

            for f_nx in f_nx_list:
                f = os.path.join(root, f_nx)
                f_list.append(f)

            # 하위 d 탐색을 원하지 않는 경우
            if mode == "d":  # d만 원하면 아래 항목에서 멈춤
                del d_nx_list[:]

        # 원하는 mode에 따라 결과 반환
        if mode == "f":
            pnx_list = f_list
        elif mode == "d":
            pnx_list = d_list
        else:
            pnx_list = f_list + d_list

        # 출력제한
        print_limit = 100000000
        if len(f_list) <= print_limit:
            # pk_print(f'''files={files}''')
            # pk_print(f'''directories={directories}''')
            pass

        return pnx_list
    elif with_walking == 0:
        import os
        if d_working is None:
            d_working = os.getcwd()

        # 절대경로로 변환
        d_working = os.path.abspath(d_working)

        pnx_nx_list = os.listdir(d_working)
        f_list = []
        d_list = []

        for pnx_nx in pnx_nx_list:
            pnx = os.path.join(d_working, pnx_nx)  # 절대경로로 결합
            if is_d(pnx):
                d_list.append(pnx)  # d의 절대경로 추가
            else:
                f_list.append(pnx)  # f의 절대경로 추가

        # 원하는 mode에 따라 결과 반환
        if mode == "f":
            pnx_list = f_list
        elif mode == "d":
            pnx_list = d_list
        else:
            pnx_list = f_list + d_list
        return pnx_list


def get_list_to_include_element(working_list, include_element):
    pnx_filtered_list = []
    for item in working_list:
        if include_element in item:
            pnx_filtered_list.append(item)
    return pnx_filtered_list


def ensure_pnx_removed(pnx):
    from pkg_py.pk_colorful_cli_util import pk_print
    import os
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    if not does_pnx_exist(pnx):
        pk_print(f'''삭제할 {get_nx(pnx)} 가 없습니다. {'%%%FOO%%%' if LTA else ''}''')
        return
    if does_pnx_exist(pnx):
        # 1
        # if is_f(pnx):
        #     cmd = rf'echo y | del /f "{pnx}"'
        # else:
        #     cmd = rf'echo y | rmdir /s "{pnx}"'
        # cmd_to_os(cmd=cmd)

        # 2
        # if does_pnx_exist(pnx):
        #     os.remove(pnx)

        # 3
        move_pnx_to_pk_recycle_bin(pnx)
    if not os.path.exists(pnx):
        pk_print(rf"[{func_n}] pnx={pnx} {'%%%FOO%%%' if LTA else ''}", print_color='green')
    else:
        pk_print(rf"[{func_n}] pnx={pnx} {'%%%FOO%%%' if LTA else ''}", print_color='red')


def does_pnx_exist(pnx=None, nx=None):
    from pkg_py.pk_colorful_cli_util import pk_print
    import os
    if LTA:
        pk_print(f'''pnx={pnx} {'%%%FOO%%%' if LTA else ''}''')
    # pnx = get_pnx_os_style(pnx)
    if not pnx:
        if not nx:
            pk_print(f'''해당 함수는 pnx nx 둘 중 하나만 설정되어야합니다. {'%%%FOO%%%' if LTA else ''}''', print_color='red')
    if pnx:
        if os.path.exists(pnx):
            return 1
        else:
            pk_print(f'''{pnx}  {'%%%FOO%%%' if LTA else ''} ''')
            return 0
    if nx:
        if pnx in get_pnx_list_from_d_working(d_working=get_d_working(), with_walking=0):
            if nx not in pnx:
                return 0


def is_target_type_list(target):
    if isinstance(target, list):
        return 1
    else:
        return 0


def is_target_type_str(target):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    if isinstance(target, str):
        return 1
    else:
        return 0


def pk_decompress_f_via_zip(f):
    import inspect
    import os
    import zipfile
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    # cmd=rf'bz.exe x "{pnx}"'  # 화면에 창이 안뜨는 모드
    # cmd_to_os(cmd=cmd)
    pnx_p = get_p(pnx=f)
    if pnx_p is None:
        pnx_p = os.path.dirname(f)
    pnx_p = get_pnx_unix_style(pnx=pnx_p)
    f = get_pnx_unix_style(pnx=f)
    with zipfile.ZipFile(f, 'r') as zip_ref:
        if not os.path.exists(pnx_p):
            os.makedirs(pnx_p)
        zip_ref.extractall(pnx_p)
        pk_print(working_str=rf'''pnx_p="{pnx_p}"  {'%%%FOO%%%' if LTA else ''}''')


def get_parents_process_pid():
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    cmd = rf'powershell (Get-WmiObject Win32_Process -Filter ProcessId=$PID).ParentProcessId'
    lines = cmd_to_os_like_person_as_admin(cmd=cmd)
    lines = get_list_replaced_element_from_str_to_str(working_list=lines, from_str="\r", to_str="")
    return lines[0]


def is_containing_kor(text):
    import re
    pattern = "[ㄱ-ㅎ가-힣]"
    if re.search(pattern, text):
        return 1
    else:
        return 0


def is_containing_special_characters_with_thread(text: str):
    import re
    import threading
    # 비동기 처리 설정 ( advanced  )
    nature_numbers = [n for n in range(1, 101)]  # from 1 to 100
    work_quantity = len(text)
    n = 4  # thread_cnt # interval_cnt
    d = work_quantity // n  # interval_size
    r = work_quantity % n
    start_1 = 0
    end_1 = d - 1
    starts = [start_1 + (n - 1) * d for n in nature_numbers[:n]]  # 등차수열 official
    ends = [end_1 + (n - 1) * d for n in nature_numbers[:n]]
    remained_start = ends[-1] + 1
    remained_end = work_quantity

    # print(rf'nature_numbers : {nature_numbers}')  # 원소의 길이의 합이 11넘어가면 1에서 3까지만 표기 ... 의로 표시 그리고 마지막에서 3번째에서 마지막에서 0번째까지 표기 cut_list_proper_for_pretty()
    # print(rf'work_quantity : {work_quantity}')
    # print(rf'n : {n}')
    # print(rf'd : {d}')
    # print(rf'r : {r}')
    # print(rf'start_1 : {start_1}')
    # print(rf'end_1 : {end_1}')
    # print(rf'starts : {starts}')
    # print(rf'ends : {ends}')
    # print(rf'remained_start : {remained_start}')
    # print(rf'remained_end : {remained_end}')

    # 비동기 이벤트 함수 설정 ( advanced  )
    async def is_containing_special_characters(start_index: int, end_index: int, text: str):
        pattern = "[~!@#$%^&*()_+|<>?:{}]"  # , 는 제외인가?
        if re.search(pattern, text[start_index:end_index]):
            # print(f"쓰레드 {start_index}에서 {end_index}까지 작업 성공 True return")
            result_list.append(True)
            # return 1
        else:
            result_list.append(False)
            # print(f"쓰레드 {start_index}에서 {end_index}까지 작업 성공 False return")
            # return 0

    # 비동기 이벤트 루프 설정
    def run_async_event_loop(start_index: int, end_index: int, text: str):
        import asyncio
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.run_until_complete(is_containing_special_characters(start_index, end_index, text))

    # 스레드 객체를 저장할 리스트 생성
    threads = []

    # 각 스레드의 결과를 저장할 리스트
    # result_list=[None] * work_quantity
    result_list = []

    # 주작업 처리용 쓰레드
    for n in range(0, n):
        start_index = starts[n]
        end_index = ends[n]
        thread = threading.Thread(target=run_async_event_loop, args=(start_index, end_index, text))
        thread.start()
        threads.append(thread)

    # 남은 작업 처리용 쓰레드
    if remained_end <= work_quantity:
        start_index = remained_start
        end_index = remained_end
        thread = threading.Thread(target=run_async_event_loop, args=(start_index, end_index, text))
        thread.start()
        threads.append(thread)
    else:
        start_index = remained_start
        end_index = start_index  # end_index 를 start_index 로 하면 될 것 같은데 테스트필요하다.
        thread = threading.Thread(target=run_async_event_loop, args=(start_index, end_index, text))
        thread.start()
        threads.append(thread)

    # 모든 스레드의 작업이 종료될 때까지 대기
    for thread in threads:
        thread.join()

    # 먼저 종료된 스레드가 있는지 확인하고, 나머지 스레드 중지
    # for thread in threads:
    #     if not thread.is_alive():
    #         for other_thread in threads:
    #             if other_thread != thread:
    #                 other_thread.cancel()
    #         break

    # 바뀐 부분만 결과만 출력, 전체는 abspaths_and_mtimes 에 반영됨
    # print(rf'result_list : {result_list}')
    # print(rf'type(result_list) : {type(result_list)}')
    # print(rf'len(result_list) : {len(result_list)}')

    if all(result_list):
        # pk_print(str_working="쓰레드 작업결과 result_list의 모든 요소가 True이므로 True를 반환합니다")
        return 1
    else:
        # pk_print(str_working="쓰레드 작업결과 result_list에 False인 요소가 있어 False를 반환합니다")
        pass


def is_containing_jpn(text):
    import re
    # pattern=r"^[\p{Script=Hiragana}\p{Script=Katakana}\p{Script=Han}ー〜・]+$"
    # pattern=r"^\P{Script=Hiragana}\P{Script=Katakana}\P{Script=Han}ー〜・]+$"
    # pattern=r"^[\p{Script=Hiragana}\p{Script=Katakana}\p{Script=Han}ー〜・]+$"
    # pattern=r"^[^\p{Script=Hiragana}^\p{Script=Katakana}^\p{Script=Han}ー〜・]+$"
    # pattern=r"^[^\p{Script=Hiragana}^\p{Script=Katakana}^\p{Script=Han}ー〜・]+$"
    pattern = r"^[^\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FFFー〜・]+$"
    if re.search(pattern, text, flags=re.U):
        return 1
    else:
        return 0


def is_containing_eng(text):
    import re
    pattern = "[a-zA-Z]"
    if re.search(pattern, text):
        return 1
    else:
        return 0


def is_containing_number(text):
    import re
    pattern = "[0-9]"
    if re.search(pattern, text):
        return 1
    else:
        return 0


def is_only_no(text):
    import re
    pattern = "^[0-9]+$"
    if re.search(pattern, text):
        return 1
    else:
        return 0


def is_only_speacial_characters(text):
    import re
    pattern = "^[~!@#$%^&*()_+|<>?:{}]+$"
    if re.search(pattern, text):
        return 1
    else:
        return 0


def is_only_eng_and_kor_and_no_and_speacial_characters(text):
    import re
    pattern = "^[ㄱ-ㅎ가-힣0-9a-zA-Z~!@#$%^&*()_+|<>?:{}]+$"
    if re.search(pattern, text):
        return 1
    else:
        return 0


def is_only_eng_and_no_and_speacial_characters(text):
    import re
    pattern = "^[0-9a-zA-Z~!@#$%^&*()_+|<>?:{}]+$"
    if re.search(pattern, text):
        return 1
    else:
        return 0


def is_only_eng_and_speacial_characters(text):
    import re
    pattern = "^[a-zA-Z~!@#$%^&*()_+|<>?:{}]+$"
    if re.search(pattern, text):
        return 1
    else:
        return 0


def is_only_eng_and_no(text):
    import re
    pattern = "^[0-9a-zA-Z]+$"
    if re.search(pattern, text):
        return 1
    else:
        return 0


def is_only_eng(text):
    import re
    pattern = "^[a-zA-Z]+$"
    if re.search(pattern, text):
        return 1
    else:
        return 0


def is_eng_or_kor_ja(text: str):
    """
    한글처리 :
        한영숫특 :
        한숫특 :
        한숫
        한특
        숫특
        특
        숫
    영어처리 :
        영숫특
        영특
        영숫
        영
    일어처리 :
    빠진거있나? 일단 여기까지

    문자구성 판별기가 필요하다
        return "eng, kor, jap, special_characters ", ... 이런식 > what_does_this_consist_of() 를 만들었다.
    """
    if is_only_speacial_characters(text=text):
        return "ko"
    elif is_only_no(text=text):
        return "ko"
    elif is_containing_kor(text=text):
        return "ko"
    if is_only_eng_and_no_and_speacial_characters(text=text):
        return "en"
    elif is_only_eng_and_speacial_characters(text=text):
        return "en"
    elif is_only_eng_and_no(text=text):
        return "en"
    elif is_only_eng(text=text):
        return "en"
    else:
        return "ko"


def what_does_this_consist_of(text: str):
    result = []
    if is_containing_kor(text=text):
        result.append("kor")
    if is_containing_eng(text=text):
        result.append("eng")
    if is_containing_number(text=text):
        result.append("number")
    if is_containing_special_characters_with_thread(text=text):
        result.append("special_characters")
    if is_containing_jpn(text=text):
        result.append("jpn")
    # print_magenta(rf'text : {text}   result : {result}')
    return result


def get_length_of_mp3(f: str):
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    import mutagen
    try:
        from mutagen.mp3 import MP3
        audio = MP3(f)
        return audio.info.length
    except mutagen.MutagenError:
        # pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red') # gtts 모듈 불능? mutagen 모듈 불능? license 찾아보자 으로 어쩔수 없다.
        return
    except Exception:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')


# def loop_run_for_speak_as_async_deprecated(ment):
#     async def speak_as_async(ment):
#         func_n=inspect.currentframe().f_code.co_name
#         # pyglet_player 가 play() 하고 있으면 before_mp3_length_used_in_speak_as_async 만큼 대기
#         pk_print(rf'before_mp3_length_used_in_speak_as_async 만큼 재생 대기', print_color='blue)
#
#         # pyglet_player 을 del 을 한 경우:
#         # pyglet_player 에 대한 참조가 불가능해진다. 다른 참조법을 적용해보자. 시도해보니 pyglet_player 는 더이상 쓸 수가 없다.
#         # 재활용해야하는 pyglet_player는 더이상 쓸 수 없어졌다.
#         if PYGLET_PLAYER is None:
#             PYGLET_PLAYER=pyglet.media.Player()
#         # if hasattr(pk_system_, 'pyglet_player') and pyglet_player is None:
#         #     # pyglet_player가 None인 경우
#         #     pyglet_player=pyglet.media.Player()
#         #     pass
#         if PYGLET_PLAYER is not None:
#             if PYGLET_PLAYER.playing == True:
#                 length_of_mp3=PREVIOUS_MP3_LENGTH_USED_IN_SPEAK_AS_ASYNC
#                 sleep(seconds=length_of_mp3 * 0.65)  # 이렇면 소리가 겹치지 않는 장점이 있으나, 실제로 일을 미리하고 나중에 보고하는 단점이 있다
#                 # asyncio.sleep(length_of_mp3 * 0.65) # 이렇면 실제로 일을 하자마자 보고하는 장점이 있으나, 소리가 겹치는 않는 단점이 있다
#                 # sleep(seconds=length_of_mp3 * 0.75)
#                 # sleep(seconds=length_of_mp3 * 0.85)
#                 # sleep(seconds=length_of_mp3 * 0.95)
#                 # sleep(seconds=length_of_mp3 * 1.05)
#                 # sleep(seconds=length_of_mp3 * 1.00)
#         try:
#             while 1:
#                 if type(ment) == str:
#                     # while is_speak_as_async_running:
#                     #     pk_print(f"def {inspect.currentframe().f_code.co_name}() 에 대한 다른 쓰레드를 기다리는 중입니다")
#                     #     pass
#                     # is_speak_as_async_running=True # 쓰레드상태 사용 중으로 업데이트
#
#                     cache_sound=rf'{PROJECT_D}\pkg_sound'
#                     make_pnx(pnx=cache_sound, mode="d")
#
#                     # print_ment_magenta("ment 전처리, 윈도우 경로명에 들어가면 안되는 문자들 공백으로 대체")
#                     ment=get_str_replaced_special_characters(target=ment, replacement=" ")
#                     ment=ment.replace("\n", " ")
#
#                     # print_ment_magenta(rf'f 없으면 생성')
#                     ment__mp3=rf'{cache_sound}\{ment}_.mp3'
#                     ment_mp3=rf'{cache_sound}\{ment}.mp3'
#                     if not os.path.exists(ment_mp3):
#                         if not os.path.exists(ment__mp3):
#                             if "special_characters" in what_does_this_consist_of(text=ment):
#                                 gtts=gTTS(text=ment, lang='ko')
#                                 gtts.save(ment__mp3)
#                             elif "kor" in what_does_this_consist_of(text=ment):
#                                 gtts=gTTS(text=ment, lang='ko')
#                                 gtts.save(ment__mp3)
#                             elif "eng" in what_does_this_consist_of(text=ment):
#                                 gtts=gTTS(text=ment, lang='en')
#                                 gtts.save(ment__mp3)
#                             elif "jpn" in what_does_this_consist_of(text=ment):
#                                 gtts=gTTS(text=ment, lang='ja')
#                                 gtts.save(ment__mp3)
#                             else:
#                                 gtts=gTTS(text=ment, lang='ko')
#                                 gtts.save(ment__mp3)
#
#                     try:
#                         merge_silent_mp3_and_ment_mp3_and_ment__mp3_via_ffmepeg(ment_mp3, ment__mp3)
#                     except Exception:
#                         pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
#
#                     try:
#                         # 자꾸 프로세스 세션을 빼앗기 때문에 불편한 코드
#                         # os.system(rf'start /b cmd /c call "{ment_mp3}" >nul 2>&1')
#
#                         # 프로세스 세션을 빼앗지 않고 mp3재생하는 다른 방법
#                         # playsound.playsound(os.path.abspath(ment_mp3))
#
#                         # pk_print(rf'프로세스 세션을 빼앗지 않고 mp3재생')
#                         ment_mp3=os.path.abspath(ment_mp3)
#
#                         try:
#                             # 재생
#                             # pyglet_player=pyglet_player
#                             pyglet_player=pyglet.media.Player()
#                             source=pyglet.media.load(ment_mp3)
#                             # multiprocessed_source_play=source
#                             pyglet_player.queue(source)
#
#                             # 재생추적
#
#                             # 재생 중인 사운드 리소스를 추적하는 이벤트 핸들러 함수
#                             def on_player_eos():
#                                 player=pyglet.media.Player()
#                                 playing_sounds.remove(player)
#
#                             pyglet_player.push_handlers(on_eos=on_player_eos)
#                             # pyglet_player.play()  # 이거 재생 안되는데, 이게 official문서에 나온 방식인데, media 객채 생성 순서가 문제였나 보다.이젠 된다
#                             pyglet_player.play()
#                             source.play()  # 웃긴다 이거 이렇게는 재생이 된다.
#                             playing_sounds=PLAYING_SOUNDS
#                             playing_sounds.append(pyglet_player)
#                             # 사운드 재생을 시작할 때마다 이벤트 핸들러를 등록하여 playing_sounds 리스트에 추가
#
#                             # FAIL
#                             # multiprocessed_source_play=multiprocessing.Process(target= source.play , args=None)
#                             # multiprocessed_source_play.start()
#
#                             if PYGLET_PLAYER.playing == False:
#                                 PYGLET_PLAYER=None
#                                 PREVIOUS_MP3_LENGTH_USED_IN_SPEAK_AS_ASYNC=0
#
#                             # is_speak_as_async_running=False # 쓰레드상태 사용종료로 업데이트
#                         except FileNotFoundError:
#                             pk_print(f"{ment_mp3} 재생할 f이 없습니다", print_color='blue)
#                         except:
#                             pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
#                             return
#
#                         pk_print("before_mp3_length_used_in_speak_as_async 업데이트")
#                         length_of_mp3=round(float(get_length_of_mp3(ment_mp3)), 1)
#                         PREVIOUS_MP3_LENGTH_USED_IN_SPEAK_AS_ASYNC=length_of_mp3
#
#                     except Exception:
#                         pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
#
#                     # pk_print(rf'불필요 f 삭제')
#                     os.system(f'echo y | del /f "{ment__mp3}" >nul 2>&1')
#
#                     # pk_print(rf'중간로깅')
#                     pk_print(f"TTS 재생시도")
#                     return
#                 return
#         except Exception:
#             pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
#
#     func_n=inspect.currentframe().f_code.co_name
#     import asyncio
#     loop=asyncio.new_event_loop()
#     asyncio.set_event_loop(loop)
#     loop.run_until_complete(speak_as_async(ment))


def pk_speak_v2(working_str, comma_delay=1.00, thread_join_mode=False):
    import inspect
    import threading
    from functools import partial
    import pyglet
    from pkg_py.pk_core_constants import PLAYING_SOUNDS, PYGLET_PLAYER
    def stop_all_sounds():
        playing_sounds = PLAYING_SOUNDS
        for player in playing_sounds:
            player.pause()  # 또는 player.stop()

    stop_all_sounds()
    if PYGLET_PLAYER is not None:
        pass
    else:
        PYGLET_PLAYER = pyglet.media.Player()
        if PYGLET_PLAYER.playing:
            PYGLET_PLAYER.pause()

    async def process_thread_speak(working_str):
        # while not exit_event.is_set(): # 쓰레드 이벤트 제어
        func_n = inspect.currentframe().f_code.co_name
        working_str = str(working_str)
        working_str = working_str.strip()
        if working_str == "":
            return None
        if is_containing_special_characters_with_thread(text=working_str):
            working_str = remove_special_characters(text=working_str)
        while 1:
            working_list = [x.strip() for x in working_str.replace(".", ",").split(",")]  # from "abc,abc.abc,abc." to ["abc","abc","abc","abc"] # , or . 를 넣으면 나누어 읽도록 업데이트
            working_list = [x for x in working_list if x.strip()]  # 리스트 요소 "" remove,  from ["", A] to [A]
            for working_str in working_list:
                pk_speak(working_str, after_delay=comma_delay)
                pass
            return None

    # 비동기 이벤트 루프 설정 (simple for void async processing)
    def process_thread_loop(ment):
        import asyncio
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.run_until_complete(process_thread_speak(ment))

    # 비동기 이벤트 루프 exec 할 쓰레드 설정 (simple for void async processing)
    thread = threading.Thread(target=partial(process_thread_loop, working_str), name="thread_for_speak")  # Q: 왜 thread.name 의 case 는 다른거야 ?  wrtn: 네, 스레드의 이름은 일반적으로 대소문자를 구분하지 않습니다.
    thread.start()
    if thread_join_mode == 1:
        thread.join()


def pk_speak(working_str, after_delay=1.00, delimiter=None):
    if is_internet_connected():
        # pk_speak_v1(working_str=working_str, after_delay=after_delay, delimiter=delimiter)
        pk_speak_v2(working_str=working_str, comma_delay=after_delay)


def pk_speak_v1(working_str, after_delay=1.00, delimiter=None):
    # 최적화 필요
    # 많이 쓸 수록 프로그램이 느려진다
    import os
    import traceback
    import pyglet
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_SILENT_MP3, D_PROJECT
    if not delimiter:
        delimiter = ','  # , 를 넣으면 나누어 읽도록 업데이트
    working_str = str(working_str)
    working_str = working_str.strip()
    if is_containing_special_characters(text=working_str):
        working_str = remove_special_characters(text=working_str)
    if working_str == "":
        return None
    try:
        while 1:
            working_list = []
            if LTA:
                pk_print(f'''working_list={working_list} {'%%%FOO%%%' if LTA else ''}''')
            if delimiter in working_str:
                working_list = working_str.split(delimiter)
                for working_str in working_list:
                    pk_speak_v2(working_str=working_str, comma_delay=0.98)
                break
            if type(working_str) == str:
                cache_mp3 = get_pnx_os_style(rf'{D_PROJECT}/pkg_mp3')
                ment__mp3 = get_pnx_os_style(rf'{cache_mp3}/{working_str}_.mp3')
                ment_mp3 = get_pnx_os_style(rf'{cache_mp3}/{working_str}.mp3')

                ensure_pnx_made(pnx=cache_mp3, mode="d")

                # "ment 전처리, 윈도우 경로명에 들어가면 안되는 문자들 공백으로 대체"
                working_str = get_str_replaced_special_characters(target=working_str, replacement=" ")
                working_str = working_str.replace("\n", " ")

                # f 없으면 생성
                if not os.path.exists(ment_mp3):
                    if not os.path.exists(ment__mp3):
                        from gtts import gTTS
                        if "special_characters" in what_does_this_consist_of(text=working_str):
                            gtts = gTTS(text=working_str, lang='ko')
                            gtts.save(ment__mp3)
                        elif "kor" in what_does_this_consist_of(text=working_str):
                            gtts = gTTS(text=working_str, lang='ko')
                            gtts.save(ment__mp3)
                        elif "eng" in what_does_this_consist_of(text=working_str):
                            gtts = gTTS(text=working_str, lang='en')
                            gtts.save(ment__mp3)
                        elif "jpn" in what_does_this_consist_of(text=working_str):
                            gtts = gTTS(text=working_str, lang='ja')
                            gtts.save(ment__mp3)
                        else:
                            gtts = gTTS(text=working_str, lang='ko')
                            gtts.save(ment__mp3)
                try:
                    silent_mp3 = F_SILENT_MP3
                    if not os.path.exists(silent_mp3):
                        pk_print(working_str="사일런트 mp3 f이 없습니다", print_color='red')
                        break
                    if not os.path.exists(ment_mp3):
                        cmd = rf'echo y | "ffmpeg" -i "concat:{os.path.abspath(silent_mp3)}|{os.path.abspath(ment__mp3)}" -acodec copy -metadata "title=Some Song" "{os.path.abspath(ment_mp3)}" -map_metadata 0:-1  >nul 2>&1'
                        cmd_to_os(cmd)
                except Exception:
                    pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
                try:
                    ment_mp3 = os.path.abspath(ment_mp3)
                    try:
                        source = pyglet.media.load(ment_mp3)
                        source.play()

                        length_of_mp3 = get_length_of_mp3(ment_mp3)
                        pk_sleep(seconds=length_of_mp3 * after_delay)
                        return length_of_mp3
                    except FileNotFoundError:
                        pk_print(f"{ment_mp3} 재생할 f이 없습니다")
                    except:
                        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
                        break
                    pk_print("before_mp3_length_used_in_speak_as_async 업데이트")
                    length_of_mp3 = round(float(get_length_of_mp3(ment_mp3)), 1)
                    PREVIOUS_MP3_LENGTH_USED_IN_SPEAK_AS_ASYNC = length_of_mp3
                except Exception:
                    pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')

                os.system(f'echo y | del /f "{ment__mp3}" >nul 2>&1')
                pk_print(f"TTS 재생시도")
            break
    except Exception:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')


def remove_special_characters(text):
    import re
    # pattern=r"[^\w\s]" #  \s(whitespace characters=[" ", "\t", "\n", ".", "\n", "_" ])      # space=" " #공백
    # pattern=r"[^\w.,]" # \w(알파벳, 숫자, 밑줄 문자)와 "." 그리고 ","를 제외한 모든문자를 선택, \t, \n, _ 도 삭제되는 설정
    pattern = r"[~!@#$%^&*()_+|<>?:{}]"
    return re.sub(pattern, "", text)


def make_project_tree_for_pk_system():
    import inspect
    from pkg_py.pk_core_constants import D_PKG_DPL
    func_n = inspect.currentframe().f_code.co_name
    leaf_d_list = [
        D_PKG_DPL
    ]
    for item in leaf_d_list:
        ensure_pnx_made(pnx=item, mode="d")
    leaf_files = [
        # ...
    ]
    for item in leaf_files:
        ensure_pnx_made(pnx=item, mode="f")


def get_list_without_none_and_duplicates(working_list):
    working_list = get_list_deduplicated(working_list)
    working_list = get_list_without_none(working_list)
    return working_list


def get_list_removed_by_removing_runtine(working_list):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    if working_list is None:
        return None
    working_list = get_list_deduplicated(working_list)
    working_list = get_list_without_none(working_list)
    working_list = get_list_removed_element_empty(working_list)
    working_list = get_list_replaced_element_from_str_to_str(working_list, "\n", "")
    working_list = get_list_striped_element(working_list)
    return working_list


def get_list_deduplicated(working_list):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    items_removed_duplication: [str] = []
    for item in working_list:
        if item not in items_removed_duplication:
            # if item is not None:
            items_removed_duplication.append(item)
    working_list = items_removed_duplication
    return working_list


def get_list_without_none(working_list):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    if working_list is not None:
        return [x for x in working_list if x is not None]
    return None


# def get_last_digit(string, debug_mode=True):
#     func_n=inspect.currentframe().f_code.co_name
#     if LTA == 0:
#     # match=re.search(r'\d$', string) # 숫자 1자리를 지우는 코드
#     match=re.search(r'\d{1,2}\b$', string.strip())  # 숫자 1자리 또는 2자리를 지우는 코드
#     if match:
#         return match.group(0)
#     return "00"  # 숫자를 찾지 못한 경우 기본값 "00" 반환


def get_last_digit(prompt):
    # todo : get_front_digit() 도 만드는 게 좋겠다.
    import inspect
    import re

    func_n = inspect.currentframe().f_code.co_name
    match = re.search(r'\d+\b$', prompt.strip())  # 끝에 위치한 모든 연속된 숫자를 찾음
    if match:
        return match.group(0)  # 매칭된 숫자 반환
    return "00"  # 숫자를 찾지 못한 경우 기본값 "00" 반환


def get_str_removed_last_digit(string, debug_mode=True):
    import inspect
    import re
    func_n = inspect.currentframe().f_code.co_name
    return re.sub(r'\d+\s*$', '', string)


def edit_browser_url_like_person():
    import random
    pk_press("ctrl", "l", interval=0.15)
    pk_press("right", interval=0.15)
    write("/")
    pk_sleep(milliseconds=random.randint(a=12, b=23))


def try_solve_cloudflare_sequrity_legacy(driver):  # fail
    import random

    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PKG_PNG
    url = f'https://torrentqq348.com'
    url_decoded = get_str_url_decoded(url)
    pk_print(working_str=rf'''url={url:60s}  url_decoded={url_decoded}  {'%%%FOO%%%' if LTA else ''}''', print_color='blue')
    driver.get(url_decoded)
    # driver.get(url)
    pk_sleep(milliseconds=random.randint(a=222, b=1333))
    try_cnt_limit = 22
    try_cnt = 0
    tab_title_negative = "잠시만 기다리십시오"
    f_png = rf'{D_PKG_PNG}\collect_img_for_autogui_2024_11_03_19_41_12.png'
    while 1:
        if does_normal_tab_exist(driver_selenium=driver, tab_title_negative=tab_title_negative):
            # move to tab
            window_required = driver.current_window_handle  # 현재 창 핸들 저장
            driver.switch_to.window(window_required)
            break
        try_cnt += 1
        if try_cnt == try_cnt_limit:
            kill_tabs_except_current_tab_via_selenium(driver)
            driver.get(url)
            pk_sleep(milliseconds=random.randint(a=1222, b=2333))
            try_cnt = 0

        # click checkbox
        ensure_window_to_front(window_title_seg=tab_title_negative)  # 창을 맨앞으로 가져오기
        pk_sleep(milliseconds=200)
        click_img_via_autogui(f_png, x_cal=random.randint(a=3, b=150))

        # edit url like person
        edit_browser_url_like_person()

        # copy tab
        # copy_tab_like_pserson()
        # open_tab_via_selenium(driver, url)


def click_tag_as_with_tag_text(driver, tag_name, tag_text):
    from pkg_py.pk_colorful_cli_util import pk_print
    from selenium.webdriver.common.by import By
    from selenium.webdriver.common.action_chains import ActionChains
    try:
        h3_element = driver.find_element(By.XPATH, rf"//{tag_name}[text()='{tag_text}']")
        actions = ActionChains(driver)
        actions.move_to_element(h3_element).click().perform()
    except Exception as e:
        pk_print(f'''click {tag_name} tag with text as {tag_text} fail  {'%%%FOO%%%' if LTA else ''}''', print_color='red')


def click_tag_as_with_tag_text_as_new_tab(driver, tag_name, tag_text):
    from selenium.webdriver.common.by import By
    from selenium.webdriver.common.action_chains import ActionChains
    from selenium.webdriver.common.keys import Keys
    try:
        element = driver.find_element(By.XPATH, rf"//{tag_name}[text()='{tag_text}']")

        # 새 탭에서 열기
        actions = ActionChains(driver)
        actions.key_down(Keys.CONTROL).move_to_element(element).click().key_up(Keys.CONTROL).perform()

        # 새 탭으로 전환
        driver.switch_to.window(driver.window_handles[-1])
        print(f"'{tag_text}'가 포함된 {tag_name} 태그를 새 탭에서 열고 전환했습니다.")
    except Exception as e:
        print(f'''{tag_name} 태그(텍스트: {tag_text})를 새 탭에서 여는 데 실패했습니다: {str(e)}''')


def driver_get_url_in_browser(url, driver, seconds_s=2222, seconds_e=4333):
    import random
    from pkg_py.pk_colorful_cli_util import pk_print
    # driver.get(url_decoded)
    url_decoded = get_str_url_decoded(url)
    if url_decoded.startswith(("http://", "https://")):
        pk_print(f'''url_decoded={url_decoded}  {'%%%FOO%%%' if LTA else ''}''')
        driver.get(url_decoded)
    else:
        pk_print(f"WEIRED URL url_decoded={url_decoded}", print_color='red')
    pk_sleep(milliseconds=random.randint(a=seconds_s, b=seconds_e))  # 정적웹소스 다운로드 대기
    # focus 를 새탭으로 이동
    window_handles = driver.window_handles
    driver.switch_to.window(window_handles[-1])


def get_driver_selenium_solved_cloudflare_sequrity(headless_mode=True):
    """
    [ATTEMPTED] cloudflare sequrity challange
    driver.uc_open_with_reconnect(magnet_page_url, reconnect_time=6)
    page_src = driver.page_source
    [SUCCESS] cloudflare sequrity challange
    """
    from seleniumbase import Driver
    driver = Driver(uc=True, headless=headless_mode)
    return driver


# def get_driver_selenium_solved_cloudflare_sequrity(headless_mode=True):
#     import undetected_chromedriver as uc
#     from selenium.webdriver.chrome.service import Service
#     from selenium.webdriver.chrome.options import Options
#     from webdriver_manager.chrome import ChromeDriverManager
#
#     # Chrome 옵션 설정
#     options = Options()
#     if headless_mode:
#         options.add_argument("--headless=new")
#     options.add_argument("--disable-gpu")
#     options.add_argument("--no-sandbox")
#     options.add_argument("--incognito")
#     options.add_argument("--disable-images")
#
#     # 퍼포먼스 로그 활성화 설정
#     capabilities = {
#         "goog:loggingPrefs": {"performance": "ALL"}  # 네트워크 로깅 활성화
#     }
#
#     # 드라이버 생성
#     driver = uc.Chrome(
#         service=Service(ChromeDriverManager().install()),
#         options=options,
#         desired_capabilities=capabilities  # 명시적 설정
#     )
#     return driver


def get_bs4_element_ResultSet(driver, tag_n, class_n=None):
    from bs4 import BeautifulSoup
    soup = BeautifulSoup(driver.page_source, "html.parser")  # web parser 설정
    if tag_n and class_n:
        bs4_element_ResultSet = soup.find_all(tag_n, class_=class_n)
        return bs4_element_ResultSet
    if tag_n:
        bs4_element_ResultSet = soup.find_all(name=tag_n)
        return bs4_element_ResultSet


def open_url_with_reconnect(driver, url, reconnect_time=10, max_retries=3):
    import time
    from selenium.common.exceptions import WebDriverException
    attempt = 0
    while attempt < max_retries:
        try:
            driver.get(url)
            print(f"성공적으로 연결되었습니다: {url}")
            return 1
        except WebDriverException as e:
            attempt += 1
            print(f"연결 실패. 재시도 {attempt}/{max_retries}회, {reconnect_time}초 대기: {e}")
            time.sleep(reconnect_time)
    print(f"최대 재시도 횟수({max_retries}) 초과. 연결 실패.")
    return 0


def get_magnets_set_from_torrent_qq(search_keyword, driver=None):
    try:
        import traceback
        import random
        import re
        from bs4 import BeautifulSoup
        from pkg_py.pk_colorful_cli_util import pk_print
        from colorama import init as pk_colorama_init
        pk_colorama_init(autoreset=True)

        magnet_link_set = set()
        pk_print(f'''search_keyword={search_keyword}  {'%%%FOO%%%' if LTA else ''}''')

        if search_keyword == "":
            pk_print(f"search_keyword is blank")
            return magnet_link_set

        if driver is None:
            # [OPTION]
            driver = get_driver_selenium_solved_cloudflare_sequrity(headless_mode=True)
            # driver = get_driver_selenium_solved_cloudflare_sequrity(headless_mode=False)

        mgt_url = None
        # solve cloudflare sequrity
        url = "https://torrentqq348.com"
        # open_url_with_reconnect(driver=driver, url = url, reconnect_time=10) # fail
        driver.uc_open_with_reconnect(url, reconnect_time=10)
        # driver_get_url_in_browser_and_wait_loaded(url=url, driver=driver) #fail
        driver_get_url_in_browser(url=url, driver=driver, seconds_s=1000, seconds_e=1500)
        body = get_bs4_element_ResultSet(driver=driver, tag_n="body")
        str_negative = '잠시만 기다려'
        if str_negative in body:
            pk_print(f'''cloudflare sequrity  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
            return magnet_link_set

        # search "torrentqq347.com" in browser
        url = f'https://torrentqq356.com/search?q={search_keyword}'
        url_encoded = get_str_encoded_url(str_working=url)
        pk_print(f'''url={url:20}  url_encoded={url_encoded:20} {'%%%FOO%%%' if LTA else ''}''')
        # driver_get_url_in_browser_and_wait_loaded(url=url, driver=driver) #fail
        driver_get_url_in_browser(url=url, driver=driver)  # go to list page
        div_row_at_row = get_bs4_element_ResultSet(driver=driver, tag_n="div", class_n="row at-row")
        # pk_print(f'''div_row_at_row={div_row_at_row}  {'%%%FOO%%%' if LTA else ''}''')

        # move to detail page
        detail_page_link_list = []
        a_tag_list = get_bs4_element_ResultSet(driver=driver, tag_n="a")
        for a_tag_str in a_tag_list:
            title = a_tag_str.get('title')
            href = a_tag_str.get('href')
            if title and href:
                detail_page_link_list.append((title, href))
        keywords_required = search_keyword.split(" ")
        detail_page_link_matched_list = []
        for title, href in detail_page_link_list:
            pk_print(f'''title={title:80s}  href={href}''')
            detail_page_link_matched_list.append((title, href))
        # print_iterable_as_vertical(item_iterable=detail_page_link_list, item_iterable_n="detail_page_link_list")
        if len(detail_page_link_matched_list) == 0:
            pk_print(f'''detail page links not matched  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
            return magnet_link_set
        print_iterable_as_vertical(item_iterable=detail_page_link_matched_list, item_iterable_n="link_matched_list")
        for title, href in detail_page_link_matched_list:
            # driver_get_url_as_browser_tab_via_js(driver, href)
            pk_print(f'''driver.title={driver.title} keywords_required={keywords_required} {'%%%FOO%%%' if LTA else ''}''')
            if not is_all_included_in_prompt(prompt=title, txt_list=keywords_required):
                continue
            driver_get_url_in_browser(url=href, driver=driver)  # go to detail page
            kill_tabs_except_current_tab_via_selenium(driver)
            body = get_bs4_element_ResultSet(driver=driver, tag_n="body")
            string_negative = '잠시만 기다리십시오…torrentqq'
            if string_negative in body:
                pk_print(f'''{string_negative} in bs4_element_ResultSet ''', print_color='red')
                continue
            href_list = []
            title_list = []
            detail_page_link_list = []
            onclick_list = []
            class_list = []
            txt_inner_list = []
            a_tag_list = get_bs4_element_ResultSet(driver=driver, tag_n="a")
            for a_tag_str in a_tag_list:
                title = a_tag_str.get('title')
                href = a_tag_str.get('href')
                onclick = a_tag_str.get('onclick')
                a_class = a_tag_str.get('class')
                txt_inner = a_tag_str.get_text(strip=True)
                title_list.append(title)
                href_list.append(href)
                onclick_list.append(onclick)
                class_list.append(a_class)
                txt_inner_list.append(txt_inner)
                if a_class is not None and "btn-magnet" in a_class and onclick:  # 둘 다 존재할 때만 리스트에 추가
                    detail_page_link_list.append((txt_inner, a_class, onclick))
            search_keyword_without_useless = search_keyword.strip()
            search_keyword_without_useless = search_keyword_without_useless.replace(" > 영화 토렌트", "")
            search_keyword_without_useless = search_keyword_without_useless.replace("영화 토렌트", "")
            search_keyword_without_useless = search_keyword_without_useless.replace("방송 토렌트", "")
            search_keyword_without_useless = search_keyword_without_useless.replace(" - 토렌트큐큐", "")
            # search_keyword_without_useless = search_keyword_without_useless.replace(" - TORRENTQQ","")
            for txt_inner, a_class, onclick in detail_page_link_list:
                mgt_url = driver.current_url
                base_url = get_base_url(mgt_url)
                onclick = onclick
                magnet_path = re.search(r"'(.+?)'", onclick)
                if magnet_path:
                    mgt_url = f"{base_url}{magnet_path.group(1)}"
                    pk_print(f'''mgt_url={mgt_url}  {'%%%FOO%%%' if LTA else ''}''')
                    # driver_get_url_in_browser(url=href, driver=driver)
                    # kill_tabs_except_current_tab_via_selenium(driver)  # 나머지 탭 닫기
                    script_tag_list = get_bs4_element_ResultSet(driver=driver, tag_n="script")
                    for script_tag in script_tag_list:
                        pk_print(f'''script_tag={script_tag}  {'%%%FOO%%%' if LTA else ''}''')
                        if script_tag and "magnet:?" in script_tag.text:
                            magnet_link = script_tag.text.split('"')[1]
                            magnet_url_customed = f"{magnet_link}&dn={search_keyword_without_useless}"
                            pk_print(f'''magnet_url_customed={magnet_url_customed:80s}  {'%%%FOO%%%' if LTA else ''}''')
                            magnet_link_set.add(magnet_url_customed)
                        else:
                            if mgt_url and "/magnet/" in mgt_url:
                                magnet_url_customed = f"{driver.title}&mgt_url={mgt_url}"
                                pk_print(f'''magnet_url_customed={magnet_url_customed}  {'%%%FOO%%%' if LTA else ''}''')
                                magnet_link_set.add(magnet_url_customed)
                            else:
                                pk_print(f'''magnet_link not found''', print_color='red')

                else:
                    pk_print(f'''magnet_link does not exist''', print_color='red')
                break
        print_iterable_as_vertical(item_iterable=magnet_link_set, item_iterable_n="magnet_link_set")

        # debug

        # sleep(hours=1)

        return magnet_link_set
    except:
        traceback.print_exc()
        import sys
        traceback.print_exc(file=sys.stdout)


#
# def download_video_from_yado(title_to_search=None, driver=None, via_f_txt=None): # fail
#     func_n=inspect.currentframe().f_code.co_name
#     f_func_n_txt=rf'{PROJECT_D}\pkg_txt\{func_n}.txt'
#     func_n_back_up_txt=rf'{PROJECT_D}\pkg_txt\{func_n}.txt.bkp'
#
#     # browser_debug_mode=True
#     browser_debug_mode=False
#
#     try:
#         url=""
#         pk_print(f'''url={url}''')
#         # url=get_encoded_url(url)
#         # pk_print(f'''url={url}''')
#
#
#
#         if driver is None:
#             driver=get_driver_selenium(browser_debug_mode=browser_debug_mode)
#
#
#         capabilities=DesiredCapabilities.CHROME
#         capabilities["goog:loggingPrefs"]={"performance": "ALL"}
#
#         driver.get(url)
#
#         # 네트워크 요청 로그 확인
#         # logs=driver.get_log("performance")
#         # for log in logs:
#         #     print(log)
#         # if "m3u8" in log["message"] or "mp4" in log["message"]:
#         #     print(log)
#         # 미디어 m3u9 mp4 없었음
#
#         # 동적생성 미디어 분석
#         html_source=driver.page_source
#         # soup=html_source.replace("><",">%%%개행%%%<")
#         # soup=get_str_url_decoded(soup)
#         # soup_list=soup.split('%%%개행%%%')
#         # print_list_as_vertical(working_list=soup_list, working_list_n='soup_list')
#
#
#         # 네트워크 요청 분석
#         # logs=driver.get_log("performance")
#         # for log in logs:
#         #     message=json.loads(log["message"])
#         #     url=message.get("message", {}).get("params", {}).get("request", {}).get("url", "")
#         #     if ".mp4" in url or ".m3u8" in url:
#         #         print(f"Found Video URL: {url}")
#
#
#         # # 쿠키를 requests에 추가
#         cookies=driver.get_cookies()
#         cookie_dict={cookie['name']: cookie['value'] for cookie in cookies}
#         # session=requests.Session()
#         # for name, value in cookie_dict.items():
#         #     session.cookies.set(name, value)
#         # headers={
#         #     "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
#         #     "Referer": "https://yatv1.com/",  # 필요한 경우 referer 추가
#         #     "Accept-Language": "ko-KR,ko;q=0.9",
#         # }
#         # proxies={
#         #     "http": "http://45.77.0.45:3128",
#         #     "https": "http://45.77.0.45:3128",
#         # }
#         # # response=requests.get(url, headers=headers, proxies=proxies)
#         # response=requests.get(url, headers=headers)
#         # print(response.text)
#
#
#         # session=requests.Session()
#         # for name, value in cookie_dict.items():
#         #     session.cookies.set(name, value)
#         # headers={
#         #     "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
#         #     "Referer": "https://yatv1.com/",  # 필요한 경우 referer 추가
#         #     "Accept-Language": "ko-KR,ko;q=0.9",
#         # }
#         # proxies={
#         #     "http": "http://45.77.0.45:3128",
#         #     "https": "http://45.77.0.45:3128",
#         # }
#         # # response=requests.get(url, headers=headers, proxies=proxies)
#         # response=requests.get(url, headers=headers)
#         # print(response.text)
#
#
#
#
#
#
#
#
#
#
#
#
#
#         # # 네트워크 탭 분석이 필요하면 적절한 대기 추가
#         # video_element=WebDriverWait(driver, 10).until(
#         #     EC.presence_of_element_located((By.TAG_NAME, "video"))
#         # )
#         # m3u8_url=video_element.get_attribute("src")  # m3u8 URL 가져오기
#         # pk_print(str_working="찾은 m3u8 URL:", m3u8_url)
#         # driver.quit()
#
#         page_source=driver.page_source
#         soup=BeautifulSoup(page_source, "html.parser")
#         pk_print(f'''soup="{soup}"  {'%%%FOO%%%' if LTA else ''}''')
#
#         # 게시 날짜와 재생 시간 추출
#         articles=soup.find_all("article", class_="post")
#         for article in articles:
#             post_title=article.find("h3").text.strip()
#             post_date=article.find("div", class_="up").text.strip()
#             play_time=article.find("div", class_="pt").text.strip()
#             print(f"Title: {post_title}, Date: {post_date}, Play Time: {play_time}")
#
#         # 페이지 네비게이션 링크
#         nav_links=soup.find("div", id="navi").find_all("a")
#         for link in nav_links:
#             page_url=link.get("href")
#             print(f"Navigation Link: {page_url}")
#
#         # 태그 추출
#         tags_div=soup.find("div", style="font-size:16px;")
#         if tags_div:
#             tags=[tag.text for tag in tags_div.find_all("a")]
#             print(f"Tags: {tags}")
#
#         # 이미지 태그 검색
#         images=soup.find_all("img", alt=True)
#         for img in images:
#             img_url=img.get("src")
#             alt_text=img.get("alt")
#             print(f"Image Alt: {alt_text}, Image URL: {img_url}")
#
#         # iframe 태그 검색
#         iframe=soup.find("iframe", id="movie")
#         iframe_src=None
#         if iframe:
#             iframe_src=iframe.get("src")
#             decoded_url=get_str_url_decoded(iframe_src)
#             iframe_src=decoded_url
#             print(f"Decoded URL: {decoded_url}")
#             pk_print(f'''iframe_src="{iframe_src}"  {'%%%FOO%%%' if LTA else ''}''')
#         else:
#             pk_print(str_working="Iframe not found.")
#         response=requests.get(iframe_src)
#
#         if response.status_code == 200:
#             pk_print(str_working="Iframe Content Retrieved Successfully")
#             with open(file="iframe_content.html", "w", encoding=Encoding.UTF8.value) as file:
#                 pk_print(f'''response.text="{response.text}"  {'%%%FOO%%%' if LTA else ''}''')
#                 file.write(response.text)
#         else:
#             print(f"Failed to retrieve iframe content: {response.status_code}")
#
#         # # CSV 저장 예제
#         # with open(file="extracted_data.csv", "w", newline="", encoding=Encoding.UTF8.value) as file:
#         #     writer=csv.writer(file)
#         #     writer.writerow(["Title", "Date", "Play Time"])  # 헤더 작성
#         #     for article in articles:
#         #         post_title=article.find("h3").text.strip()
#         #         post_date=article.find("div", class_="up").text.strip()
#         #         play_time=article.find("div", class_="pt").text.strip()
#         #         writer.writerow([post_title, post_date, play_time])
#         # pk_print(str_working="Data saved to extracted_data.csv")
#
#         # file format analye try 1
#         home_dir=os.path.expanduser("~")
#         desktop_dir=os.path.join(home_dir, "Desktop")
#         # file_path=os.path.join(desktop_dir, "00005.shtml")
#         file_path=os.path.join(desktop_dir, "00030.shtml")
#         #
#         # if os.path.exists(file_path):
#         #     file_type=magic.from_file(file_path)
#         #     print(f"f type: {file_type}")
#         # else:
#         #     print(f"f not found: {file_path}")
#
#         # file format analye try 2
#         # def get_file_signature(file_path):
#         #     with open(file=file_path, "rb") as f:
#         #         header=f.read(20)  # 첫 20바이트 읽기
#         #         return header
#         # signature=get_file_signature(file_path)
#         # print(f"f Signature: {signature.hex()}")
#         # with open(file=file_path, "r", encoding=Encoding.UTF8, errors="ignore") as f:
#         #     content=f.read(400)  # 처음 100자 읽기
#         #     print(content)
#
#         # file format analye try 3
#         # with open(file=file_path, "r", encoding="windows-1252", errors="ignore") as f:
#         #     content=f.read()
#         # cleaned_data=re.sub(r"<.*?>", "", content)
#         # result=cleaned_data.encode("windows-1252")
#         # pk_print(f'''result="{result}"  {'%%%FOO%%%' if LTA else ''}''')
#
#         # file format analye try 4
#         # def analyze_file_with_encodings(file_path):
#         #     """
#         #     f을 여러 인코딩으로 분석하여 비교 출력합니다.
#         #     """
#         #     try:
#         #         # f 읽기
#         #         with open(file=file_path, 'rb') as file:
#         #             content=file.read()
#         #
#         #         # f 크기 및 헤더 출력
#         #         file_size=len(content)
#         #         print(f"f 크기: {file_size} 바이트")
#         #         print(f"f 헤더 (16진수): {binascii.hexlify(content[:16])}")
#         #
#         #         # compress 해제 시도 (zlib 사용)
#         #         try:
#         #             decompressed_data=zlib.decompress(content)
#         #             pk_print(str_working="\n[압축 해제 성공]")
#         #             print(decompressed_data[:200].decode('utf-8', errors='ignore'))  # 텍스트로 출력
#         #         except zlib.error:
#         #             pk_print(str_working="\n[압축된 데이터가 아닙니다]")
#         #
#         #         # FFmpeg 관련 문자열 탐색
#         #         if b'FFmpeg' in content:
#         #             pk_print(str_working="\n[FFmpeg 관련 데이터 발견]")
#         #         else:
#         #             pk_print(str_working="\n[FFmpeg 관련 데이터 미발견]")
#         #
#         #         # 다양한 인코딩으로 디코딩 시도
#         #         encodings=['utf-8', 'latin-1', 'cp1252', 'iso-8859-1']
#         #         for encoding in encodings:
#         #             try:
#         #                 decoded_content=content.decode(encoding)
#         #                 print(f"\n[{encoding}] 디코딩 성공: {decoded_content[:500]}")
#         #             except UnicodeDecodeError:
#         #                 print(f"\n[{encoding}] 디코딩 실패")
#         #
#         #         # ASCII 변환 (일부)
#         #         ascii_content=''.join(chr(b) if 32 <= b < 127 else '.' for b in content[:100])
#         #
#         #         # ASCII 변환 (전체)
#         #         # ascii_content=''.join(chr(b) if 32 <= b < 127 else '.' for b in content)
#         #
#         #         pk_print(str_working="\n[ASCII 변환 내용 (전체)]:")
#         #         print(ascii_content)
#         #
#         #     except Exception as e:
#         #         print(f"\nf 분석 중 {e}")
#
#         # exec
#         # file_path=file_path
#         # analyze_file_with_encodings(file_path)
#
#
#
#         browser_debug_mode=True
#         driver=get_driver_selenium(browser_debug_mode=browser_debug_mode)
#
#         # 쿠키를 requests에 추가
#         cookies=driver.get_cookies()
#         cookie_dict={cookie['name']: cookie['value'] for cookie in cookies}
#         session=requests.Session()
#         for name, value in cookie_dict.items():
#             session.cookies.set(name, value)
#         headers={
#             "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
#             "Referer": "https://yatv1.com/",
#             "Accept-Language": "ko-KR,ko;q=0.9",
#         }
#         # proxies={
#         #     "http": "http://45.77.0.45:3128",
#         #     "https": "http://45.77.0.45:3128",
#         # }
#         # response=requests.get(url, headers=headers, proxies=proxies)
#         response=requests.get(url, headers=headers)
#         # print(response.text)
#
#         # session=requests.Session()
#         # for name, value in cookie_dict.items():
#         #     session.cookies.set(name, value)
#         # headers={
#         #     "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
#         #     "Referer": "https://yatv1.com/",  # 필요한 경우 referer 추가
#         #     "Accept-Language": "ko-KR,ko;q=0.9",
#         # }
#         # proxies={
#         #     "http": "http://45.77.0.45:3128",
#         #     "https": "http://45.77.0.45:3128",
#         # }
#         # # response=requests.get(url, headers=headers, proxies=proxies)
#         # response=requests.get(url, headers=headers)
#         # print(response.text)
#
#         def analyze_file_with_encodings(file_path):
#             """
#             f을 여러 인코딩으로 분석하여 비교 출력합니다.
#             """
#             try:
#                 # f 읽기
#                 with open(file=file_path, 'rb') as file:
#                     content=file.read()
#
#                 # f 크기 및 헤더 출력
#                 file_size=len(content)
#                 print(f"f 크기: {file_size} 바이트")
#                 print(f"f 헤더 (16진수): {binascii.hexlify(content[:16])}")
#
#                 # compress 해제 시도 (zlib 사용)
#                 try:
#                     decompressed_data=zlib.decompress(content)
#                     pk_print(str_working="\n[압축 해제 성공]")
#                     print(decompressed_data[:200].decode('utf-8', errors='ignore'))  # 텍스트로 출력
#                 except zlib.error:
#                     pk_print(str_working="\n[압축된 데이터가 아닙니다]")
#
#                 # FFmpeg 관련 문자열 탐색
#                 if b'FFmpeg' in content:
#                     pk_print(str_working="\n[FFmpeg 관련 데이터 발견]")
#                 else:
#                     pk_print(str_working="\n[FFmpeg 관련 데이터 미발견]")
#
#                 # 다양한 인코딩으로 디코딩 시도
#                 encodings=['utf-8', 'latin-1', 'cp1252', 'iso-8859-1']
#                 for encoding in encodings:
#                     try:
#                         decoded_content=content.decode(encoding)
#                         print(f"\n[{encoding}] 디코딩 성공: {decoded_content[:500]}")
#                     except UnicodeDecodeError:
#                         print(f"\n[{encoding}] 디코딩 실패")
#
#                 # ASCII 변환 (일부)
#                 ascii_content=''.join(chr(b) if 32 <= b < 127 else '.' for b in content[:100])
#
#                 # ASCII 변환 (전체)
#                 # ascii_content=''.join(chr(b) if 32 <= b < 127 else '.' for b in content)
#
#                 pk_print(str_working="\n[ASCII 변환 내용 (전체)]:")
#                 print(ascii_content)
#
#             except Exception as e:
#                 print(f"\nf 분석 중 {e}")
#
#         # exec
#         file_path=file_path
#         analyze_file_with_encodings(file_path)
#
#         # file format analye try 3 #fail
#         # output_dir=desktop_dir
#         # start_chunk=5  # 시작 f 번호
#         # end_chunk=43  # 마지막 f 번호
#         #
#         # os.makedirs(output_dir, exist_ok=True)
#         # for i in range(start_chunk, end_chunk + 1):
#         #     chunk_url=f"{base_url}{str(i).zfill(4)}.shtml"  # URL 생성
#         #     chunk_filename=os.path.join(output_dir, f"{str(i).zfill(4)}.ts")
#         #     print(f"Downloading: {chunk_url}")
#         #
#         #     response=requests.get(chunk_url, stream=True)
#         #     if response.status_code == 200:
#         #         with open(file=chunk_filename, "wb") as f:
#         #             f.write(response.content)
#         #     else:
#         #         print(f"Failed to download: {chunk_url}")
#     except:
#         traceback.print_exc(file=sys.stdout)


def is_all_included_in_prompt(prompt, txt_list):
    if all(keyword in prompt for keyword in txt_list):
        return 1
    else:
        return 0


def get_str_encoded_url(str_working):
    import urllib
    from urllib.parse import quote
    return urllib.parse.quote(f"{str_working}")


def get_str_url_decoded(str_working):
    import urllib
    from urllib.parse import quote
    return urllib.parse.unquote(str_working)


def pk_copy(str_working):
    import clipboard
    clipboard.copy(str_working)
    return str_working


def sum_via_txt_f():
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PROJECT
    func_n = inspect.currentframe().f_code.co_name

    f_func_n_txt = rf'{D_PROJECT}\pkg_txt\{func_n}.txt'
    ensure_pnx_made(pnx=f_func_n_txt, mode="f")
    open_pnx_by_ext(f_func_n_txt)

    texts = get_list_from_f(f=f_func_n_txt)
    # texts=texts.split("\n")
    texts = get_list_striped_element(working_list=texts)
    total = 0
    for text in texts:
        if text is not None:
            total += int(text.strip())
    [pk_print(item) for item in texts]
    pk_print(f'''len(texts)={len(texts)}''')
    pk_print(f'''total={total}''')


def get_p(pnx):
    import os
    return rf"{os.path.dirname(pnx)}"


def kill_tabs_except_current_tab_via_selenium(driver):
    current_window = driver.current_window_handle
    for window in driver.window_handles:
        if window != current_window:
            driver.switch_to.window(window)
            # press("ctrl", "w", interval=0.15)
            driver.close()  # 탭 닫기
            pk_sleep(seconds=0.1)
        #     pk_sleep(milliseconds=random.randint(a=22, b=2222))
        # pk_sleep(milliseconds=random.randint(a=22, b=2222))

    driver.switch_to.window(current_window)


def click_img_via_autogui(img, x_cal=0, y_cal=0):
    from pkg_py.pk_colorful_cli_util import pk_print
    import pyautogui
    # confidence=0.7(70%)유사도를 낮춰 인식률개선시도, region 낮춰 속도개선시도, grayscale 흑백으로 판단해서 속도개선시도,

    # 이미지중앙좌표 클릭
    img_finding_loop_cnt = 0
    img_finding_loop_cnt_limit = 10
    while 1:
        img_finding_loop_cnt = img_finding_loop_cnt + 1
        try:
            x, y = pyautogui.locateCenterOnScreen(image=img, confidence=0.7, grayscale=True)
        except pyautogui.ImageNotFoundException:
            pk_print(rf"이미지찾기", print_color='red')
            # pk_print(f"{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}", print_color='red')
            break
        if x is not None and y is not None:
            x_cal = x_cal
            y_cal = y_cal
            x = x - x_cal
            y = y - y_cal

            # 마우스위치 기록
            initial_position = pyautogui.position()

            duration = 1
            move_mouse(x_abs=x, y_abs=y, duration=duration)
            pyautogui.click()

            # 마우스위치 원복
            x, y = initial_position
            duration = 0
            move_mouse(x_abs=x, y_abs=y, duration=duration)
            # pk_print(rf"이미지중앙좌표클릭 ({x}, {y})  {'%%%FOO%%%' if LTA else ''}", print_color='green')
            break

        pk_print(f'''이미지중앙좌표클릭  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        if img_finding_loop_cnt == img_finding_loop_cnt_limit:
            pk_print(f'''이미지중앙좌표클릭  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
            break


def driver_get_url_as_browser_tab_via_js(driver, url):
    driver.execute_script(rf"window.open('{url}', '_blank');")
    # new_window = [window for window in driver.window_handles if window != original_window][0]
    # driver.switch_to.window(new_window)  # move to magnets btn page
    kill_tabs_except_current_tab_via_selenium(driver)  # 나머지 탭 닫기


def copy_tab_like_pserson():
    import random
    pk_press("ctrl", "l", interval=0.15)
    pk_sleep(milliseconds=random.randint(a=12, b=23))
    pk_press("alt", "shift", "enter", interval=0.15)
    # pk_print(f" {'%%%FOO%%%' if LTA else ''} green 새탭복사")


def get_base_url(url):
    from urllib.parse import urlparse
    parsed_url = urlparse(url)
    base_url = f"{parsed_url.scheme}://{parsed_url.netloc}"
    return base_url


# def print_list_as_horizontal(items, items_name):
#     from pkg_py.pk_colorful_cli_util import pk_print
#     for name, value in locals().items():
#         if value == items:
#             pk_print(f'''{items_name}={value}''')


# def pnxs_classify_to_pkg_extensions_via_hard_coded():
#
#     pnx=rf'D:\#기타\pkg_files'
#
#     # pnx_todo가 유효한 d인지 확인
#     if is_file(pnx=pnx):
#         pk_print(f"{pnx} 는 정리할 수 있는 d가 아닙니다")
#         return
#
#     # f과 d get
#     txt_to_exclude_list=[
#         DB_YAML,
#         SUCCESS_LOG,
#         LOCAL_PKG_CACHE_FILE,
#     ]
#     d_list, f_list=get_sub_pnxs_without_walking(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list)
#     # d_list, f_list=get_sub_pnxs_with_walking(pnx=pnx, txt_to_exclude_list= txt_to_exclude_list)
#
#     # f 처리
#     for f in f_list:
#         f=f[0]
#         file_p=get_p(f)
#         file_x=get_x(f).replace(".", "")
#         pkg_ext=rf"{file_p}\pkg_{file_x}"
#         make_pnx(pkg_ext, mode="d")
#         move_pnx_without_overwrite(src=f, dst=pkg_ext)
#         pk_print(str_working=rf'''f="{f}"  {'%%%FOO%%%' if LTA else ''}''')
#
#     # d 처리
#     # for dir_pnx in d_list:
#     #     dir_pnx=dir_pnx[0]
#     #     dir_p=get_p(dir_pnx)
#     #     pkg_ext=rf"{dir_p}\pkg_d"
#     #     make_pnx(pkg_ext, target_mode="d")
#     #     move_pnx_without_overwrite(pnx=dir_pnx, dst=pkg_ext)
#     #     pk_print(str_working=rf'''dir_pnx="{dir_pnx}"  {'%%%FOO%%%' if LTA else ''}''')


def get_f_current_n():
    import os
    return os.path.basename(__file__)


def print_class_field_and_value(class_n):  # print 보다는 get 으로 바꾸는게 좋겠다.

    from pkg_py.pk_colorful_cli_util import pk_print
    cmd_usage_explanations = []
    cmd_usage_explanations.append(title)
    cmd_usage_explanations.append('\n')
    cmd_usage_explanations.append('<예시> : python console_blurred.py <mode_option>')
    cmd_usage_explanations.append('\n')
    longest_field = max(vars(class_n), key=len)  # mkr_get_longest_field_name
    longest_value = vars(class_n)[longest_field]  # mkr_get_longest_field_value
    for key, value in class_n.__dict__.items():  # mkr_get_field_name_and_field_value
        if not key.startswith('__'):  # 내장 속성 제외
            cmd_usage_explanations.append(f"{key}{" " * (len(longest_field) - len(key))}: {value}")
    cmd_usage_explanations.append('\n')
    for cmd_usage_explanation in cmd_usage_explanations:
        pk_print(working_str=cmd_usage_explanation)
    cmd_usage_explanations.append('\n')


def pk_deprecated_get_d_current_n_like_person():
    texts_removed_duplicated_element = []
    current_d = cmd_to_os_like_person_as_admin(rf'echo %cd%')
    for text in current_d:  # remove_duplication
        if text not in texts_removed_duplicated_element:
            if text is not None:
                texts_removed_duplicated_element.append(text)
    current_d = texts_removed_duplicated_element
    current_d = [item.strip() for item in current_d]  # strip_list_element_each
    current_d = [item for item in current_d if item and item.strip()]
    current_d = " ".join(current_d)  # convert_from_list_to_str
    return current_d


def classify_pnx_list_to_pn_dir(d_working):
    import os
    from pkg_py.pk_colorful_cli_util import pk_print
    for pnx_nx in os.listdir(d_working):
        pnx_item = os.path.join(d_working, pnx_nx)
        if is_f(pnx_item):
            pk_print(f'''pnx_item={pnx_item}''')
            f_n_d = os.path.join(d_working, pnx_nx)
            f_n_d_pn = get_pn(f_n_d)

            if not os.path.exists(f_n_d_pn):
                os.makedirs(f_n_d_pn)

            # shutil.move(pnx_item, f_n_d_pn) # 중복있으면 에러로 처리됨
            move_pnx(pnx=pnx_item, d_dst=f_n_d_pn)  # 중복있으면 timestamp를 붙여 이동됨


def get_window_opened_list():
    # return get_windows_opened_via_psutil()
    # return get_windows_opened_via_pygetwindow()
    return get_windows_opened_via_win32gui()


def get_windows_opened_via_win32gui():
    import win32gui  # pywin32
    window_titles = []

    def enum_windows_callback(hwnd, lparam):
        if win32gui.IsWindowVisible(hwnd):
            # 창의 제목을 가져와서 리스트에 추가
            window_title = win32gui.GetWindowText(hwnd)
            if window_title:  # 제목이 비어있지 않은 창만 추가
                window_titles.append(window_title)

    win32gui.EnumWindows(enum_windows_callback, None)
    return window_titles


# def get_windows_opened_via_psutil():
#     process_names=[]
#     for proc in psutil.process_iter(['pid', 'name']):
#         try:
#             process_names.append(proc.info['name'])  # proc.info 없는데?
#         except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
#             pass
#     return process_names

def get_windows_opened_via_pygetwindow():
    import pygetwindow
    windows = pygetwindow.getAllTitles()
    return windows


def is_front_window_title(window_title_seg):
    if not get_front_window_title() is None:
        if window_title_seg in get_front_window_title():
            return 1
    return 0


def is_window_opened(window_title_seg):
    windows_titles_opened = get_window_opened_list()
    windows_titles_opened = get_list_without_none(working_list=windows_titles_opened)

    # print_list_as_vertical(working_list=windows_titles_opened,working_list_n="windows_titles_opened")

    for windows_title_opened in windows_titles_opened:
        if window_title_seg in windows_title_opened:
            # pk_print(f'''{windows_title_opened}" 창이 열려 있습니다''')
            return 1
    # pk_print(f'''{window_title_seg}" 창이 닫혀 있습니다''')
    return 0


def is_window_title_opened(window_title):
    from pkg_py.pk_colorful_cli_util import pk_print
    window_titles_opened = get_window_opened_list()
    window_titles_opened = get_list_without_none(working_list=window_titles_opened)
    for window_title_opened in window_titles_opened:
        if window_title != window_title_opened:
            continue
        if window_title == window_title_opened:
            if LTA:
                pk_print(f'''window_title={window_title}  {'%%%FOO%%%' if LTA else ''}''')
                pk_print(f'''window_title_opened={window_title_opened}  {'%%%FOO%%%' if LTA else ''}''')
            return 1
    return 0


def is_window_open_via_pygetwindow(window_title):
    import pygetwindow
    windows = pygetwindow.getAllTitles()  # 모든 열린 창들의 제목을 가져옴
    return window_title in windows  # 특정 창이 열려 있는지 확인


def is_window_open_via_win32gui(window_title):
    import win32gui  # pywin32
    def enum_windows_callback(hwnd, lparam):
        if win32gui.IsWindowVisible(hwnd):
            # 창의 제목을 확인
            if window_title in win32gui.GetWindowText(hwnd):
                # pk_print(f'''{win32gui.GetWindowText(hwnd)}"''')
                lparam.append(hwnd)

    # 열린 창들을 확인
    hwnd_list = []
    win32gui.EnumWindows(enum_windows_callback, hwnd_list)

    # 특정 창이 열려 있는지 확인
    return any(window_title in win32gui.GetWindowText(hwnd) for hwnd in hwnd_list)


def window_kill_by_title(window_title):
    kill_window_by_title_via_wind32con(window_title)


def kill_window_by_title_via_wind32con(window_title):
    import traceback
    import win32con  # pywin32
    import win32gui  # pywin32
    from pkg_py.pk_colorful_cli_util import pk_print
    def enum_windows_callback(hwnd, lparam):
        try:
            if win32gui.IsWindowVisible(hwnd):
                current_window_title = win32gui.GetWindowText(hwnd)
                if current_window_title == window_title:
                    win32gui.PostMessage(hwnd, win32con.WM_CLOSE, 0, 0)
                    pk_print(f'close window ({window_title})', print_color='blue')
                    return 0  # 창을 찾았으면 더 이상 탐색하지 않음
        except:
            pk_print(f"{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}", print_color='red')
        return 1  # 계속 탐색

    try:
        # 모든 창을 탐색하여 해당 제목을 찾음
        win32gui.EnumWindows(enum_windows_callback, None)
    except:
        pk_print(f"{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}", print_color='red')


def get_window_title_list(process_img_n=None):
    # @pk_measure_seconds 0.000 passed at 250413
    import traceback
    import win32gui  # pywin32
    import win32process
    from pkg_py.pk_colorful_cli_util import pk_print
    import psutil
    if process_img_n is not None:
        titles = []

        # 프로세스 목록에서 이름으로 PID 찾기
        pids = [p.info['pid'] for p in psutil.process_iter(['name', 'pid']) if p.info['name'] == process_img_n]
        if LTA:
            pk_print(f"Found PIDs : '{process_img_n}': {pids}")

        if not pids:
            pk_print(f"Process '{process_img_n}' not found.")
            return titles

        # PID에 연결된 창 검색
        def enum_windows_callback(hwnd, pids):
            _, found_pid = win32process.GetWindowThreadProcessId(hwnd)
            if found_pid in pids:
                title = win32gui.GetWindowText(hwnd)
                if title:  # 제목이 있는 창만 추가
                    titles.append(title)

        for pid in pids:
            win32gui.EnumWindows(enum_windows_callback, [pid])
        if LTA:
            print(f"Window titles for process '{process_img_n}': {titles}")
        return titles
    if process_img_n is None:
        window_titles = []
        try:
            def enum_windows_callback(hwnd, lparam):
                if win32gui.IsWindowVisible(hwnd):
                    current_window_title = win32gui.GetWindowText(hwnd)
                    if current_window_title:  # 제목이 비어 있지 않은 경우에만 추가
                        window_titles.append(current_window_title)
                return 1  # 계속해서 다른 창들도 검색

            win32gui.EnumWindows(enum_windows_callback, None)
        except Exception as e:
            pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')

        return window_titles


def pk_print_and_speak(str_working, print_color='blue', after_delay=1.00):
    from pkg_py.pk_colorful_cli_util import pk_print
    pk_print(working_str=str_working, print_color=print_color)
    try:
        pk_speak(working_str=str_working, after_delay=after_delay)
    except:
        raise


def classify_pnx_list_to_d_special_keyword(d_src, with_walking):
    from pkg_py.pk_core_constants import D_PKG_TXT
    f = rf'{D_PKG_TXT}/collect_magnets_from_nyaa_si.txt'
    special_keywords_from_f_txt = get_list_from_f(f=f)
    special_keywords_from_f_txt = get_list_removed_element_contain_prompt(working_list=special_keywords_from_f_txt, prompt="#")
    # special_keywords_from_f_txt = get_list_replaced_element_from_str_to_str(working_list=special_keywords_from_f_txt, from_str='\n', to_str='')
    special_keywords_from_f_txt = get_list_striped_element(working_list=special_keywords_from_f_txt)
    special_keywords_from_f_txt = get_list_deduplicated(working_list=special_keywords_from_f_txt)
    special_keywords_from_f_txt = get_list_removed_element_empty(working_list=special_keywords_from_f_txt)
    special_keywords_from_f_txt = get_list_without_none(working_list=special_keywords_from_f_txt)
    special_keywords = [  # special_keywords는 텍스트의 길이가 길수록 분류가 잘될 확률이 높다
                           "[]",
                       ] + special_keywords_from_f_txt
    for special_keyword in special_keywords:
        classify_pnx_by_special_keyword(d_src=d_src, special_keyword=special_keyword, with_walking=with_walking)


def get_sub_pnx_list(pnx, txt_to_exclude_list=None, with_walking=1):
    import os
    txt_to_exclude_list = txt_to_exclude_list or []
    if with_walking == 1:
        d_list = []
        f_list = []
        # 모든 하위 검색
        for root, d_nx_list, f_nx_list in os.walk(pnx):
            for d_nx in d_nx_list:
                item_pnx = os.path.join(root, d_nx)
                if is_d(item_pnx):
                    for txt_to_exclude in txt_to_exclude_list:
                        if txt_to_exclude in item_pnx:
                            break  # d에 제외할 문자열이 있으면 추가하지 않음
                    else:
                        d_list.append([item_pnx, os.path.getmtime(item_pnx)])

            for f_nx in f_nx_list:
                item_pnx = os.path.join(root, f_nx)
                for txt_to_exclude in txt_to_exclude_list:
                    if txt_to_exclude in item_pnx:
                        break  # f 경로에 제외할 문자열이 있으면 추가하지 않음
                else:
                    f_list.append([item_pnx, os.path.getmtime(item_pnx)])
        return d_list, f_list
    elif with_walking == 0:
        import os

        d_list = []
        f_list = []

        # 현재 d만 순회
        for item in os.listdir(pnx):
            item_pnx = os.path.join(pnx, item)
            # d인 경우
            if is_d(item_pnx):
                for txt_to_exclude in txt_to_exclude_list:
                    if txt_to_exclude in item_pnx:
                        break  # d에 제외할 문자열이 있으면 추가하지 않음
                else:
                    d_list.append([item_pnx, os.path.getmtime(item_pnx)])

            # f인 경우
            if is_f(item_pnx):
                for txt_to_exclude in txt_to_exclude_list:
                    if txt_to_exclude in item_pnx:
                        break  # f 경로에 제외할 문자열이 있으면 추가하지 않음
                else:
                    # f 경로에 제외할 문자열이 없다면 f_list에 추가
                    # pk_print(str_working=rf'''item_pnx       ="{item_pnx}"  {'%%%FOO%%%' if LTA else ''}''')
                    # pk_print(str_working=rf'''txt_to_exclude="{txt_to_exclude}"  {'%%%FOO%%%' if LTA else ''}''')
                    f_list.append([item_pnx, os.path.getmtime(item_pnx)])

        # print_list_as_vertical(texts=d_list, list_name='d_list')
        # print_list_as_vertical(texts=f_list, list_name='f_list')

        return d_list, f_list


def rename_pnxs(pnx_list):
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    for pnx in pnx_list:
        try:
            src = pnx[0]
            pnx_new = pnx[1]
            rename_pnx(src=src, pnx_new=pnx_new)
        except:
            pk_print(f"{traceback.format_exc()}", print_color='red')


def rename_pnxs_from_keywords_to_keyword_new_at_d(d, mode, with_walking, debug_mode=True):
    import inspect
    import re
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_LOCAL_PKG_CACHE, F_SUCCESS_LOG, F_DB_YAML
    func_n = inspect.currentframe().f_code.co_name

    txt_to_exclude_list = [
        F_DB_YAML,
        F_SUCCESS_LOG,
        F_LOCAL_PKG_CACHE,
    ]

    d_list = None
    working_list = None
    if with_walking == True:
        d_list, working_list = get_sub_pnx_list(pnx=d, txt_to_exclude_list=txt_to_exclude_list)
    else:
        d_list, working_list = get_sub_pnx_list(pnx=d, txt_to_exclude_list=txt_to_exclude_list, without_walking=0)

    if mode == "f":
        pnxs = working_list
    elif mode == "d":
        pnxs = d_list
    else:
        pk_print(working_str=rf'''mode={mode}  {'%%%FOO%%%' if LTA else ''}''')
        return

    # pnxs에 "System Volume Information" 있으면 제외
    keywords_remove_pnxs_unnecessary = [
        "System Volume Information",
        "$RECYCLE.BIN",
    ]

    from pkg_py.pk_core_constants import D_PKG_TXT
    working_list = get_list_from_f(f=rf'{D_PKG_TXT}\collect_magnets_from_nyaa_si.txt')
    working_list = get_list_removed_element_contain_prompt(working_list=working_list, prompt="#")
    working_list = get_list_deduplicated(working_list=working_list)
    working_list = get_list_removed_element_empty(working_list=working_list)
    working_list = get_list_striped_element(working_list=working_list)
    pattern = re.compile(r"(\[.*?\])\s*(.*)")
    # filtered_list = []
    duplicated_stamp_list: list[tuple[str, str]] = []
    stamp_title_list: list[tuple[str, str]] = []
    for item in working_list:
        match = pattern.match(item)
        if match:
            # filtered_list.append((match.group(1), match.group(2)))
            stamp = match.group(1).strip()
            title = match.group(2).strip()
            if title != "":
                title_with_stamp = rf"{stamp} {title}"
                stamp_title_list.append((title, title_with_stamp))

            duplicated_stamp = rf"{stamp} {stamp}"
            duplicated_stamp_list.append((duplicated_stamp, stamp))

    duplicated_stamp_list = get_list_deduplicated(working_list=duplicated_stamp_list)

    keywords = [
                   # '_.. ', # referece : . 으로 끝나는 것 안된다.
                   # '"', # referece : 한글자 는 매우 유의해야한다.

                   # from x to ''
                   # ('_____', ''),
                   ('[jhp##]', ''),
                   ('[시작문자]', ''),
                   ('[끝문자]', ''),
                   ('[중복문자]', ''),

                   # from x to '_'
                   # ('_____', '_'),
                   ('[Multiple Subtitle]', '_'),
                   ('[1080p]', '_'),
                   ('[ x265-10Bit Ver_]', '_'),
                   (' - TV + SP', '_'),
                   ('RARBG', '_'), ('H264-3Li', '_'), ('_.UHD_.x264', '_'), ('_.x264-ORBS[rarbg]', '_'), ('_.NF_DDP5.1.x264-AO', '_'), ('.x264.DTS-WAF', '_'), ('.PORTUGUESE_VXT', '_'), ('_.x264-CM', '_'), ('_x265-', '_'), ('.ORIGINAL.UNRATED.CUT', '_'), ('_x265-', '_'), ('_-LCHD', '_'),
                   ('[5.1]', '_'),
                   (' dvdscr whd ', '_'), ('dvdrip', '_'), ('_H264.AAC', '_'), ('.iNTERNAL_-XME', '_'),
                   ('10bit.HDR.DV_.8CH.x265.HEVC-PSA', '_'),
                   ('Our.Blues.', '우리들의 블루스'),
                   ('.KOR.', '[한국]'), ('.KOR.FHDRip.H264.AAC-RTM', '_'), ('.10bit_6CH.x265.HEVC-PSA', '_'), ('_.NF_DDP5.1.x264-NTG', '_'), ('_.DTS-SWTYBLZ', '_'), ('_.H264.AAC-VXT', '_'), ('(_10bit Tigole)', '_'), ('WEB-DL.XviD.AC3-FGT', '_'), ('_.H264.AAC-VXT', '_'), ('.Remux.DTS-HD.5.1', '_'),
                   ('.10bit_6CH.x265.HEVC-PSA', '_'), ('.AAC.5.1', '_'), ('AAC.5.1-POOP', '_'), ('_DD5.1', '_'),
                   ('_.AAC-Hon3y', '_'), ('.NF_DD5.1.x264-SiGMA', '_'), ('_HEVC_EAC3 5.1 Silence', '_'), ('.1080p_H265.AAC-RGB', '_'), ('_H265.AAC-RGB', '_'), ('.DUBBED.', '_'), ('.1080p_x265-VXT', '_'), ('ENSUBBED', '_'), ('1080p_.x264', '_'), ('1080p _ x264', '_'), (' _ _ ', '_'),
                   ('[YTS.AM]', '_'),
                   ('.2018.1080p', '[2018]'), ('.2018.', '[2018]'), ('.x265-VXT', '_'), ('.x265-', '_'),
                   ('_.bit_.ch.x_psa_', '_'), ('BluRay', '_'), ('_x264-', '_'), ('x264-SPARKS', '_'), ('BluRay_HEVC_HDR AAC 7.1 Tigole', '_'), ('pkg_movie_horor', '[호러영화]'),
                   ('pkg_movie_image', '[영화이미지]'), ('pkg_movie_korean', '[한국영화]'), ('pkg_movie_marvel_and_dc', '[marvel dc]'), ('pkg_movie_space', '[우주영화]'), ('pkg_sound', '[영화사운드]'), ('x264-HANDJOB', '_'),
                   (' x265 ', '_'), (' HEVC ', '_'), (' 10bit ', '_'), (' EAC3 5.1 ', '_'), ('WEBRip.x264-RARBG', '_'), ('WEB-DL.DD5.1.H264-FGT', '_'), ('KORSUB', '_'), ('DTS-FGT', '_'), ('BluRay.x265-RARBG', '_'), ('#_movie_ #', '_'), ('[FOXM.TO]', '_'), ('[WEBRip]', '_'), ('[YTS.MX]', '_'),
                   ('[720p]', '_'),
                   ('[1080p]', '_'), ('[BluRay]', '_'), ('DTS-JYK', '_'), ('RARBG', '_'), ('BRRip', '_'),
                   ('.SPANISH.', '_'), ('.WEBRip.', '_'), ('-RARBG', '_'), ('[BLURAY]', '_'),
                   ('.BluRay.x265-RARBG', '_'), ('BluRay.H264.AAC-RARBG', '_'), ('KORSUB.WEBRip.H264.AAC', '_'),
                   ('.KOR.HDTC.H264.AAC_', '_'), ('y2meta.com', '_'), ('[YTS.AG]', '_'), ('[4K] _ [5.1]', '_'), ('.WEB.AMZ_.AVC.DD5.1.x264-PANAM', '_'),
                   ('1080p.KORSUB.WEBRip.H264.AAC', '_'),
                   ('(1080p BluRay x265 RZeroX)', '_'),

                   # from x to y
                   # ('_____', '_____'),
                   ('_Toaru_Majutsu_no_Index_', 'Toaru Majutsu no Index'),
                   ('To Aru Kagaku', 'Toaru Kagaku'), ('To Aru Majutsu', 'Toaru Majutsu'),
                   ('[UTW-Mazui]', 'pk_ani'), ('[SubsPlease]', 'pk_ani'), ('[Erai-raws]', 'pk_ani'), ('[Judas]', 'pk_ani'), ('[UTW-Mazui]', 'pk_ani'),
                   ('pk_ani', 'pk_ani '),  # todo : 추후삭제
                   ('pk_ani  ', 'pk_ani '),  # todo : 추후삭제
                   ('청설 Hear Me Our Summer, 2024', 'pk_movie 청설'),
                   ('pk_movie pk_movie', 'pk_movie'),
                   ('헨리', '(Henry)'),
                   ('The.Way.of.the.Househusband.', '극주부도 '),
                   ('극주부도', 'gokushufudo'),
                   ('크레이븐 더 헌터 Kraven the Hunter ,2024', '[마블영화]Kraven the Hunter 2024'), ('아메바 소녀들과 학교괴담 개교기념일 ,2024', '아메바 소녀들과 학교괴담 개교기념일 2024'),
                   ('아마존 활명수 Amazon Bullseye, 2024', '아마존 활명수 2024'), ('스콜피온 킹 The Scorpion King, 2002', 'Scorpion King 2002'),
                   ('브리드 Breathe, 2024.720p', 'Breathe 2024'),
                   ('정글의 법칙', '정글의_법칙'), ('정글의_법칙', '정글의법칙'),
                   ('로멘틱', '로맨틱'), ('로맨틱 이탈리아', '로맨틱이탈리아'),
                   ('[SEOA]', '[서아]'),
                   ('텐트 밖은 유럽', '텐트밖은유럽'),
                   ('Strange.Darling.2023', 'Strange Darling 2023'),
                   ('Crayon.Shinchan', 'Crayon Shinchan'),
                   ('공포의 기억 The Beast Within ,2024', 'The Beast Within 2024'),
                   ('A Herbivorous Dragon of 5000 Years Gets Unfairly Villainized', 'Yowai 5000-nen no Soushoku Dragon Iwarenaki Jaryuu Nintei'),
                   ('Meg.2.The.Trench.', 'Meg 2 The Trench'), ('[중복문자][중복문자][중복문자]', '[중복문자]'),
                   ('[중복문자][중복문자]', '[중복문자]'), (' 720p ', '[720p]'), ('The.', 'The '),  # The.mp3 라면 The mp3 가 되어 버려 문제가 될 우려가 됨
                   ('movie_ ', '영화'), ('.kra mvi ', '[한국영화]'), ('.kra mvi,', '[한국영화]'), ('포드 v 페라리', 'ford v ferrari'),
                   ('1080p', '[1080p]'), ('PMC 더 벙커 Take Point', '더 벙커[한국영화]'), ('.CHINESE.', '[중국]'), ('.JAPANESE.', '[일본]'), ('공포_movie', '[공포영화]'), ('_movie_', '_영화_'), ('[한국_movie_]', '[한국영화]'), ('[공포_movie_]', '[공포영화]'), ('kra mvi, ', '[한국영화]'), ('#일본_movie_', '[일본영화]'),
                   ('문경.2024', '문경 2024'),
                   # ('www.btranking.top - 최초배포', 'www.btranking.top - 최초배포.url'), # . 이 f명에 2개 있는 경우에 이동되지 않는데, 이동되도록 처리시도
                   # ('www.btranking.top - 최초배포.url.url', 'www.btranking.top - 최초배포.url'),# . 이 f명에 2개 있는 경우에 이동되지 않는데, 이동되도록 처리시도
                   # ('[TGx]Downloaded from torrentgalaxy.to .txt', '[TGx]Downloaded from torrentgalaxy_to .txt'),# . 이 f명에 2개 있는 경우에 이동되지 않는데, 이동되도록 처리시도
                   ('베놈 라스트 댄스', 'Venom The Last Dance'), ('Jeongnyeon The Star is Born', '정년이'), ('정년이.정년이', '정년이'), ('Mungyeong.More.than.Roads', '문경'), ('#2023 #', '[PARK]'),
                   ('#2025 #', '[PARK]'), ('#2024 #', '[PARK]'), ('#2024 ', '[PARK]'), ('#영화  ', '[PARK]'), ('#예능 ', '[PARK]'), ('#[PARK]', '[PARK]'), ('바운디', ' Vaundy'), ('mkr_', '[PARK]'), ('#노래 #', '[PARK]'), ('_tvN_', '_'),
                   ('[Utaite_ sound ]', '[utaite]'), ('[Piano_Music]', '[piano]'), ('순수음성', '[순수음성]'), ('``', '[PARK]'), ('[PARK]음악[PARK]', '[PARK]'), ('[PARK]', ' [PARK] '), ('[PARK]', ' '), ('. ', '_'), ('.___', '_'), ('._', '_'), ('     ', ' '), ('    ', ' '), ('   ', ' '), ('  ', ' '),
                   ('______', '_'),
                   ('_____', '_'), ('____', '_'), ('___', '_'), ('__', '_'), ('2024.720p.WEBRip.H264.AAC', '[PARK]'),
                   ('`marvel `hero`', '[marvel]'), ('로키 시즌2', 'Loki 2'), ('왓 이프', 'what if'),
                   ('애니메이션', ' pk_ani'), ('애니', ' pk_ani'),
                   ('사진', '이미지'), ('이미지', '이미지'), ('그림', '이미지'), ('스샷', '이미지'), ('[우주_영화_]', '[우주영화]'), ('[일본_영화_]', '[일본영화]'), ('#일본 _movie', '[일본영화]'), ('[한국_영화_]', '[한국영화]'), ('Harry_Potter', 'Harry Potter'), ('music', ' sound '), ('sing', ' sound '), ('song', ' sound '),
                   ('``눈물', ' [눈물] '), ('언리얼 엔진', ' unreal engine '), ('언리얼엔진', ' unreal engine '), ('언리얼5', ' unreal engine 5'),
                   ('언리얼 5', ' unreal engine 5'), ('緑黄色社会', '녹황색시사회'), ('_kra_', '[korea]'), ('_jpn_', '[japan]'), ('``음악``', ' sound '), ('[고음질]', '_'),
                   ('【 ', '['), ('】 ', ']'), ('【 ', '['), ('】 ', ']'), ('( ', '['), ('『 ', '['), ('」 ', ']'), ('《 ', '['), ('》 ', ']'),
                   ('[𝙇𝙤𝙤𝙠𝘽𝙤𝙤𝙠]', '[룩북]'), ('LOOKBOOK', '[룩북]'),
                   # 일본어 & 로마자소리 맵핑
                   # 순서가 요음 먼저 맵핑해야함
                   # 히라가나 요음
                   ("きゃ", "kya"), ("きゅ", "kyu"), ("きょ", "kyo"), ("しゃ", "sha"), ("しゅ", "shu"), ("しょ", "sho"), ("ちゃ", "cha"), ("ちゅ", "chu"), ("ちょ", "cho"), ("にゃ", "nya"), ("にゅ", "nyu"), ("にょ", "nyo"), ("ひゃ", "hya"), ("ひゅ", "hyu"), ("ひょ", "hyo"), ("みゃ", "mya"),
                   ("みゅ", "myu"),
                   ("みょ", "myo"), ("りゃ", "rya"), ("りゅ", "ryu"), ("りょ", "ryo"), ("ぎゃ", "gya"),
                   ("ぎゅ", "gyu"), ("ぎょ", "gyo"), ("じゃ", "ja"), ("じゅ", "ju"), ("じょ", "jo"), ("びゃ", "bya"), ("びゅ", "byu"), ("びょ", "byo"), ("ぴゃ", "pya"), ("ぴゅ", "pyu"), ("ぴょ", "pyo"),
                   # 히라가나 모음 # k행  s행  t행  n행  h행  m행  y행  r행  w행
                   ("あ", "a"), ("い", "i"), ("う", "u"), ("え", "e"), ("お", "o"), ("か", "ka"), ("き", "ki"), ("く", "ku"), ("け", "ke"), ("こ", "ko"), ("さ", "sa"), ("し", "shi"), ("す", "su"), ("せ", "se"), ("そ", "so"), ("た", "ta"), ("ち", "chi"), ("つ", "tsu"), ("て", "te"), ("と", "to"),
                   ("な", "na"), ("に", "ni"), ("ぬ", "nu"), ("ね", "ne"), ("の", "no"), ("は", "ha"), ("ひ", "hi"),
                   ("ふ", "fu"), ("へ", "he"), ("ほ", "ho"), ("ま", "ma"), ("み", "mi"), ("む", "mu"), ("め", "me"), ("も", "mo"), ("や", "ya"), ("ゆ", "yu"), ("よ", "yo"), ("ら", "ra"), ("り", "ri"), ("る", "ru"), ("れ", "re"), ("ろ", "ro"), ("わ", "wa"), ("を", "wo"),
                   ("ん", "n"),  # 히라가나 특수
                   # 가타가나 요음
                   ("キャ", "kya"), ("キュ", "kyu"), ("キョ", "kyo"), ("シャ", "sha"), ("シュ", "shu"), ("ショ", "sho"), ("チャ", "cha"), ("チュ", "chu"), ("チョ", "cho"), ("ニャ", "nya"), ("ニュ", "nyu"), ("ニョ", "nyo"), ("ヒャ", "hya"), ("ヒュ", "hyu"), ("ヒョ", "hyo"), ("ミャ", "mya"),
                   ("ミュ", "myu"),
                   ("ミョ", "myo"), ("リャ", "rya"), ("リュ", "ryu"), ("リョ", "ryo"), ("ギャ", "gya"),
                   ("ギュ", "gyu"), ("ギョ", "gyo"), ("ジャ", "ja"), ("ジュ", "ju"), ("ジョ", "jo"), ("ビャ", "bya"), ("ビュ", "byu"), ("ビョ", "byo"), ("ピャ", "pya"), ("ピュ", "pyu"), ("ピョ", "pyo"), ('ア', 'a'), ('イ', 'i'), ('ウ', 'u'), ('エ', 'e'), ('オ', 'o'), ('カ', 'ka'), ('キ', 'ki'),
                   ('ク', 'ku'), ('ケ', 'ke'), ('コ', 'ko'), ('サ', 'sa'), ('シ', 'shi'), ('ス', 'su'), ('セ', 'se'),
                   ('ソ', 'so'), ('タ', 'ta'), ('チ', 'chi'), ('ツ', 'tsu'), ('テ', 'te'), ('ト', 'to'), ('ナ', 'na'), ('ニ', 'ni'), ('ヌ', 'nu'), ('ネ', 'ne'), ('ノ', 'no'), ('ハ', 'ha'), ('ヒ', 'hi'), ('フ', 'fu'), ('ヘ', 'he'), ('ホ', 'ho'), ('マ', 'ma'), ('ミ', 'mi'), ('ム', 'mu'), ('メ', 'me'),
                   ('モ', 'mo'), ('ヤ', 'ya'), ('ユ', 'yu'), ('ヨ', 'yo'), ('ラ', 'ra'), ('リ', 'ri'), ('ル', 'ru'),
                   ('レ', 're'), ('ロ', 'ro'), ('ワ', 'wa'), ('ヲ', 'wo'), ('ン', 'n'),
                   ("ン", "n"),  # 가타가나 특수
                   # 간자체
                   ("𝐘", "Y"), ("𝐱", "x"), ("𝐖", "W"), ("𝐑", "R"), ("𝐫", "r"), ("P", "P"), ("𝐨", "o"), ("𝐧", "n"), ("𝐦", "m"), ("𝐥", "l"), ("𝐤", "k"), ("𝐠", "g"), ("𝐟", "f"), ("𝐞", "e"), ("𝐃", "D"), ("𝐁", "B"), ("𝐀", "A"), ('𝐲', 'y'), ('𝐕', 'V'), ('𝐮', 'u'), ('𝐭', 't'), ('ｔ', 't'), ('𝐒', 'S'),
                   ('𝐬', 's'),
                   ('𝐏', 'P'), ('𝐨', 'o'), ('ｏ', 'o'), ('𝐧', 'n'), ('ｌ', 'l'), ('ｋ', 'k'), ('𝐢', 'i'), ('i', 'i'),
                   ('ｅ', 'e'), ('𝐝', 'd'), ('𝐜', 'c'), ('ｃ', 'c'), ('𝐚', 'a'),
                   # 특수문자
                   ('🌕', '_'), ('🔥', '_'), ('🗡️', '_'), ('💜', '_'), ('🎤', '_'), ('☆️', '_'), ('★', '_'), ('🛸', '_'), ('🚬', '_'), ('🚪', '_'), ('🚨', '_'), ('🚘', '_'), ('🙆', '_'), ('😭', '_'), ('😥', '_'), ('😢', '_'), ('😈', '_'), ('😆', '_'), ('😅', '_'), ('🧖', '_'), ('🧐', '_'), ('🦝', '_'), ('🥺', '_'),
                   ('🥩', '_'), ('🥜', '_'), ('🤸', '_'), ('🤴', '_'), ('🤫', '_'), ('🤡', '_'), ('🤘', '_'), ('🤗', '_'), ('🤔', '_'),
                   ('🤓', '_'), ('🖐', '_'), ('🔹', '_'), ('🔮', '_'), ('🔍', '_'), ('📚', '_'), ('📁', '_'), ('💻', '_'), ('💸', '_'), ('💪', '_'), ('💥', '_'), ('💡', '_'), ('💛', '_'), ('💚', '_'), ('💙', '_'), ('💖', '_'), ('💔', '_'), ('💎', '_'), ('💍', '_'), ('💁', '_'), ('👹', '_'), ('👭', '_'), ('👗', '_'),
                   ('👖', '_'),
                   ('👍', '_'), ('👌', '_'), ('👋', '_'), ('👊', '_'), ('👄', '_'), ('🐶', '_'), ('🐠', '_'), ('🐟', '_'),
                   ('🏻', '_'), ('🏡', '_'), ('🎩', '_'), ('🎧', '_'), ('🎉', '_'), ('🍰', '_'), ('🍭', '_'), ('🍜', '_'), ('🍒', '_'), ('🍃', '_'), ('🍂', '_'), ('🌺', '_'), ('🌹', '_'), ('🌸', '_'), ('🌷', '_'), ('🌡', '_'), ('🌟', '_'), ('🌞', '_'), ('🌙', '_'), ('🌎', '_'), ('🌈', '_'), ('⭐', '_'), ('⧸', '_'),
                   ('➡', '_'),
                   ('❤', '_'), ('❗', '_'), ('❕', '_'), ('❓', '_'), ('❌', '_'), ('✿', '_'), ('✨', '_'), ('✧', '_'),
                   ('✦', '_'), ('✔', '_'), ('✅', '_'), ('🇹', '_'), ('🇷', '_'), ('🇰', '_'), ('🇮', '_'), ('⚡', '_'), ('♬', '_'), ('♪', '_'), ('♩', '_'), ('♨', '_'), ('📝', '_'), ('🌱', '_'),
                   ('｜', '_'),
                   # 일본어 간자체 일부 맵핑 # 공부용 #아는 것만 추가 #같은문자 다른소리 처리 어떻게하지?
                   ("日", "日(nichi)"), ("人", "人(jin)"), ("本", "本(hon)"), ("大", "大(dai)"), ("中", "中(chuu)"), ("小", "小(shou)"), ("山", "山(yama)"), ("川", "川(kawa)"), ("田", "田(ta)"), ("水", "水(sui)"), ("火", "火(ka)"), ("木", "木(moku)"), ("金", "金(kin)"), ("土", "土(do)"),
                   ("空", "空(kuu)"),
                   ("天", "天(ten)"), ("海", "海(umi)"), ("心", "心(shin)"), ("愛", "愛(ai)"), ("学", "学(gaku)"),
                   ("生", "生(sei)"), ("車", "車(sha)"), ("電", "電(den)"), ("語", "語(go)"), ("書", "書(sho)"), ("読", "読(doku)"), ("見", "見(ken)"), ("聞", "聞(bun)"), ("花", "花(hana)"), ("風", "風(kaze)"),
                   (']_[', ']['), ('_.. ', '_'), ('.._ ', '_'), ('._ ', '_'),
                   ('[$TIMESTAMP]', '_'),
                   (' e end hdtv once ', '_E_'),
                   ('.E.p_NEXT_', '_E_'),
                   (' e end hdtv once ', '_E_'),
                   ('hhd800.com@', '_'),
                   ('티비플', '[티비플]'), ('re제로', ' re zero '), ('리제로', ' re zero '), ('미스터 션샤인', ' 미스터션샤인'), ('야나기나기', ' Nagi Yanagi'), ('피아노_음악', '[piano]'),
                   ('「', '['), ('】', ']'), ('」', ']'), ('【', '['), ('／', ' '), ('│', ' '),
                   ('이어폰 필수', '이어폰필수'),
                   ('우타이테', 'utaite'),
                   ('이어폰필수', '_'), ('편곡ver ', '_'), ('볼빨간 사춘기', '볼빨간사춘기'),
                   ('cover.鹿乃', '_'), ('#s #', '_'), ('[Leopard-Raws]', '_'),
                   ('메이플', '메이플스토리'), ('스토리스토리', '스토리'),
                   ('짐___캐리', '짐 캐리'), ('짐_캐리', '짐 캐리'),
                   ('케이tv', '_'), ('한글자막', '_'), ('1080P', '1080p'), ('1080p.H264-F1RST', '_'), ('[Moozzi2]', '_'),
                   # ('[[', '['),
                   # (']]', ']'),
                   # ('_)_)', '))'),
                   ('►', '_'), ('♫', '_'),
                   # '후회안합니다', '환영합니다', '합니다', '시작합니다', '소개합니다', '복잡합니다', '만들어야합니다', '공개합니다', '감사합니다',
                   # '[퓨전_음악]', '[ENG]', '[TM_sound]', '[치유정화]', '[울적해져요]', '[nightcore]', '[MV]', '[쇼! 음악중심]', '[쇼!_음악중심]', '[이어폰_소름]', '[이어폰_필수]', '[이어폰챙겻죠]', '[한국어 자막]', '[너무좋다]', '[소름 돋아요]', '[자작곡]', '[수정본]', '[TV]', '[CD]',
                   # 'Yang HeeEun', '판타스틱 듀오', '집중력 향상을 위한', '임금님랭킹2기오프닝', 'Fantastic Duo', '모던민요',
                   # "(ENG_SUB)"
                   # # 'playlist',
                   # # 'LIVE',
                   # '핫클립',
                   # '_., ', '_._ ',
                   # ' _ ', ' - ', '[_]', '___',
                   # '__', '  ',
                   # # "'",
                   # '|', '「️', '」️', '【', '】',
                   # # '+', '&',
               ] + stamp_title_list + duplicated_stamp_list * 2  # *2 를 해야 stamp 가 충분히 없어집니다.
    # for index, item in enumerate(keywords):
    #     pk_print(f'''keywords[{index}]={item}  {'%%%FOO%%%' if LTA else ''}''')

    # for index, item in enumerate(stamp_title_list):
    #     pk_print(f'''stamp_title_list[{index}]={item}  {'%%%FOO%%%' if LTA else ''}''')

    for index, item in enumerate(duplicated_stamp_list):
        pk_print(f'''duplicated_stamp_list[{index}]={item}  {'%%%FOO%%%' if LTA else ''}''')

    for keyword_removed in keywords_remove_pnxs_unnecessary:
        pnxs = [item for item in pnxs if keyword_removed not in item[0]]  # remove_element_to_have_"keywords_remove_dirs_unnecessary"
    # print_list_as_vertical(working_list=d_list, items_name="d_list")
    # print_list_as_vertical(working_list=f_list, items_name="f_list")
    pnxs_and_pnxs_new = []
    for item in pnxs:
        item_pnx = item[0]
        item_pnx_new = item_pnx  # item_pnx_로 초기화
        for keyword, keyword_new in keywords:
            item_p = get_p(pnx=item_pnx_new)
            item_nx = get_nx(pnx=item_pnx_new)
            item_nx_new = item_nx.replace(keyword, keyword_new)  # 누적하여 교체
            item_pnx_new = rf"{item_p}\{item_nx_new}"
        # pk_print(str_working=rf'''item_pnx="{item_pnx}"  {'%%%FOO%%%' if LTA else ''}''')
        # pk_print(str_working=rf'''item_pnx_new="{item_pnx_new}"  {'%%%FOO%%%' if LTA else ''}''')
        if item_pnx != item_pnx_new:  # item_pnx_와 item_pnx_new가 다르면 추가
            pnxs_and_pnxs_new.append([item_pnx, item_pnx_new])

    # 확인
    pk_print(f'''pnxs_and_pnxs_new={pnxs_and_pnxs_new}  {'%%%FOO%%%' if LTA else ''}''')
    pk_print(f'''len(pnxs_and_pnxs_new)={len(pnxs_and_pnxs_new)} 바꿀 대상  {'%%%FOO%%%' if LTA else ''}''')

    # 적용
    rename_pnxs(pnx_list=pnxs_and_pnxs_new)


def rename_pnxs_from_pattern_once_to_pattern_new(src, pattern, mode, pattern_new, with_walking):
    import re
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_LOCAL_PKG_CACHE, F_SUCCESS_LOG, F_DB_YAML
    pk_print(working_str=rf'''pattern={pattern}  pattern_new={pattern_new}  {'%%%FOO%%%' if LTA else ''}''')

    txt_to_exclude_list = [
        F_DB_YAML, F_SUCCESS_LOG, F_LOCAL_PKG_CACHE,
    ]

    if with_walking == True:
        d_list, f_list = get_sub_pnx_list(pnx=src, txt_to_exclude_list=txt_to_exclude_list)
    else:
        d_list, f_list = get_sub_pnx_list(pnx=src, txt_to_exclude_list=txt_to_exclude_list, without_walking=0)

    if mode == "f":
        pnxs = f_list
    elif mode == "d":
        pnxs = d_list
    else:
        pk_print(working_str=rf'''"return"  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        return
    pk_print(f'''len(pnxs)={len(pnxs)}  {'%%%FOO%%%' if LTA else ''}''')
    # print_list_as_vertical(working_list=pnxs, working_list_n="pnxs  {'%%%FOO%%%' if LTA else ''}")

    # 한 번들어간 패턴
    pnxs_reg_checked = []
    item_p = None
    item_nx = None
    item_pnx = None
    item_nx_new = None
    for item in pnxs:
        item_p = get_p(item[0])
        item_nx = get_nx(item[0])
        item_pnx = get_pnx(item[0])
        if re.search(pattern, item_nx):
            # if re.match(pattern, item_nx):
            pnxs_reg_checked.append(item)
    pk_print(working_str=rf'''pnxs_reg_checked="{pnxs_reg_checked}"  {'%%%FOO%%%' if LTA else ''}''')
    # print_list_as_vertical(working_list=pnxs_reg_checked, working_list_n="pnxs_reg_checked")

    pnxs_and_pnxs_new = []
    for item in pnxs_reg_checked:
        item_p = get_p(item[0])
        item_nx = get_nx(item[0])
        item_nx_new = re.sub(pattern, pattern_new, item_nx)

        # logging
        pk_print(working_str=rf'''item_nx_new="{item_nx_new}"  {'%%%FOO%%%' if LTA else ''}''')

        item_pnx_new = rf"{item_p}\{item_nx_new}"
        pnxs_and_pnxs_new.append([item[0], item_pnx_new])

    # logging
    pk_print(working_str=rf'''item_p={item_p} item_nx={item_nx} item_nx_new={item_nx_new} {'%%%FOO%%%' if LTA else ''}''')

    # 확인
    # print_list_as_vertical(working_list=pnxs_and_pnxs_new, working_list_n="바꿀 대상")
    # pk_print(str_working=rf'''len(pnxs_and_pnxs_new)="{len(pnxs_and_pnxs_new)}"  {'%%%FOO%%%' if LTA else ''}''')

    # 적용
    rename_pnxs(pnx_list=pnxs_and_pnxs_new)


def rename_pnxs_from_pattern_twice_to_pattern_new(pnx, pattern, mode, with_walking, pattern_new="_"):
    import re
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_LOCAL_PKG_CACHE, F_SUCCESS_LOG, F_DB_YAML

    pk_print(working_str=rf'''pattern={pattern} pattern_new={pattern_new}  {'%%%FOO%%%' if LTA else ''}''')

    txt_to_exclude_list = [
        F_DB_YAML, F_SUCCESS_LOG, F_LOCAL_PKG_CACHE,
    ]

    if with_walking == True:
        d_list, f_list = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list)
    else:
        d_list, f_list = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list, without_walking=0)

    if mode == "f":
        pnxs = f_list
    elif mode == "d":
        pnxs = d_list
    else:
        pk_print(working_str=rf'''"return"  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        return

    # 두 번들어간 패턴
    pnxs_reg_checked = []
    item_new = None
    for item in pnxs:
        item_p = get_p(item[0])
        item_nx = get_nx(item[0])
        item_pnx = get_pnx(item[0])
        if len(re.findall(pattern, item[0])) >= 2:
            # if re.match(pattern, item_nx):
            pnxs_reg_checked.append(item)
    pk_print(f'''len(pnxs_reg_checked)={len(pnxs_reg_checked)}  {'%%%FOO%%%' if LTA else ''}''')

    pnxs_and_pnxs_new = []
    for item in pnxs_reg_checked:
        item_p = get_p(item[0])
        item_nx = get_nx(item[0])
        item_nx_new = re.sub(pattern, pattern_new, item_nx)
        if is_f(item[0]):
            item_pnx_new = rf"{item_p}\{item_nx_new}"
        else:
            item_pnx_new = rf"{item_p}\{item_nx_new}"
        pnxs_and_pnxs_new.append([item[0], item_pnx_new])

    # 확인
    pk_print(working_str=rf'''len(pnxs_and_pnxs_new)="{len(pnxs_and_pnxs_new)}" 바꿀 대상  {'%%%FOO%%%' if LTA else ''}''')

    # 적용
    rename_pnxs(pnx_list=pnxs_and_pnxs_new)


def print_from_pnx_list_to_semantic_words(pnx):
    import inspect
    import re
    from collections import Counter
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_LOCAL_PKG_CACHE, F_SUCCESS_LOG, F_DB_YAML
    func_n = inspect.currentframe().f_code.co_name

    txt_to_exclude_list = [
        F_DB_YAML,
        F_SUCCESS_LOG,
        F_LOCAL_PKG_CACHE,
    ]

    # d_list, f_list=get_sub_pnxs_without_walking(pnx=item_pnx, txt_to_exclude_list=txt_to_exclude_list)
    d_list, f_list = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list)

    # pnxs=d_list
    pnxs = f_list

    # 수십개의 f 경로에서 2개 이상의 한글로 구성된 의미론적인 단어를 추출
    special_korean_words = []

    def extract_korean_words(pnx):
        pattern = r'[가-힣]{2,}'  # 한글만 추출하는 정규식
        korean_words = re.findall(pattern=pattern, string=pnx)  # 2개 이상 한글 문자로 이루어진 단어를 찾음
        return korean_words

    for item in pnxs:
        item_pnx = item[0]
        korean_words = extract_korean_words(item_pnx)
        special_korean_words = special_korean_words + korean_words
    word_count = Counter(special_korean_words)
    pk_print(working_str=rf'''word_count="{word_count}"  {'%%%FOO%%%' if LTA else ''}''')


def rename_pnxs_from_________to_______2______via_hard_coded():
    import inspect
    from pkg_py.pk_core_constants import F_LOCAL_PKG_CACHE, F_SUCCESS_LOG, F_DB_YAML
    func_n = inspect.currentframe().f_code.co_name

    # pnx=rf"D:\#기타\pkg_dirs"
    # pnx=rf"D:\#기타\pkg_files"
    pnx = rf"D:\#기타"
    pnx = rf"D:\#기타\pkg_files\pkg_mp4"

    txt_to_exclude_list = [
        F_DB_YAML,
        F_SUCCESS_LOG,
        F_LOCAL_PKG_CACHE,
    ]

    # d_list, f_list=get_sub_pnxs_without_walking(pnx=item_pnx, txt_to_exclude_list=txt_to_exclude_list)
    d_list, f_list = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list)

    # pnxs=d_list
    pnxs = f_list

    # todo : chore : pattern 변수 그 유사함수에서 참조해서 가져오기
    #
    # # pattern 대체 timestamp 를 붙이기
    # pnxs_and_pnxs_new=[]
    # for item in pnxs:
    #     pattern_new=''
    #     item_without_reg=re.sub(pattern, pattern_new, item[0]) # 날짜/시간 패턴을 모두 remove
    #     item_pn=get_pn(item_without_reg)
    #     item_x=get_x(item_without_reg)
    #     timestamp=get_time_as_("now")
    #     item_new=""
    #     if is_file(item[0]):
    #         item_new=f"{item_pn}_{timestamp}.{item_x}"
    #     else:
    #         item_new=f"{item_pn}_{timestamp}{item_x}"
    #     pnxs_and_pnxs_new.append([item[0], item_new])
    #
    # # 확인
    # print_list_as_vertical(working_list=pnxs_and_pnxs_new, items_name="바꿀 대상")
    # pk_print(str_working=rf'''len(pnxs_and_pnxs_new)="{len(pnxs_and_pnxs_new)}"  {'%%%FOO%%%' if LTA else ''}''')
    #
    # # 적용
    # rename_pnxs(pnxs=pnxs_and_pnxs_new)


def move_pnx_list_pattern_via_hard_coded():
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_LOCAL_PKG_CACHE, F_SUCCESS_LOG, F_DB_YAML
    func_n = inspect.currentframe().f_code.co_name

    # pnx=rf"D:\#기타\pkg_dirs"
    # pnx=rf"D:\#기타\pkg_files"
    pnx = rf"D:\#기타"
    pnx = rf"D:\#기타\pkg_files\pkg_mp4"

    txt_to_exclude_list = [
        F_DB_YAML,
        F_SUCCESS_LOG,
        F_LOCAL_PKG_CACHE,
    ]

    # d_list, f_list=get_sub_pnxs_without_walking(pnx=item_pnx, txt_to_exclude_list=txt_to_exclude_list)
    d_list, f_list = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list)

    # pnxs=d_list
    pnxs = f_list

    # pattern 대체 timestamp 를 붙이기
    # pnxs_and_pnxs_new=[]
    # for item in pnxs:
    #     pattern_new=''
    #     item_without_reg=re.sub(pattern, pattern_new, item[0]) # 날짜/시간 패턴을 모두 remove
    #     item_pn=get_pn(item_without_reg)
    #     item_x=get_x(item_without_reg)
    #     timestamp=get_time_as_("now")
    #     item_new=""
    #     if is_file(item[0]):
    #         item_new=f"{item_pn}_{timestamp}.{item_x}"
    #     else:
    #         item_new=f"{item_pn}_{timestamp}{item_x}"
    #     pnxs_and_pnxs_new.append([item[0], item_new])

    # [문자열] 패턴은 f명의 맨앞이나 뒤로 이동
    pnxs_and_pnxs_new = []
    for item in pnxs:
        item_pnx = item[0]
        pattern = r'(\[.*?\])'
        # item_pnx_new=get_str_moved_pattern_to_front(pattern=pattern, item_pnx=item_pnx)
        item_pnx_new = get_f_n_moved_pattern(pattern=pattern, pnx_working=item_pnx, mode_front=0)
        if item_pnx != item_pnx_new:  # item_pnx item_pnx_new가 다르면 추가
            pnxs_and_pnxs_new.append([item_pnx, item_pnx_new])

    # 확인
    print_iterable_as_vertical(item_iterable=pnxs_and_pnxs_new, item_iterable_n="바꿀 대상")
    pk_print(working_str=rf'''len(pnxs_and_pnxs_new)="{len(pnxs_and_pnxs_new)}"  {'%%%FOO%%%' if LTA else ''}''')

    # 적용
    rename_pnxs(pnx_list=pnxs_and_pnxs_new)


def merge_pnx_list_via_text_file():
    import inspect
    from pkg_py.pk_core_constants import D_PROJECT
    func_n = inspect.currentframe().f_code.co_name
    f_func_n_txt = rf'{D_PROJECT}\pkg_txt\{func_n}.txt'
    ensure_pnx_made(pnx=f_func_n_txt, mode="f")
    # if not is_window_open(window_title=f_func_n_txt):
    #     open_pnx(f_func_n_txt, debug_mode=True)
    pnxs = get_list_from_f(f=f_func_n_txt)
    merge_d_list(d_list=pnxs)


def gather_f_useless_at_tree(d_working):
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_USELESS_FILE_NAMES_TXT, D_PROJECT
    dst = rf"D:\[]\[useless]"
    ensure_pnx_made(pnx=dst, mode="d")
    pk_print(f'''dst={dst}  {'%%%FOO%%%' if LTA else ''}''')
    if not is_empty_d(d_src=dst):
        cmd_to_os(cmd=rf'explorer "{dst}" ', encoding='cp949')
    try:
        pk_chdir(d_dst=d_working)

        # string_clipboard_bkp=pk_paste()

        # useless_f_set 수집
        useless_f_set = set()
        is_target_moved_done = False
        useless_file_names_txt = F_USELESS_FILE_NAMES_TXT
        uleless_f_list = get_list_from_f(useless_file_names_txt)
        # open_pnx(pnx=useless_file_names_txt, debug_mode=True)
        for useless_f_nx in uleless_f_list:
            if useless_f_nx is not None:
                useless_f_nx = useless_f_nx.strip()
                useless_f_nx = useless_f_nx.strip("\n")
                cmd = f'dir /b /s "{useless_f_nx}"'
                uleless_f_list = cmd_to_os(cmd=cmd, encoding='cp949')
                if uleless_f_list is None:
                    uleless_f_list = []
                for uleless_f in uleless_f_list:
                    if does_pnx_exist(pnx=uleless_f):
                        useless_f_set.add(uleless_f)

        pk_chdir(D_PROJECT)

        if len(useless_f_set) == 0:
            pk_print(f'''len(useless_f_set)={len(useless_f_set)}  {'%%%FOO%%%' if LTA else ''}''')
            return
        else:
            for useless_f in useless_f_set:
                move_pnx(pnx=useless_f, d_dst=dst)  # todo : fix:외장드라이브에서는 안되는듯
                # move_pnx_to_trash_bin(src=useless_f)
        pk_print(working_str=rf'''dst="{dst}"  {'%%%FOO%%%' if LTA else ''}''', print_color='green')
    except:
        pk_print(f"{traceback.format_exc()}", print_color='red')


# @pk_measure_seconds
def get_d_working():
    import os
    return os.getcwd()


def is_wired_pnx(pnx):
    import inspect
    import os
    import string
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    # wired 이상한 pnx 인지 확인
    # required 가 나은 것 같은데
    if pnx == "":
        pk_print(f'''입력된 pnx가 "" 입니다 pnx={pnx} {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        return 1
    connected_drives = []
    for drive_letter in string.ascii_uppercase:
        drive_path = drive_letter + ":\\"
        if os.path.exists(drive_path):
            connected_drives.append(drive_path)
            if pnx == drive_path:
                pk_print(f'''입력된 pnx는 너무 광범위하여 진행할 수 없도록 설정되어 있습니다  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
                return 1
    if not os.path.exists(pnx):
        pk_print(f'''입력된 pnx가 존재하지 않습니다 pnx={pnx} {'%%%FOO%%%' if LTA else ''}''')
        return 1


def get_list_removed_element_empty(working_list):
    return [item for item in working_list if item and item.strip()]


# def get_list_removed_element_empty(working_list):
#     return [
#         item for item in working_list
#         if isinstance(item, str) and item.strip()
#     ]


def get_list_removed_element_contain_prompt(working_list, prompt):
    return [item for item in working_list if prompt not in item]


# def get_list_removed_element_contain_prompt(working_list, prompt):
#     return [
#         item for item in working_list
#         if isinstance(item, str) and prompt not in item
#     ]


# def get_list_removed_element_contain_prompt(working_list, prompt):
#     result = []
#     for item in working_list:
#         if not isinstance(item, str):
#             print(f"[제거] 타입이 str 아님: {item}")
#             continue
#         item_stripped = item.strip()
#         if not item_stripped:
#             print(f"[제거] 공백 또는 빈 줄: {repr(item)}")
#             continue
#         if prompt in item_stripped:
#             print(f"[제거] prompt 포함: {repr(item)}")
#             continue
#         result.append(item_stripped)
#     return result


def get_list_leaved_element_contain_prompt(working_list, prompt):
    return [f for f in working_list if prompt in f]


def get_list_replaced_element_from_str_to_str(working_list, from_str, to_str, debug_mode=True):
    return [text.replace(from_str, to_str) for text in working_list]


def get_list_striped_element(working_list, mode='strip'):
    if working_list is None:
        working_list = []
    if mode == 'lstrip':
        return [item.lstrip() for item in working_list]
    elif mode == 'rstrip':
        return [item.rstrip() for item in working_list]
    else:
        return [item.strip() for item in working_list]


# def get_list_striped_element(working_list):
#     return [
#         item.strip() for item in working_list
#         if isinstance(item, str)
#     ]


def get_list_contained_element(working_list, prefix=None, suffix=None):
    modified_list = []
    for item in working_list:
        if prefix and suffix:
            if item.startswith(prefix) and item.endswith(suffix):
                modified_list.append(item)
        if prefix:
            if item.startswith(prefix):
                modified_list.append(item)
        if suffix:
            if item.endswith(suffix):
                modified_list.append(item)
    return modified_list


def get_list_contained_element_that_added_prefix_suffix(working_list, prefix="", suffix=""):
    modified_list = []
    for item in working_list:
        item_added_prefix_and_suffix = f"{prefix}{item}{suffix}"
        modified_list.append(item_added_prefix_and_suffix)
    return modified_list


def pk_get_colorful_working_str_with_stamp_enviromnet(func_n, ment=""):
    from pkg_py.pk_core_constants import STAMP_PK_ENVIRONMENT_WITHOUT_BRAKET
    highlight_config_dict = {
        "blue": [
            STAMP_PK_ENVIRONMENT_WITHOUT_BRAKET
        ],
        "green": [
            func_n
        ],
        "white": [
            ment
        ],
    }
    return get_txt_highlighted(txt_whole=rf'({STAMP_PK_ENVIRONMENT_WITHOUT_BRAKET}) ({func_n}) {ment}', config_highlight_dict=highlight_config_dict)


def remove_lines_within_keyword_from_f(f: str, keyword: str) -> None:
    import shutil
    from datetime import datetime

    # 변경 전 파일 백업
    # now = datetime.now().strftime("%y%m%d_%H%M")
    now = datetime.now().strftime("%y%m%d_%H")
    backup_path = f"{f}.{now}.bak"
    shutil.copy2(f, backup_path)
    if does_pnx_exist(pnx=backup_path):
        print(f"백업 파일 저장 완료: {backup_path}")

    # 특정 키워드가 포함된 줄 제거
    filtered_lines = []
    with open(f, 'r', encoding='utf-8') as f_obj:
        lines = f_obj.readlines()
        filtered_lines = [line for line in lines if keyword not in line]
    with open(f, 'w', encoding='utf-8') as f_obj:
        f_obj.writelines(filtered_lines)


def get_pnx_ubuntu_pkg_installed(ubuntu_pkg_n):
    import shutil
    return shutil.which(ubuntu_pkg_n)


def get_youtube_clip_id(url):
    youtube_clip_id = url.split("v=")[-1]
    return youtube_clip_id


def download_youtube_video():
    try:
        import inspect
        from pkg_py.pk_colorful_cli_util import pk_print
        from pkg_py.pk_core_constants import D_PROJECT, D_WORKING, D_PKG_TXT, F_FFMPEG_EXE, PK_BLANK
        import yt_dlp
        import os
        import sys
        from pkg_py.pk_core_class import PkState250701
        from pkg_py.pk_core_class import PkMents2025, PkState250701, PkStateFromDB

        d_pnx = D_WORKING
        func_n = inspect.currentframe().f_code.co_name
        f_func_n_txt = rf'{D_PKG_TXT}/{func_n}.txt'  # success log 기록 # 불필요함.  success 이면 f_historical 에서 삭제되도록 함.

        cookie_f = rf"{D_PKG_TXT}/chrome_youtube_cookies.txt"
        if is_os_windows():
            ffmpeg_location = rf'{get_pnx_os_style(get_p(F_FFMPEG_EXE))}'
        else:
            ensure_ubuntu_pkg_installed('ffmpeg')
            ffmpeg_location = get_pnx_ubuntu_pkg_installed('ffmpeg')
        ydl_opts = {
            'ffmpeg_location': ffmpeg_location,
            'format': 'bestvideo+bestaudio/best',  # 최상의 비디오 & 오디오 선택
            'outtmpl': os.path.join(d_pnx, '%(title)s [%(id)s].%(ext)s'),
            'quiet': False,
            'noplaylist': True,
            'merge_output_format': 'mp4',  # 병합 시 MP4로 저장
            'postprocessors': [{
                'key': 'FFmpegVideoConvertor',
                'preferedformat': 'mp4'  # 변환 후 MP4로 저장
            }],
            'geo_bypass': True,  # 지역 제한 우회
            'cookiefile': cookie_f  # 유튜브영상 성인인증
        }

        # search_keyword = input(f"{pk_get_colorful_working_str_with_stamp_enviromnet(func_n=func_n, ment='WRITE URL TO DOWNLOAD')} >")

        f_historical = rf'{D_PKG_TXT}/historical_{func_n}.txt'
        ensure_pnx_made(pnx=f_historical, mode='f')

        pk_db = PkStateFromDB()

        value = pk_db.get(db_id='open historical f')
        if value == PkMents2025.YES:
            open_pnx_by_ext(pnx=f_historical)
            pk_db.set("open historical f", "YES, one time done")  # 프로그램 실생 중 1회만 실행제한

        youtube_video_url_from_clipboard = get_str_from_clipboard()
        marker_for_clipboard = f'{PK_BLANK}(url from clipboard)'
        youtube_video_url_from_clipboard = rf"{youtube_video_url_from_clipboard}{marker_for_clipboard}"

        historical_lines = get_historical_list(f=f_historical)
        if youtube_video_url_from_clipboard and is_url(youtube_video_url_from_clipboard):
            youtube_clip_id = youtube_video_url_from_clipboard.split("v=")[-1]
            if is_f_contained_feature_str(feature_str=youtube_clip_id, d_pnx=d_pnx):
                youtube_clip_id_stamp = f"[{youtube_clip_id}]"
                pk_print(f"{youtube_clip_id_stamp} is already downloaded, {youtube_video_url_from_clipboard}", print_color="green")

                value = pk_db.get(db_id='download_option')
                # play or skip video
                if value == PkMents2025.play:
                    # play video
                    f_pnx_downloaded = get_f_contained_feature_str(feature_str=youtube_clip_id, d_pnx=d_pnx)
                    if f_pnx_downloaded:
                        open_pnx_by_ext(pnx=f_pnx_downloaded)
                if value == PkMents2025.skip:
                    pass

                # 다운로드 여부 확인 후 제거
                remove_lines_within_keyword_from_f(f=f_historical, keyword=youtube_clip_id)

                # get historical list 
                historical_lines = get_historical_list(f=f_historical)
            else:
                tab_completer_iterable = [youtube_video_url_from_clipboard] + historical_lines

        tab_completer_iterable = historical_lines

        for historical_url in historical_lines:
            historical_url = historical_url.strip()

            youtube_clip_id = historical_url.split("v=")[-1]
            youtube_clip_id_stamp = f"[{youtube_clip_id}]"
            if not is_url(historical_url):
                # URL 아닌 건 제거
                remove_lines_within_keyword_from_f(f=f_historical, keyword=youtube_clip_id)
                continue

            if is_f_contained_feature_str(feature_str=youtube_clip_id_stamp, d_pnx=d_pnx):
                pk_print(f"{youtube_clip_id_stamp} is already downloaded, {historical_url}", print_color="green")
                pk_db = PkStateFromDB()
                db_id = 'download_option'
                value = pk_db.get(db_id=db_id)
                pk_print(f'''db_id=value : {db_id}={value} {'%%%FOO%%%' if LTA else ''}''', print_color="green")

                # play or skip video
                if value == PkMents2025.play:
                    # play video
                    f_pnx_downloaded = get_f_contained_feature_str(feature_str=youtube_clip_id, d_pnx=d_pnx)
                    if f_pnx_downloaded:
                        open_pnx_by_ext(pnx=f_pnx_downloaded)
                if value == PkMents2025.skip:
                    pass

                # 다운로드 여부 확인 후 제거
                remove_lines_within_keyword_from_f(f=f_historical, keyword=youtube_clip_id)

        # get historical list 
        historical_lines = get_historical_list(f=f_historical)

        answer = get_pk_input(message='YOUTUBE URL TO DOWNLOAD=', answer_options=tab_completer_iterable)
        answer = answer.strip()
        if answer.lower() == "x" or answer.lower() == "exit" or answer.lower() == "q" or answer.lower() == "quit":
            sys.exit(0)
        url = answer
        write_list_to_f(f=f_historical, working_list=[url] + historical_lines, mode="w")
        url = url.replace(marker_for_clipboard, "")

        if not does_pnx_exist(pnx=f_historical):
            ensure_pnx_made(pnx=f_historical, mode="f")
        working_list = get_list_from_f(f=f_historical)
        working_list = get_list_removed_element_contain_prompt(working_list=working_list, prompt="#")
        working_list = get_list_deduplicated(working_list=working_list)
        working_list = get_list_removed_element_empty(working_list=working_list)
        working_list = get_list_striped_element(working_list=working_list)
        urls = [url] + working_list
        pk_print(working_str=str(len(urls)))
        urls = get_list_removed_element_empty(working_list=urls)
        pk_print(working_str=str(len(urls)))
        if len(urls) == 0:
            pk_print(f'''len(urls)={len(urls)}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
            return

        if is_os_windows():
            youtube_clip_id = get_youtube_clip_id(url=url)
            download_youtube_video_via_yt_dlp(url_list=[youtube_clip_id], d_pnx=d_pnx, f_func_n_txt=f_func_n_txt)

            youtube_clip_id_stamp = f"[{youtube_clip_id}]"
            if is_f_contained_feature_str(feature_str=youtube_clip_id_stamp, d_pnx=d_pnx):
                pk_print(f"{youtube_clip_id_stamp} is already downloaded, {url}", print_color="green")
                pk_db = PkStateFromDB()
                db_id = 'download_option'
                value = pk_db.get(db_id=db_id)
                if value == PkMents2025.play:
                    # play video
                    f_pnx_downloaded = get_f_contained_feature_str(feature_str=youtube_clip_id, d_pnx=d_pnx)
                    if f_pnx_downloaded:
                        open_pnx_by_ext(pnx=f_pnx_downloaded)
                if value == PkMents2025.skip:
                    pass

            # 다운로드 여부 확인 후 제거
            remove_lines_within_keyword_from_f(f=f_historical, keyword=youtube_clip_id)

            # get historical list
            historical_lines = get_historical_list(f=f_historical)
        else:
            url_list = [normalize_youtube_url(url) for url in urls]  # Shorts URL 변환
            # 자동으로 쿠키를 가져옴

            try:
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    for url in url_list:
                        url = normalize_youtube_url(url)
                        info = ydl.extract_info(url, download=False)
                        youtube_clip_id = info.get('id', None)
                        youtube_clip_id_stamp = f"[{youtube_clip_id}]"
                        clip_title = info.get('title')
                        url_list = [str(url)]
                        pk_print(f'''clip_id={youtube_clip_id} {'%%%FOO%%%' if LTA else ''}''')
                        pk_print(f'''clip_title={clip_title} {'%%%FOO%%%' if LTA else ''}''')

                        # skip download
                        if is_f_contained_feature_str(feature_str=youtube_clip_id_stamp, d_pnx=d_pnx):
                            pk_print(f"{youtube_clip_id_stamp} is already downloaded, {clip_title}({url})", print_color="green")

                            # play/skip decision
                            pk_db = PkStateFromDB()
                            db_id = 'download_option'
                            value = pk_db.get(db_id=db_id)
                            pk_print(f'''db_id=value : {db_id}={value} {'%%%FOO%%%' if LTA else ''}''', print_color="green")
                            if value == PkMents2025.play:
                                # play video
                                f_pnx_downloaded = get_f_contained_feature_str(feature_str=youtube_clip_id, d_pnx=d_pnx)
                                if f_pnx_downloaded:
                                    open_pnx_by_ext(pnx=f_pnx_downloaded)
                            if value == PkMents2025.skip:
                                pass

                            # remove f in f_historical after download
                            remove_lines_within_keyword_from_f(f=f_historical, keyword=youtube_clip_id)

                            # get historical list 
                            historical_lines = get_historical_list(f=f_historical)
                            continue

                        # download
                        ydl.download(url_list)

                        # check f after download
                        if is_f_contained_feature_str(feature_str=youtube_clip_id_stamp, d_pnx=d_pnx):
                            pk_print(f"f saved in '{d_pnx}'. {url}", print_color="green")

                            # remove f in f_historical after download
                            remove_lines_within_keyword_from_f(f=f_historical, keyword=youtube_clip_id)

                            # get historical list 
                            historical_lines = get_historical_list(f=f_historical)
                            continue

            except:
                import traceback
                traceback.print_exc()
                pk_print(f'''Download {url} \n {traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}" ''', print_color='red')
    except SystemExit as e:
        if e.code == 0:
            pk_print('[정상 종료됨: SystemExit(0)]', print_color='green')
            sys.exit(0)
        else:
            raise  # 비정상 종료는 그대로 propagate
    except:
        import traceback
        import sys
        traceback.print_exc()


def is_f_contained_feature_str(feature_str, d_pnx):
    from pkg_py.pk_colorful_cli_util import pk_print
    import os
    if not os.path.exists(d_pnx):
        pk_print(f'''Directory does not exist: {d_pnx}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        return 0
    for filename in os.listdir(d_pnx):
        if feature_str in filename:
            return 1
    return 0


def get_f_contained_feature_str(feature_str, d_pnx):
    from pkg_py.pk_colorful_cli_util import pk_print
    import os
    if not os.path.exists(d_pnx):
        pk_print(f'''Directory does not exist: {d_pnx}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        return None
    else:
        pk_print(f'''Searching for feature_str="{feature_str}" in directory: {d_pnx}  {'%%%FOO%%%' if LTA else ''}''')
    for filename in os.listdir(d_pnx):
        if feature_str in filename:
            full_path = os.path.join(d_pnx, filename)
            pk_print(f'''Found file: {full_path}  {'%%%FOO%%%' if LTA else ''}''')
            return full_path
    else:
        pk_print(f'''No file containing feature_str="{feature_str}" found in directory: {d_pnx}  {'%%%FOO%%%' if LTA else ''}''')
    return None


def get_f_list_contained_feature_str(feature_str, d_pnx):
    from pkg_py.pk_colorful_cli_util import pk_print
    import os
    if not os.path.exists(d_pnx):
        pk_print(f'''Directory does not exist: {d_pnx}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        return None
    else:
        pk_print(f'''Searching for feature_str="{feature_str}" in directory: {d_pnx}  {'%%%FOO%%%' if LTA else ''}''')
    files_filtered = []
    for filename in os.listdir(d_pnx):
        if feature_str in filename:
            full_path = os.path.join(d_pnx, filename)
            pk_print(f'''Found file: {full_path}  {'%%%FOO%%%' if LTA else ''}''')
            files_filtered.append(full_path)
    else:
        pk_print(f'''No file containing feature_str="{feature_str}" found in directory: {d_pnx}  {'%%%FOO%%%' if LTA else ''}''')
    return files_filtered


def format_selector(ctx):
    """ 최적의 비디오 및 오디오 형식을 선택하는 함수 """
    formats = ctx.get('formats')
    if not formats:
        raise ValueError("No formats available.")

    # 모든 비디오 포맷 가져오기 (MP4 우선)
    video_formats = sorted(
        [fmt for fmt in formats if fmt.get('vcodec') != 'none'],
        key=lambda fmt: (int(fmt.get('height') or 0), int(fmt.get('vbr') or 0)), reverse=True
    )

    # 모든 오디오 포맷 가져오기
    audio_formats = sorted(
        [fmt for fmt in formats if fmt.get('acodec') != 'none'],
        key=lambda fmt: int(fmt.get('abr') or 0), reverse=True
    )

    # MP4 우선, 없으면 다른 확장자도 허용
    for video in video_formats:
        audio_ext = 'm4a' if video.get('ext') == 'mp4' else video.get('ext')
        compatible_audio = next((audio for audio in audio_formats if audio.get('ext') == audio_ext), None)
        if compatible_audio:
            return {
                'format_id': f"{video['format_id']}+{compatible_audio['format_id']}",
                'ext': video['ext'],
                'requested_formats': [video, compatible_audio],
                'protocol': f"{video.get('protocol', '')}+{compatible_audio.get('protocol', '')}"
            }

    # 아무 형식도 찾지 못한 경우
    raise ValueError("No compatible format found. Check if the video is restricted.")


def get_video_title_with_ytdlp(clip_id):
    from pkg_py.pk_colorful_cli_util import pk_print
    from yt_dlp import YoutubeDL
    # URL 정리
    url = normalize_youtube_url(f"https://www.youtube.com/watch?v={clip_id}")

    ydl_opts = {
        'quiet': True,
        'skip_download': True,  # 다운로드는 건너뜀
        'force_generic_extractor': False,  # 유튜브 전용 처리
    }
    try:
        with YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)
            # YouTube 영상 ID 추출
            clip_id = info.get('id', None)
            title = info.get('title', None)
            if title is None:
                pk_print(f"Could not retrieve title for {clip_id}. Using default title.", print_color='red')
                if clip_id:
                    pk_print(f"Could not retrieve clip_id for URL: {url}.", print_color='red')
                    return rf"Unknown_Title({clip_id})"
                return "Unknown_Title(unknown_clip_id)"
            return title

    except:
        DESCRIPTION = f"yt_dlp를 사용하여 제목을 가져오는 데 실패했습니다"  # 제목에 이모지나 특수문자를 포함한 경우 실패할 수 있음
        pk_print(f"{DESCRIPTION}  {'%%%FOO%%%' if LTA else ''}", print_color='red')
        return "Unknown_Title"


def log_success_to_f(FEATURE_NICK_NAME, FEATURE_ID, FEATURE_REMOVAL_ID, f):
    from pkg_py.pk_colorful_cli_util import pk_print
    import os
    from pkg_py.pk_core_constants import Encoding, STAMP_SUCCEEDED
    try:
        working_list = []
        if not os.path.exists(f):
            with open(file=f, mode='w', encoding=Encoding.UTF8.value) as f_obj:
                f_obj.write("")  # 빈 f 생성

        with open(file=f, mode='r', encoding=Encoding.UTF8.value) as f_obj:
            working_list = f_obj.readlines()

        # 리스트 정리: 공백 remove 및 중복 remove
        # working_list = list(set([item.strip() for item in working_list]))

        hashed_stamp_success = rf'#{STAMP_SUCCEEDED}'
        for item in working_list:
            if hashed_stamp_success in item:
                working_list.remove(item)
                pk_print(f"{FEATURE_ID} removed from working_list.")

        working_list.append(f"{hashed_stamp_success} {FEATURE_ID:30s} {FEATURE_NICK_NAME} ")

        # 리스트 저장 (정렬 필요 시 주석 해제)
        # working_list = sorted(working_list)

        with open(file=f, mode='w', encoding=Encoding.UTF8.value) as f:
            f.write("\n".join(working_list) + "\n")

    except:
        import traceback
        DESCRIPTION = f"log {FEATURE_ID} \n {traceback.format_exc()}"
        pk_print(f"{DESCRIPTION}  {'%%%FOO%%%' if LTA else ''}", print_color='red')


def normalize_youtube_url(url):
    """ YouTube URL을 표준 형식으로 변환 """
    if "youtube.com/watch?v=" in url and "youtu.be" in url:
        url = url.replace("https://www.youtube.com/watch?v=https://youtu.be/", "https://youtu.be/")

    # youtu.be 형식의 단축 URL을 표준 watch?v= 형식으로 변환
    if "youtu.be/" in url:
        video_id = url.split("youtu.be/")[-1].split("?")[0]  # YouTube 영상 ID 추출
        url = f"https://www.youtube.com/watch?v={video_id}"

    return url


def save_chrome_youtube_cookies_to_f():
    import browser_cookie3
    from pkg_py.pk_core_constants import D_PKG_TXT
    from pkg_py.pk_colorful_cli_util import pk_print

    f_cookie = rf"{D_PKG_TXT}/chrome_youtube_cookies.txt"
    f_cookie = get_pnx_os_style(pnx=f_cookie)

    try:
        cj = browser_cookie3.chrome(domain_name=".youtube.com")  # Chrome에서 youtube.com 쿠키 가져오기
        with open(file=f_cookie, mode="w") as f:
            for cookie in cj:
                f.write(f"{cookie.domain}\tTRUE\t{cookie.path}\tFALSE\t{cookie.expires}\t{cookie.name}\t{cookie.value}\n")
        pk_print(f"save cookies {f_cookie}", print_color="green")
    except:
        pk_print(f"save cookies {f_cookie}", print_color='red')


def download_youtube_video_via_yt_dlp(url_list, d_pnx, f_func_n_txt):
    import yt_dlp
    import os
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PKG_TXT, F_FFMPEG_EXE

    url_list = [normalize_youtube_url(url) for url in url_list]  # Shorts URL 변환

    if not does_pnx_exist(pnx=d_pnx):
        pk_print(f'''d_pnx="{d_pnx}" does not exist. Creating it.''', print_color='red')

    # 저품질 성공
    # ydl_opts = {
    #     'format': 'best',
    #     # 'format': format_selector,
    #     'outtmpl': os.path.join(d_pnx, '%(title)s [%(id)s].%(ext)s'),
    #     'quiet': False,
    #     'noplaylist': True,
    #     'force_generic_extractor': True
    # }

    # 고품질 실패
    # ydl_opts = {
    # 'format': format_selector,
    #     'outtmpl': os.path.join(d_pnx, '%(title)s [%(id)s].%(ext)s'),
    #     'quiet': False,
    #     'noplaylist': True,
    #     'force_generic_extractor': True
    # }

    # 고품질 성공
    # ydl_opts = {
    #     'format': 'bestvideo+bestaudio/best',  # 최상의 비디오 & 오디오 선택
    #     'outtmpl': os.path.join(d_pnx, '%(title)s [%(id)s].%(ext)s'),
    #     'quiet': False,
    #     'noplaylist': True,
    #     'merge_output_format': 'mp4',  # 병합 시 MP4로 저장
    #     'postprocessors': [{
    #         'key': 'FFmpegVideoConvertor',
    #         'preferedformat': 'mp4'  # 변환 후 MP4로 저장
    #     }],
    # }

    # 고품질 성공
    """ 자동으로 쿠키를 가져와서 유튜브 영상을 다운로드하는 함수 """

    cookie_f = rf"{D_PKG_TXT}/chrome_youtube_cookies.txt"
    ydl_opts = {
        'ffmpeg_location': rf'{get_pnx_os_style(get_p(F_FFMPEG_EXE))}',
        'format': 'bestvideo+bestaudio/best',  # 최상의 비디오 & 오디오 선택
        'outtmpl': os.path.join(d_pnx, '%(title)s [%(id)s].%(ext)s'),
        'quiet': False,
        'noplaylist': True,
        'merge_output_format': 'mp4',  # 병합 시 MP4로 저장
        'postprocessors': [{
            'key': 'FFmpegVideoConvertor',
            'preferedformat': 'mp4'  # 변환 후 MP4로 저장
        }],
        'geo_bypass': True,  # 지역 제한 우회
        'cookiefile': cookie_f  # 유튜브영상 성인인증
    }
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        for url in url_list:
            url = normalize_youtube_url(url)
            # clip_id = url.split("v=")[-1]
            info = ydl.extract_info(url, download=False)
            clip_id = info.get('id', None)
            feature_str = f"[{clip_id}]"
            if is_f_contained_feature_str(feature_str=feature_str, d_pnx=d_pnx):
                if LTA:
                    pk_print(f"{feature_str} found in file system. Skipping download.", print_color="green")
                f_downloaded = get_f_contained_feature_str(feature_str=feature_str, d_pnx=d_pnx)
                pk_print(f'''f_downloaded="{f_downloaded}"  {'%%%FOO%%%' if LTA else ''}''')
                if f_downloaded:
                    open_pnx_by_ext(pnx=f_downloaded)
                FEATURE_NICK_NAME = get_video_title_with_ytdlp(clip_id=clip_id)
                FEATURE_NICK_NAME = get_url_list_encoded_element(working_list=[FEATURE_NICK_NAME])[0]
                FEATURE_NICK_NAME = get_str_url_decoded(FEATURE_NICK_NAME)
                log_success_to_f(FEATURE_ID=rf"{url} {clip_id}", FEATURE_REMOVAL_ID=clip_id, FEATURE_NICK_NAME=FEATURE_NICK_NAME, f=f_func_n_txt)

                continue

            DESCRIPTION = rf'{url}'
            if LTA:
                pk_print(f'''{DESCRIPTION}  {'%%%FOO%%%' if LTA else ''}''')
            url_list = [str(url)]

            try:
                ydl.download(url_list)
                pk_print(f"f saved in '{d_pnx}'. {url}", print_color="green")
                FEATURE_NICK_NAME = get_video_title_with_ytdlp(clip_id=clip_id)
                FEATURE_NICK_NAME = get_url_list_encoded_element(working_list=[FEATURE_NICK_NAME])[0]
                FEATURE_NICK_NAME = get_str_url_decoded(FEATURE_NICK_NAME)
                log_success_to_f(FEATURE_ID=rf"{url} {clip_id}", FEATURE_REMOVAL_ID=clip_id, FEATURE_NICK_NAME=FEATURE_NICK_NAME, f=f_func_n_txt)
            except:
                import traceback
                pk_print(f'''Download {url} \n {traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}" ''', print_color='red')

                continue


@pk_measure_seconds
def get_window_title(window_title_seg):
    window_title_list = get_window_title_list()
    window_title_set = get_set_from_list(window_title_list)
    for window_title in window_title_set:
        if window_title_seg in window_title:
            return window_title


def restore_all_windows_position():
    import win32con  # pywin32
    import win32gui  # pywin32
    def enum_windows_callback(hwnd, lparam):
        # func_n=inspect.currentframe().f_code.co_name
        if win32gui.IsWindowVisible(hwnd):
            window_title = win32gui.GetWindowText(hwnd)
            # # 예시: 시스템 창이나 보안 프로그램을 제외하는 조건
            # if "System" in window_title or "Security" in window_title:
            #     print(f"시스템 창 또는 보안 프로그램을 건너뛰는 중: {window_title}")
            #     return  # 건너뛰기
            try:
                win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)
                win32gui.SetWindowPos(hwnd, win32con.HWND_TOP, 0, 0, 0, 0, win32con.SWP_NOMOVE | win32con.SWP_NOSIZE)
                print(f"창 {win32gui.GetWindowText(hwnd)}를 복원했습니다.")
            except Exception as e:
                print(f"Error while processing window {hwnd}: {str(e)}")
                pass

    win32gui.EnumWindows(enum_windows_callback, None)


def minimize_all_windows():
    import inspect
    import win32gui  # pywin32
    func_n = inspect.currentframe().f_code.co_name
    win32gui.EnumWindows(minimize_all_windows_callback, None)


def get_txt_dragged():
    import clipboard
    clipboard_current_contents = pk_paste()
    while 1:
        pk_press("ctrl", "c")
        pk_sleep(milliseconds=15)
        text_dragged = pk_paste()
        if clipboard_current_contents != text_dragged:
            break
    clipboard.copy(clipboard_current_contents)
    return text_dragged


def kill_chrome_tab_like_person(url_to_kill):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name

    window_titles = get_window_title_list()
    loop_limit = 50
    for window_title_seg in window_titles:
        if "chrome".lower() in window_title_seg.lower():
            pk_print(working_str=rf'''window_title="{window_title_seg}"  {'%%%FOO%%%' if LTA else ''}''')
            loop_cnt = 0
            while 1:
                ensure_window_to_front(window_title_seg=window_title_seg)
                if loop_cnt == loop_limit:
                    break
                loop_cnt = loop_cnt + 1
                pk_sleep(milliseconds=15)
                pk_press("ctrl", "l")
                pk_sleep(milliseconds=15)
                url_dragged = get_txt_dragged()
                if url_dragged == url_to_kill:
                    pk_print(working_str=rf'''url_to_close="{url_to_kill}"  {'%%%FOO%%%' if LTA else ''}''')
                    pk_print(working_str=rf'''url_dragged="{url_dragged}"  {'%%%FOO%%%' if LTA else ''}''')
                    pk_press("ctrl", "w")
                    # restore_all_windows()
                    return


def refresh_chrome_tab_like_person(url_to_close):
    import inspect
    import time
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    # minimize_all_windows()
    # window_title_seg=get_window_title(window_title_seg="Chrome")
    window_titles = get_window_title_list()

    time_limit_seconds = 10
    time_s = time.time()
    for window_title_seg in window_titles:
        if "chrome".lower() in window_title_seg.lower():
            if time_limit_seconds == 50:
                pk_print(working_str=rf'''window_title="{window_title_seg}"  {'%%%FOO%%%' if LTA else ''}''')
            while 1:
                elapsed_time = time.time() - time_s
                if elapsed_time > time_limit_seconds:
                    break
                ensure_window_to_front(window_title_seg=window_title_seg)
                pk_sleep(milliseconds=15)
                pk_press("ctrl", "l")
                pk_sleep(milliseconds=15)
                url_dragged = get_txt_dragged()
                if url_dragged == url_to_close:
                    pk_print(working_str=rf'''url_to_close="{url_to_close}"  {'%%%FOO%%%' if LTA else ''}''')
                    pk_print(working_str=rf'''url_dragged="{url_dragged}"  {'%%%FOO%%%' if LTA else ''}''')
                    pk_press("f5")
                    # restore_all_windows()
                    return


def move_chrome_tab_by_url(url):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    minimize_all_windows()
    window_title_seg = get_window_title(window_title_seg="Chrome")
    window_titles = get_window_title_list()
    for window_title in window_titles:
        if "Chrome".lower() in window_title.lower():
            ensure_window_to_front(window_title_seg=window_title)
            loop_limit = 30
            loop_cnt = 0
            while 1:
                if loop_cnt == loop_limit:
                    return
                loop_cnt = loop_cnt + 1
                pk_sleep(milliseconds=15)
                pk_press("ctrl", "l")
                pk_sleep(milliseconds=15)
                url_dragged = get_txt_dragged()
                if url_dragged == url:
                    pk_print(f'''url_to_move="{url}"''')
                    pk_print(f'''url_dragged="{url_dragged}"''')
                    break
                pass


def does_normal_tab_exist(driver_selenium, tab_title_negative):
    import inspect
    import random
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    for window in driver_selenium.window_handles:  # 모든 탭 이동
        driver_selenium.switch_to.window(window)  # 각 탭으로 전환
        pk_sleep(milliseconds=random.randint(22, 2222))
        if tab_title_negative not in driver_selenium.title:  # 탭 제목 확인
            return 1
    pk_print(f'''abnormal tab title({tab_title_negative}) detedcted  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
    return 0


def classify_pnxs_to_pkg_document(pnx, without_walking=True):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_LOCAL_PKG_CACHE, F_SUCCESS_LOG, F_DB_YAML
    func_n = inspect.currentframe().f_code.co_name
    # pnx_todo가 유효한 d인지 확인
    if is_f(pnx=pnx):
        pk_print(f"{pnx} 는 정리할 수 있는 d가 아닙니다")
        return

    # f과 d get
    txt_to_exclude_list = [
        F_DB_YAML,
        F_SUCCESS_LOG,
        F_LOCAL_PKG_CACHE,
    ]
    if without_walking == False:
        d_list, f_list = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list)
    else:
        d_list, f_list = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list, without_walking=0)

    # f 처리
    x_allowed = [".txt", '.ximind', '.pdf', '.xls']
    x_allowed = x_allowed + get_list_replaced_element_from_str_to_upper_case(working_list=x_allowed)
    pnx = get_pn(pnx)
    dst = rf"{pnx}\pkg_document"
    for f in f_list:
        f = f[0]
        file_p = get_p(f)
        file_x = get_x(f).replace(".", "")  # 확장자에서 점(.) remove
        if file_x in [ext.replace(".", "") for ext in x_allowed]:  # x_allowed의 확장자와 비교
            ensure_pnx_made(dst, mode="d")
            move_pnx(pnx=f, d_dst=dst)
            pk_print(working_str=rf'''f="{f}"  {'%%%FOO%%%' if LTA else ''}''')
    pk_print(working_str=rf'''dst="{dst}"  {'%%%FOO%%%' if LTA else ''}''')


def classify_pnxs_to_pk_image(pnx, without_walking=True):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_LOCAL_PKG_CACHE, F_SUCCESS_LOG, F_DB_YAML
    if is_f(pnx=pnx):
        pk_print(f"{pnx} 는 정리할 수 있는 d가 아닙니다")
        return

    # f과 d get
    txt_to_exclude_list = [
        F_DB_YAML,
        F_SUCCESS_LOG,
        F_LOCAL_PKG_CACHE,
    ]
    if without_walking == False:
        d_list, f_list = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list)
    else:
        d_list, f_list = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list, without_walking=0)

    # f 처리
    x_allowed = [".png", '.jpg', '.jpeg', '.jfif', '.webp']
    x_allowed = x_allowed + get_list_replaced_element_from_str_to_upper_case(working_list=x_allowed)
    pnx = get_pn(pnx)
    dst = rf"{pnx}\pk_image"
    for f in f_list:
        f = f[0]
        file_p = get_p(f)
        file_x = get_x(f).replace(".", "")  # 확장자에서 점(.) remove
        if file_x in [ext.replace(".", "") for ext in x_allowed]:  # x_allowed의 확장자와 비교
            ensure_pnx_made(dst, mode="d")
            move_pnx(pnx=f, d_dst=dst)
            pk_print(working_str=rf'''f="{f}"  {'%%%FOO%%%' if LTA else ''}''')
    pk_print(working_str=rf'''dst="{dst}"  {'%%%FOO%%%' if LTA else ''}''')


def classify_pnxs_to_pkg_video(pnx, without_walking=True):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_LOCAL_PKG_CACHE, F_SUCCESS_LOG, F_DB_YAML
    func_n = inspect.currentframe().f_code.co_name

    # pnx_todo가 유효한 d인지 확인
    if is_f(pnx=pnx):
        pk_print(f"{pnx} 는 정리할 수 있는 d가 아닙니다")
        return

    # f과 d get
    txt_to_exclude_list = [
        F_DB_YAML,
        F_SUCCESS_LOG,
        F_LOCAL_PKG_CACHE,
    ]
    if without_walking == False:
        d_list, f_list = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list)
    else:
        d_list, f_list = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list, without_walking=0)

    # f 처리
    x_allowed = [".mp4", '.avi', '.mkv', '.webm', '.mpg', '.flv', '.wmv']
    x_allowed = x_allowed + get_list_replaced_element_from_str_to_upper_case(working_list=x_allowed)
    pnx = get_pn(pnx)
    dst = rf"{pnx}\pkg_video"
    f = None
    for f in f_list:
        f = f[0]
        file_p = get_p(f)
        file_x = get_x(f).replace(".", "")  # 확장자에서 점(.) remove
        if file_x in [ext.replace(".", "") for ext in x_allowed]:  # x_allowed의 확장자와 비교
            ensure_pnx_made(pnx=dst, mode="d")
            move_pnx(pnx=f, d_dst=dst)
            pk_print(working_str=rf'''f="{f}"  {'%%%FOO%%%' if LTA else ''}''')
    pk_print(working_str=rf'''dst="{dst}"  {'%%%FOO%%%' if LTA else ''}''')


def classify_pnxs_to_pkg_soundtrack(pnx, without_walking=True):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_LOCAL_PKG_CACHE, F_SUCCESS_LOG, F_DB_YAML
    func_n = inspect.currentframe().f_code.co_name
    # 유효d 확인
    if is_f(pnx=pnx):
        pk_print(f"{pnx} 는 정리할 수 있는 d가 아닙니다")
        return

    # f과 d get
    txt_to_exclude_list = [
        F_DB_YAML,
        F_SUCCESS_LOG,
        F_LOCAL_PKG_CACHE,
    ]
    if without_walking == False:
        d_list, f_list = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list)
    else:
        d_list, f_list = get_sub_pnx_list(pnx=pnx, txt_to_exclude_list=txt_to_exclude_list, without_walking=0)

    # f 처리
    x_allowed = [".mp3", '.flac', '.wav']
    x_allowed = x_allowed + get_list_replaced_element_from_str_to_upper_case(working_list=x_allowed)
    pnx = get_pn(pnx)
    dst = rf"{pnx}\pkg_soundtrack"
    for f in f_list:
        f = f[0]
        file_p = get_p(f)
        file_x = get_x(f).replace(".", "")  # 확장자에서 점(.) remove
        if file_x in [ext.replace(".", "") for ext in x_allowed]:  # x_allowed의 확장자와 비교
            ensure_pnx_made(dst, mode="d")
            move_pnx(pnx=f, d_dst=dst)
            pk_print(working_str=rf'''f="{f}"  {'%%%FOO%%%' if LTA else ''}''')
    pk_print(working_str=rf'''dst="{dst}"  {'%%%FOO%%%' if LTA else ''}''')


def classify_pnx_list_to_pkg_compressed(src, without_walking=True):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_LOCAL_PKG_CACHE, F_SUCCESS_LOG, F_DB_YAML
    func_n = inspect.currentframe().f_code.co_name
    # d 유효성 확인
    if is_f(pnx=src):
        pk_print(f"{src}  {'%%%FOO%%%' if LTA else ''}")
        return

    # f과 d get
    txt_to_exclude_list = [
        F_DB_YAML,
        F_SUCCESS_LOG,
        F_LOCAL_PKG_CACHE,
    ]

    if without_walking == False:
        d_list, f_list = get_sub_pnx_list(pnx=src, txt_to_exclude_list=txt_to_exclude_list)
    else:
        d_list, f_list = get_sub_pnx_list(pnx=src, txt_to_exclude_list=txt_to_exclude_list, without_walking=0)

    # f 처리
    x_allowed = [".zip", '.tar']
    x_allowed = x_allowed + get_list_replaced_element_from_str_to_upper_case(working_list=x_allowed)
    src = get_pn(src)
    dst = rf"{src}\pkg_compressed"
    for f in f_list:
        f = f[0]
        file_p = get_p(f)
        file_x = get_x(f).replace(".", "")  # 확장자에서 점(.) remove
        if file_x in [ext.replace(".", "") for ext in x_allowed]:  # x_allowed의 확장자와 비교
            ensure_pnx_made(dst, mode="d")
            move_pnx(pnx=f, d_dst=dst)
            pk_print(working_str=rf'''file_new="{f}"  {'%%%FOO%%%' if LTA else ''}''')
    pk_print(working_str=rf'''dst="{dst}"  {'%%%FOO%%%' if LTA else ''}''')


def get_f_n_moved_pattern_to_front(pattern, item_pnx):
    import re
    match = re.search(pattern=pattern, string=item_pnx)
    n = get_n(item_pnx)
    p = get_p(item_pnx)
    x = get_x(item_pnx)
    if match:
        pattern = match.group(1)
        item_pnx_new = rf"{p}\{pattern}_{n.replace(pattern, '')}{x}"
        return item_pnx_new
    else:
        # 패턴이 없으면 원래 f명 반환
        return item_pnx


def get_str_moved_pattern_to_rear(pattern, item_pnx):
    import re
    match = re.search(pattern=pattern, string=item_pnx)
    n = get_n(item_pnx)
    p = get_p(item_pnx)
    x = get_x(item_pnx)
    if match:
        pattern = match.group(1)
        item_pnx_new = rf"{p}\{n.replace(pattern, '')}_{pattern}{x}"
        return item_pnx_new
    else:
        # 패턴이 없으면 원래 f명 반환
        return item_pnx


def save_all_drive_pnxs_to_text_file2():  # 루프 수정필요 # 이 함수는 거의 필요 없을 것 같다. 관심d만 확인하는 것으로 충분해 보인다.
    import inspect
    from pkg_py.pk_core_constants import Encoding
    from pkg_py.pk_core_constants import D_PKG_TXT, D_PROJECT
    func_n = inspect.currentframe().f_code.co_name
    f_func_n_txt = rf'{D_PROJECT}\pkg_txt\{func_n}.txt'
    ensure_pnx_made(pnx=f_func_n_txt, mode="item")

    # if not is_window_open(window_title=f_func_n_txt):
    #     open_pnx(f_func_n_txt, debug_mode=True)

    # 1. 특정 경로를 제외할 텍스트 f에서 경로 읽어오기
    def load_pnxs_exclude(file_path):
        import inspect
        func_n = inspect.currentframe().f_code.co_name
        exclude_paths = set()
        try:
            with open(file=file_path, mode='r', encoding=Encoding.UTF8.value) as file:
                for line in file:
                    exclude_paths.add(line.strip())
        except PermissionError as e:
            print(f"PermissionError: {e}. Check if the item is accessible and you have the right permissions.")
        except Exception as e:
            print(f"Error opening item {file_path}: {e}")
        return exclude_paths

    # 2. 모든 드라이브에서 f 목록 가져오기
    def get_drives_connected():
        import inspect
        import os
        import string
        from pkg_py.pk_colorful_cli_util import pk_print
        func_n = inspect.currentframe().f_code.co_name
        drives = []
        for letter in string.ascii_uppercase:
            drive = f"{letter}:\\"
            if os.path.exists(drive):
                drives.append(drive)
        pk_print(working_str=rf'''drives="{drives}"  {'%%%FOO%%%' if LTA else ''}''')
        return drives

    # 3. 드라이브에서 f 검색하고 처리하기
    def list_files_in_drives(exclude_paths_txt):

        import inspect
        import os
        from pkg_py.pk_colorful_cli_util import pk_print
        from pkg_py.pk_core_constants import D_PKG_TXT
        func_n = inspect.currentframe().f_code.co_name
        exclude_paths = load_pnxs_exclude(exclude_paths_txt)
        drives = get_drives_connected()
        cnt = 0
        pnxs = []
        limit = 10000
        cnt_f_list = limit
        cnt_txt_files = 0
        temp = set()
        # 모든 드라이브에서 f 탐색
        for drive in drives:
            pk_print(working_str=rf'''drive="{drive}"  {'%%%FOO%%%' if LTA else ''}''')
            for root, d_nx_list, f_nx_list in os.walk(drive):
                for f_nx in f_nx_list:
                    f = os.path.join(root, f_nx)
                    # pk_print(str_working=rf'''f="{f}"  {'%%%FOO%%%' if LTA else ''}''')
                    cnt_f_list = cnt_f_list - 1
                    pnxs.append(f)
                    if cnt_f_list == 0:
                        # pk_print(str_working=rf'''f="{f}"  {'%%%FOO%%%' if LTA else ''}''')
                        cnt_f_list = limit
                        cnt_txt_files = cnt_txt_files + 1
                        # pk_print(str_working=rf'''cnt_txt_files="{cnt_txt_files}"  {'%%%FOO%%%' if LTA else ''}''')

                        output_pnx_txt_before = rf"{D_PKG_TXT}\{func_n}_{cnt_txt_files - 1}.txt"
                        temp = get_list_from_f(f=output_pnx_txt_before)
                        if None != temp:
                            if 0 == len(temp):
                                cnt_txt_files = cnt_txt_files - 1

                        output_pnx_txt = rf"{D_PKG_TXT}\{func_n}_{cnt_txt_files}.txt"
                        # pk_print(str_working=rf'''output_pnx_txt="{output_pnx_txt}"  {'%%%FOO%%%' if LTA else ''}''')
                        # if any(exclude_path in f for exclude_path in exclude_paths):
                        #     continue
                        with open(file=output_pnx_txt, mode='w', encoding=Encoding.UTF8.value) as f:
                            for pnx in pnxs:
                                cnt = cnt + 1
                                # temp.add(rf"{pnx.split("\\")[0]}\{pnx.split("\\")[1]}")
                                # print(temp)
                                for exclude_path in exclude_paths:
                                    if exclude_path in pnx:
                                        break
                                else:
                                    if not pnx.strip() == "":
                                        f.write(f'{pnx}\n')
                                        pk_print(working_str=rf'''cnt="{cnt}" pnxs="{pnx}" output_pnx_txt="{output_pnx_txt}"  {'%%%FOO%%%' if LTA else ''}''')
                                    else:
                                        pk_print(f'''없다''')
        pk_print(working_str=rf'''temp="{temp}"  {'%%%FOO%%%' if LTA else ''}''')

    # exec
    exclude_paths_txt = rf'{D_PKG_TXT}\{func_n}_exclude_paths.txt'
    ensure_pnx_made(pnx=exclude_paths_txt, mode='item')
    list_files_in_drives(exclude_paths_txt)


def get_element_random(working_list):
    import random
    return random.choice(working_list)


def make_pnx_interested_list_to_f_txt_x(d_working_list, exclusion_list):
    import inspect
    from pkg_py.pk_core_constants import D_PKG_TXT
    # todo : chore : f 내용 초기화
    func_n = inspect.currentframe().f_code.co_name
    pnx_processed_list = []
    file_cnt = 0
    write_cnt = 0
    write_cnt_limit = 1000000
    for pnx_interested in d_working_list:
        pnxs_with_walking = get_pnx_list(d_working=pnx_interested, mode="f", with_walking=1)

        # 'pnxs_exclude'를 set으로 변경하여 'in' 연산을 최적화
        func_n_file_cnt_txt = None
        for pnx_with_walking in pnxs_with_walking:
            # 빠른 'in' 연산을 위해 set으로 변환된 pnxs_exclude 활용
            if any(pnx_exclude in pnx_with_walking for pnx_exclude in exclusion_list):
                continue  # 'pnx_exclude'에 포함되면 건너뛰기
            # 'exclude' 목록에 포함되지 않으면 'pnx_processed_list'에 추가
            pnx_processed_list.append(pnx_with_walking)
            # pk_print(str_working=rf'''len(pnx_processed_list)="{len(pnx_processed_list)}"  {'%%%FOO%%%' if LTA else ''}''')
            if write_cnt == write_cnt_limit % 2 == 0:
                file_cnt = file_cnt + 1
                # print_iterable_as_vertical(item_iterable=pnx_processed_list, item_iterable_n="pnx_processed_list")
                # func_n_file_cnt_txt=rf"{D_PKG_TXT}\{func_n}_{file_cnt}.txt"
                # write_list_to_file(texts=pnx_processed_list, pnx=func_n_file_cnt_txt, mode="w")
            func_n_file_cnt_txt = rf"{D_PKG_TXT}\{func_n}_{file_cnt}.txt"
            # pk_print(str_working=rf'''write_cnt="{write_cnt}"  {'%%%FOO%%%' if LTA else ''}''')
            write_str_to_f(txt=f"{pnx_with_walking}\n", f=func_n_file_cnt_txt, mode="a")
            write_cnt = write_cnt + 1
            if write_cnt == write_cnt_limit % 2 == 0:
                window_title = rf"{func_n}_{file_cnt}"
                # if not is_window_open(window_title_seg=window_title):
                #     open_pnx(pnx=func_n_file_cnt_txt)


def make_pnx_interested_list_to_f_txt(pnx_interested_list=None, string_exclude=None):
    import inspect
    from pkg_py.pk_core_constants import D_DOWNLOADS

    from pkg_py.pk_core_constants import D_HOME, D_PKG_TXT
    func_n = inspect.currentframe().f_code.co_name

    # pnx_interested_list=[]
    if pnx_interested_list is None:
        pnx_interested_list = [
            rf'{D_DOWNLOADS}',
            rf'{D_HOME}\AppData\Roaming\bittorrent',

            rf'D:\\',
            rf'E:\\',
            rf'F:\\',
        ]
    # pnxs_exclude=[]
    if pnx_interested_list is None:
        string_exclude = [
            rf'{D_DOWNLOADS}\[]\docker_image_maker\venv',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\ios',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\macos',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\windows',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\web',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\linux',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\lib',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\build',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\asset',
            rf'{D_DOWNLOADS}\[]\test_flutter(모바일 프론트 엔드 용도)\android',

            rf'D:\$RECYCLE.BIN',
            rf'D:\System Volume Information',

            rf'E:\$RECYCLE.BIN',
            rf'E:\System Volume Information',

            rf'F:\$RECYCLE.BIN',
            rf'F:\System Volume Information',

            rf'deprecated',
            rf'archived',
            rf'.git',
            rf'.idea',
            rf'venv',
            rf'node_modules',
            rf'test_flutter',
            rf'pkg_font',
            rf'telegram memo export by static web',
            rf'docker_image_maker',
            rf'e-magazine',
            rf'netlify-web',
        ]

    pnx_processed_list = []
    f_func_n_txt = rf"{D_PKG_TXT}\{func_n}.txt"
    write_str_to_f(txt=f"", f=f_func_n_txt, mode="w")  # 내용 초기화
    for pnx_interested in pnx_interested_list:
        pnxs_with_walking = get_pnx_list(d_working=pnx_interested, mode="f", with_walking=1)
        for pnx_with_walking in pnxs_with_walking:
            if any(pnx_exclude in pnx_with_walking for pnx_exclude in string_exclude):
                continue
            pnx_processed_list.append(pnx_with_walking)
            write_str_to_f(txt=f"{pnx_with_walking}\n", f=f_func_n_txt, mode="a")


def get_screenshot():
    import inspect
    import numpy as np
    import pyautogui
    func_n = inspect.currentframe().f_code.co_name
    # 화면 캡처 (PyAutoGUI를 사용)
    screenshot = pyautogui.screenshot()
    # PIL 이미지를 OpenCV 이미지로 변환
    open_cv_image = np.array(screenshot)
    # RGB → BGR 색상 변환 (OpenCV는 BGR 형식 사용)
    import cv2
    open_cv_image = cv2.cvtColor(open_cv_image, cv2.COLOR_RGB2BGR)
    return open_cv_image


def get_extreact_texts_from_image_via_easyocr(image):
    import inspect
    import easyocr
    func_n = inspect.currentframe().f_code.co_name
    # EasyOCR 객체 생성
    reader = easyocr.Reader(['en', 'ko'])  # 영어와 한글을 동시에 처리하려면 'en', 'ko' 지정
    result = reader.readtext(image)
    return result


def is_prompt_in_text(prompt, text):
    if prompt.lower() in text.lower():
        return 1
    return 0


def get_all_text_with_coordinates_via_easy_ocr(image):
    import inspect
    import easyocr
    func_n = inspect.currentframe().f_code.co_name
    # EasyOCR 객체 생성
    reader = easyocr.Reader(['en', 'ko'])  # 영어와 한글을 동시에 처리하려면 'en', 'ko' 지정
    results = reader.readtext(image)

    # 추출된 텍스트와 위치 반환
    text_with_coordinates = [(result[1], result[0]) for result in results]
    return text_with_coordinates


def get_coordinates_bounding_box(image, str_working):
    import inspect
    import easyocr
    func_n = inspect.currentframe().f_code.co_name
    # EasyOCR로 텍스트 및 위치 추출
    reader = easyocr.Reader(['en', 'ko'])  # 영어와 한글을 동시에 처리하려면 'en', 'ko' 지정
    results = reader.readtext(image)

    # 추출된 텍스트와 위치 반환
    for result in results:
        text = result[1]  # result[1]은 텍스트
        if str_working.lower() in text.lower():
            coord_bounding_box = result[0]  # result[0]은 바운딩 박스 좌표
            return coord_bounding_box
    print(f"{str_working}에 대한 바운딩 박스가 화면에 없습니다. ")


def get_center_of_bounding_box(bounding_box):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    """
    바운딩 박스 좌표를 받아서, 그 중심 좌표를 반환하는 함수.

    :param bounding_box: 바운딩 박스 좌표 [(x1, y1), (x2, y2), (x3, y3), (x4, y4)]
    :return: 중심 좌표 (x, y)
    """
    # 네 점의 x, y 좌표를 각각 합산
    if bounding_box is None:
        return None
    x_coords = [point[0] for point in bounding_box]
    y_coords = [point[1] for point in bounding_box]

    # x, y 평균값을 구하여 중심 좌표 계산
    center_x = sum(x_coords) / 4
    center_y = sum(y_coords) / 4

    return center_x, center_y


def get_text_coordinates_via_easy_ocr(string):  # 한글인식 잘 안되는 듯하다
    import inspect

    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    # 화면 캡처
    screenshot = get_screenshot()

    # EsayOCR을 통해 모든텍스트 바운딩박스좌표 추출
    # coordinates_bounding_box=get_all_text_with_coordinates_via_easy_ocr(screenshot)
    # print_list_as_vertical(working_list=coordinates_bounding_box, items_name="coordinates_bounding_box")

    # EsayOCR을 통해 특정텍스트 바운딩박스좌표 추출
    coordinates_bounding_box = get_coordinates_bounding_box(image=screenshot, str_working=string)
    # print_list_as_vertical(working_list=coordinates_bounding_box, items_name="coordinates_bounding_box")

    # 중심 좌표 구하기
    if get_center_of_bounding_box(coordinates_bounding_box) is not None:
        center_x, center_y = get_center_of_bounding_box(coordinates_bounding_box)
        # pk_print(str_working=rf'''center_x="{center_x}"  {'%%%FOO%%%' if LTA else ''}''')
        # pk_print(str_working=rf'''center_y="{center_y}"  {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''"text_coordinates=({center_x}, {center_y})"''')
        return center_x, center_y
    return None


def reconnect_to_qcy_h3_anc_headset_via_bluetooth():  # toogle_to_qcy_h3_anc_headset_via_bluetooth 이게 더 작명이 나은것..
    import inspect
    import time

    func_n = inspect.currentframe().f_code.co_name
    # Bluetooth 설정창 띄우기
    cmd = 'start ms-settings:bluetooth'
    cmd_to_os_like_person_as_admin(cmd=cmd)
    window_title_seg = "설정"
    time_limit = 10
    time_s = time.time()
    while 1:
        if not is_window_opened(window_title_seg=window_title_seg):
            ensure_window_to_front(window_title_seg=window_title_seg)
        else:
            break
        # pk_print(str_working=time.time() - time_s)
        if time.time() - time_s > time_limit:
            break
        pk_sleep(seconds=0.5)

    # string 더블 클릭
    click_string(string="QCY H3 ANC HEADSET", doubleclick_mode=True)

    # string 더블 클릭
    import asyncio
    asyncio.run(shoot_custom_screenshot_via_asyncio())
    # click_img_via_autogui()

    # string 더블 클릭
    # click_string(string="연결", doubleclick_mode=True)
    pass


#
# def kill_chrome_tab_duplicated():
#     func_n=inspect.currentframe().f_code.co_name
#     # minimize_all_windows()
#     # window_title_seg=get_window_title(window_title_seg="Chrome")
#
#     window_title="Chrome"
#     move_window_to_front(window_title_seg=window_title, debug_mode=True)
#
#     chrome_tab_urls_duplicated=[]
#     chrome_tab_urls_processed=[]  # 이미 처리된 URL을 저장하는 리스트
#     chrome_tab_urls_len_before=0
#     loop_limit=10
#     loop_out_cnt=0
#
#     while 1:
#         pk_print(str_working=rf'''loop_out_cnt="{loop_out_cnt}"  {'%%%FOO%%%' if LTA else ''}''')
#         pk_print(str_working=rf'''loop_limit="{loop_limit}"  {'%%%FOO%%%' if LTA else ''}''')
#
#         # 탭을 전환하고 URL을 가져옵니다.
#         press("ctrl", "l")
#         pk_sleep(milliseconds=5)
#         url_dragged=get_text_dragged()
#
#         # 다시 탭을 전환하고 URL을 가져옵니다.
#         press("ctrl", "tab")
#         pk_sleep(milliseconds=5)
#         press("ctrl", "l")
#         pk_sleep(milliseconds=5)
#         url_dragged_new=get_text_dragged()
#         pk_print(str_working=rf'''url_dragged="{url_dragged}"  {'%%%FOO%%%' if LTA else ''}''')
#         pk_print(str_working=rf'''url_dragged_new="{url_dragged_new}"  {'%%%FOO%%%' if LTA else ''}''')
#
#         # URL이 동일한지 확인하여 중복된 URL인지 체크
#         if url_dragged == url_dragged_new:
#             # if url_dragged not in chrome_tab_urls_duplicated:
#             #     chrome_tab_urls_duplicated.append(url_dragged)
#             #     pk_print(str_working=rf'''Added duplicate URL: "{url_dragged}"  {'%%%FOO%%%' if LTA else ''}''')
#
#             # 중복된 URL의 탭을 닫음
#             press("ctrl", "w")
#             loop_out_cnt -= 1
#         loop_out_cnt += 1
#
#         # 처리된 URL을 `chrome_tab_urls_processed`에 추가
#         chrome_tab_urls_processed.append(url_dragged)
#         pk_print(str_working=rf'''chrome_tab_urls_processed="{chrome_tab_urls_processed}"  {'%%%FOO%%%' if LTA else ''}''')
#
#         # 중복된 탭을 모두 remove했으면 종료
#         if loop_out_cnt == loop_limit:
#             # get_list_removed_element_duplicated(chrome_tab_urls_processed)
#             pk_print(str_working=rf'''Counter(chrome_tab_urls_processed)="{Counter(chrome_tab_urls_processed)}"  {'%%%FOO%%%' if LTA else ''}''')
#             # if loop_out_cnt >= loop_limit:
#             #     pk_print(str_working=rf'''중복된 탭을 모두 remove  {'%%%FOO%%%' if LTA else ''}''')
#             #     break  # 더 이상 중복된 탭이 없으므로 종료
#             return

def kill_chrome_tab_duplicated():
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name

    chrome_tab_urls_processed = []  # 이미 처리된 URL을 저장하는 리스트
    loop_limit = 10
    loop_out_cnt = 0

    while 1:
        window_title = "Chrome"
        if is_window_opened(window_title_seg=window_title):
            ensure_window_to_front(window_title_seg=window_title)

        pk_print(working_str=rf'''loop_out_cnt="{loop_out_cnt}"  {'%%%FOO%%%' if LTA else ''}''')
        pk_print(working_str=rf'''loop_limit="{loop_limit}"  {'%%%FOO%%%' if LTA else ''}''')

        # 탭을 전환하고 URL을 가져옵니다.
        pk_press("ctrl", "l")
        pk_sleep(milliseconds=5)
        url_dragged = get_txt_dragged()

        # 중복 여부 확인
        if url_dragged in chrome_tab_urls_processed:
            pk_print(working_str=rf'''URL already processed: "{url_dragged}"  {'%%%FOO%%%' if LTA else ''}''')
            pk_press("ctrl", "tab")  # 다음 탭으로 이동
            loop_out_cnt += 1
            if loop_out_cnt >= loop_limit:
                break
            continue

        # 다음 탭으로 전환 후 URL 가져오기
        pk_press("ctrl", "tab")
        pk_sleep(milliseconds=5)
        pk_press("ctrl", "l")
        pk_sleep(milliseconds=5)
        url_dragged_new = get_txt_dragged()

        pk_print(working_str=rf'''url_dragged="{url_dragged}"  {'%%%FOO%%%' if LTA else ''}''')
        pk_print(working_str=rf'''url_dragged_new="{url_dragged_new}"  {'%%%FOO%%%' if LTA else ''}''')

        # 중복된 URL이면 탭 닫기
        if url_dragged == url_dragged_new:
            pk_print(working_str=rf'''Closing duplicate tab for URL: "{url_dragged}"  {'%%%FOO%%%' if LTA else ''}''')
            pk_press("ctrl", "w")  # 탭 닫기
            continue

        # 처리된 URL을 리스트에 추가
        chrome_tab_urls_processed.append(url_dragged)
        pk_print(working_str=rf'''chrome_tab_urls_processed="{chrome_tab_urls_processed}"  {'%%%FOO%%%' if LTA else ''}''')

        # 최대 반복 횟수 초과 시 종료
        loop_out_cnt += 1
        if loop_out_cnt >= loop_limit:
            break


def decode_via_pk_system(text_encoded):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    text_encoded = text_encoded.replace("2", "8")
    text_encoded = text_encoded.replace("3", "7")
    text_encoded = text_encoded.replace("4", "6")
    text_encoded = text_encoded.replace("6", "4")
    text_encoded = text_encoded.replace("7", "3")
    text_encoded = text_encoded.replace("8", "2")
    return text_encoded


def replace_text_B_and_text_C_interchangeably_at_text_A_by_using_(____text_A, ____text_B, ____text_C, _____and):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    foo_foo = "{{kono foo wa sekai de uituna mono ni motomo chikai desu}}"
    text_special = "{{no}}"
    text_B_cnt = ____text_A.count(____text_B)
    foo_list = []
    foo_str = ""
    foo_cmt = 0
    if ____text_C == "":
        ____text_A = ____text_A.replace(____text_B, ____text_C)
    elif text_special in ____text_C:
        pk_print(working_str="text_A 에서 " + ____text_B + " 를 총" + str(text_B_cnt) + "개 발견하였습니다")
        foo_list = ____text_A.split(____text_B)
        if ____text_B in ____text_C:
            foo_cmt = 0
            for j in foo_list:
                if j == foo_list[-1]:
                    pass
                else:
                    foo_str = foo_str + j + ____text_C.split(text_special)[0] + str(foo_cmt)
                foo_cmt = foo_cmt + 1
            ____text_A = ""
            ____text_A = foo_str
        else:
            foo_cmt = 0
            for j in foo_list:
                if j == foo_list[-1]:
                    pass
                else:
                    foo_str = foo_str + j + ____text_C.split(text_special)[0] + str(foo_cmt)
                foo_cmt = foo_cmt + 1
            ____text_A = ""
            ____text_A = foo_str
    else:
        ____text_A = ____text_A.replace(____text_C, foo_foo)
        ____text_A = ____text_A.replace(____text_B, ____text_C)
        ____text_A = ____text_A.replace(foo_foo, ____text_B)


def act_via_interchangeable_triangle_model_by_using_(____text_A, ____text_B, ____text_C, _____and):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    foo_foo = "{{kono foo wa sekai de uituna mono ni motomo chikai desu}}"
    if ____text_C == "":
        ____text_A = ____text_A.replace(____text_B, ____text_C)
    else:
        ____text_A = ____text_A.replace(____text_C, foo_foo)
        ____text_A = ____text_A.replace(____text_B, ____text_C)
        ____text_A = ____text_A.replace(foo_foo, ____text_B)


def print_built_in_info(thing_curious):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    pk_print(f"{inspect.currentframe().f_code.co_name} {str(thing_curious.__code__.co_varnames)}")
    pk_print(working_str="_______________________________________________________________ " + str() + "(" + str(thing_curious) + ") s")
    pk_print(working_str="print(inspect.getsource(thing_curious))")
    print(inspect.getsource(thing_curious))
    pk_print(working_str="for i in inspect.getmembers(thing_curious_):")
    for i in inspect.getmembers(thing_curious):
        print(i)
    pk_print(working_str="print(help(thing_curious))")
    print(help(thing_curious))
    pk_print(working_str="[x for x in dir(thing_curious) if '__' not in x]")
    foo = [x for x in dir(thing_curious) if '__' not in x]
    # dir() 함수는 값 없이 지정된 객체의 모든 속성과 메서드를 반환합니다 .
    # 이 함수는 모든 속성과 메서드를 반환하며, 모든 개체에 대한 기본값인 내장 속성도 반환합니다.
    pk_print(working_str="[x for x in dir(thing_curious) if '__' not in x]")


def print_function_info(thing_curious):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    pk_print(f"{inspect.currentframe().f_code.co_name} {str(thing_curious.__code__.co_varnames)}")
    print(help(thing_curious))
    pk_print(f'# of the Arguments : {thing_curious.__code__.co_argcount}')
    # pk_print(f'Name of the Arguments : {thing_curious.__code__.co_varnames}')
    pk_print(working_str="┌>print via getsource s")
    print(inspect.getsource(thing_curious))
    pk_print(working_str="└>print via getsource e")


def print_event_info_(event, thing_curious):
    import inspect
    """
        jhp_debugger.print_event_info_(event)
        # └>call sample
    """
    func_n = inspect.currentframe().f_code.co_name
    print(str(event))
    # print(event.type())
    # if type(thing_curious)==str:
    #     print('{{mkr}}')
    # if type(thing_curious)==list:
    #     print(thing_curious[str(event.type())])
    # if type(thing_curious) == tuple:
    #     print('{{mkr}}')


def find_pnx_interested_list_from_txt_f_x(including_texts=[], exclude_texts=[], except_extensions=[], f_ext_list_including=[]):
    import os
    import re
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PKG_TXT

    # d 내의 모든 f 리스트 가져오기
    # d="."  # 현재 d에서 확인
    d = D_PKG_TXT
    # d=get_pnx_os_style(pnx=d)
    # pattern=rf"{re.escape(d)}\update_pnx_interested_list_to_text_file_\d\.txt$"
    # pattern=rf"{re.escape(d)}\\update_pnx_interested_list_to_text_file_\d\.txt$"
    pattern = rf"^update_pnx_interested_list_to_text_file_\d\.txt$"
    pk_print(working_str=rf'''pattern="{pattern}"  {'%%%FOO%%%' if LTA else ''}''')
    # f_list_in_d 아니고 f_nx_list_in_d 인지 확인필요
    f_list_in_d = os.listdir(d)
    print_iterable_as_vertical(item_iterable=f_list_in_d, item_iterable_n="f_list_in_d")
    f_nx_list_matched = [file for file in f_list_in_d if re.match(pattern, file)]
    pnxs_required = []
    if f_nx_list_matched:
        pk_print(working_str=rf'''files_matched="{f_nx_list_matched}"  {'%%%FOO%%%' if LTA else ''}''')
        for files_nx_matched in f_nx_list_matched:
            pnx = rf"{d}\{files_nx_matched}"
            pk_print(working_str=rf'''pnx="{pnx}"  {'%%%FOO%%%' if LTA else ''}''')
            lines = get_list_from_f(f=pnx)
            for line in lines:
                if not including_texts == []:
                    if any(text in line for text in including_texts):
                        pnxs_required.append(line)
                else:
                    pnxs_required.append(line)
        pnxs_required = get_list_replaced_element_from_str_to_str(working_list=pnxs_required, from_str="\n", to_str="")
        # print_list_as_vertical(working_list=pnxs_required, items_name="pnxs_required")
    else:
        pk_print(working_str="정규식 패턴에 맞는 f이 존재하지 않습니다.")

    pnxs_excluded = []
    for pnx in pnxs_required:
        # txt_to_exclude_list의 어떠한 요소도 포함되지 않은 경우만 추가
        if not any(exclude_text in pnx for exclude_text in exclude_texts):  # 배제할 확장자 체크
            f_ext_list = os.path.splitext(pnx)[1]
            if f_ext_list not in except_extensions:  # 제외할 확장자 체크
                if not f_ext_list_including == []:
                    if any(f_ext_list == f_ext for f_ext in f_ext_list_including):  # 반드시 포함할 확장자 체크
                        pnxs_excluded.append(pnx)
                else:
                    pnxs_excluded.append(pnx)
    print_iterable_as_vertical(item_iterable=pnxs_excluded, item_iterable_n="pnxs_excluded")
    return pnxs_excluded


def get_list_interested_from_list(working_list, string_list_include=[], string_list_exclude=[], except_extensions=[], ext_list_include=[], string_list_include_any=[]):
    from pkg_py.pk_colorful_cli_util import pk_print
    import os
    if working_list is None:
        pk_print("working_list가 None입니다. 올바른 리스트를 전달하세요.", print_color='red')
    pnxs_included = []
    for item in working_list:
        if not string_list_include == []:
            if any(text in item for text in string_list_include):
                pnxs_included.append(item)
        else:
            pnxs_included.append(item)
    pnxs_included = get_list_replaced_element_from_str_to_str(working_list=pnxs_included, from_str="\n", to_str="")
    # print_list_as_vertical(working_list=pnxs_included, working_list_n='pnxs_included')

    pnxs_excluded = []
    for pnx in pnxs_included:
        # txt_to_exclude_list의 어떠한 요소도 포함되지 않은 경우만 추가
        if not any(exclude_text in pnx for exclude_text in string_list_exclude):  # 배제할 확장자 체크
            file_extension = os.path.splitext(pnx)[1]
            if file_extension not in except_extensions:  # 제외할 확장자 체크
                if not ext_list_include == []:
                    if any(file_extension == ext for ext in ext_list_include):  # 반드시 포함할 확장자 체크
                        pnxs_excluded.append(pnx)
                else:
                    pnxs_excluded.append(pnx)
    # print_list_as_vertical(working_list=pnxs_excluded, working_list_n="pnxs_excluded")

    pnxs_required = []
    if not string_list_include_any == []:
        for item in pnxs_excluded:
            if any(include in item for include in string_list_include_any):
                pnxs_required.append(item)
    else:
        pnxs_required = pnxs_excluded
    return pnxs_required


def ask_to_chat_gpt(question):
    from pkg_py.pk_core_constants import D_PROJECT
    import pyautogui
    # 페이지 열기
    url = "https://chatgpt.com/"
    cmd_to_os(cmd=f'explorer "{url}"')

    # 창 앞으로 이동
    window_title = "Chrome"
    window_title_seg = window_title,
    ensure_window_to_front(window_title_seg=window_title_seg)

    # chrome 창 탭 중 해당 url로 이동
    move_chrome_tab_by_url(url=url)

    # text_string 클릭
    # text_string="로그아웃 유지"
    # text_coordinates=get_text_coordinates_via_easy_ocr(string=text_string)
    # # text_coordinates=(692.0, 1047.5)
    # if not text_coordinates:
    #     print(rf"Text not found. {text_string}")
    #     return
    # x_abs, y_abs=text_coordinates
    # move_mouse(x_abs=x_abs, y_abs=y_abs)
    # click_mouse_left_btn(x_abs=x_abs, y_abs=y_abs)
    # print(rf"{text_string}")

    # 스크린샷 프로그램 exec
    # collect_img_for_autogui()
    # asyncio.run(shoot_custom_screenshot())

    # 이미지 바운딩박스 찾아 가운데 센터 클릭 ...
    f_png = rf"{D_PROJECT}\pk_image\screenshot_로그아웃_유지_2024_11_19_02_54_14.png"
    # click_center_of_img_recognized_by_mouse_left(img_abspath=f_png, loop_limit_cnt=10, is_zoom_toogle_mode=False)
    # 인식률 및 속도 개선 시도
    # pip install opencv-python # 이것은 고급 기능이 포함되지 않은 Python용 OpenCV의 미니 버전입니다. 우리의 목적에는 충분합니다.
    # confidence=0.7(70%)유사도를 낮춰 인식률개선시도, region 낮춰 속도개선시도, grayscale 흑백으로 판단해서 속도개선시도,
    # open cv 설치했는데 적용안되고 있음. 재부팅도 하였는 데도 안됨.
    # xy_infos_of_imgs=pyautogui.locateOnScreen(img_abspath, confidence=0.7, grayscale=True)
    # debug_as_gui(xy_infos_of_imgs is None)
    img = pyautogui.locateOnScreen(f_png, confidence=0.7, grayscale=True)

    # # 프롬프트 콘솔 클릭(광고 없어도 진행)
    # f_png=rf"{PROJECT_D}\pkg_png\ask_to_wrtn.png"
    # if click_center_of_img_recognized_by_mouse_left(img_abspath=f_png, recognize_loop_limit_cnt=50, is_zoom_toogle_mode=True):
    #     # 질문 작성 및 확인
    #     write_fast(question)
    #     press('enter')

    # 뤼튼 프롬프트 콘솔 최하단 이동 버튼 클릭


def get_found_pnx_interested_list_from_txt_f(including_texts=[], exclude_texts=[], except_extensions=[], including_extensions=[]):
    return find_pnx_interested_list_from_txt_f_x(including_texts=including_texts, exclude_texts=exclude_texts, except_extensions=except_extensions, f_ext_list_including=including_extensions)


def pk_here(item_str=None):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    if item_str is None:
        item_str = ''
    pk_print(rf"{str(str(item_str) + ' ') * 242:.100} here!")


# def does_text_bounding_box_exist_via_easy_ocr(string, mode="one_click"):  # GPU 없으면 동작안함
def does_text_bounding_box_exist_via_easy_ocr(string):  # GPU 없으면 동작안함

    from pkg_py.pk_colorful_cli_util import pk_print
    text_coordinates = get_text_coordinates_via_easy_ocr(string=string)
    if not text_coordinates:
        print(rf"[not found] {string}")
        return 0
    x_abs, y_abs = text_coordinates
    pk_print(working_str=rf'''x_abs="{x_abs}"  {'%%%FOO%%%' if LTA else ''}''')
    pk_print(working_str=rf'''y_abs="{y_abs}"  {'%%%FOO%%%' if LTA else ''}''')
    move_mouse(x_abs=x_abs, y_abs=y_abs)
    return 1


def assist_to_make_d_for_work():
    from pkg_py.pk_colorful_cli_util import pk_print
    try:
        while 1:
            # 1st input: 진행여부

            # 2nd input: 업무명 입력
            work_n = pk_input_validated("work_n", mode_nx_validation=1)

            # 3rd input: 경로 입력
            dst = pk_input_validated(str_working="dst", mode_nx_validation=1)

            # d 생성
            make_d_with_timestamp(d_nx=work_n, dst=dst)

            # 내용 비우기 # todo
            for idx, _ in enumerate([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]):
                print()


    except Exception as e:
        pk_print(f"Error: {str(e)}")


def is_pnx_required(pnx):
    import os
    import string
    from pkg_py.pk_colorful_cli_util import pk_print
    pk_print(f'''pnx={pnx}  {'%%%FOO%%%' if LTA else ''}''')
    if pnx == "":
        pk_print(f'''pnx가 입력되지 않았습니다  {'%%%FOO%%%' if LTA else ''}''')
        return 1
    connected_drives = []
    for drive_letter in string.ascii_uppercase:
        drive_path = drive_letter + ":\\"
        if os.path.exists(drive_path):
            connected_drives.append(drive_path)
            if pnx == drive_path:
                pk_print(f'''입력된 pnx는 너무 광범위하여 진행할 수 없도록 설정되어 있습니다  {'%%%FOO%%%' if LTA else ''}''')
                return 1
    if not os.path.exists(pnx):
        pk_print(f'''입력된 pnx가 존재하지 않습니다  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        return 1


def make_d_with_timestamp(d_nx, dst):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    try:
        # 업무명
        d_nx = d_nx.strip()
        d_nx = d_nx.replace("\"", "")
        pk_print(
            f'''[ {get_time_as_('now')} ] work_n={d_nx}  {'%%%FOO%%%' if LTA else ''}''')
        if d_nx == "":
            pk_print(
                f'''[ {get_time_as_('now')} ] work_n가 입력되지 않았습니다  {'%%%FOO%%%' if LTA else ''}''')
            return

        # 경로
        dst = dst.strip()
        dst = get_pnx_os_style(dst)
        if is_pnx_required(dst):
            return
        pk_print(working_str=rf'''dst="{dst}"  {'%%%FOO%%%' if LTA else ''}''')

        # 타임스템프 생성
        timestamp = get_time_as_("yyyy MM dd (weekday) HH mm")
        pnx_new = rf"{dst}\{timestamp} {d_nx}"
        pnx_new = get_pnx_os_style(pnx_new)
        pk_print(working_str=rf'''pnx_new="{pnx_new}"  {'%%%FOO%%%' if LTA else ''}''')

        # d 생성 및 f 탐색기 열기 # todo
        ensure_pnx_made(pnx=pnx_new, mode="d")
        cmd = rf'explorer "{pnx_new}"'
        pk_print(working_str=rf'''cmd="{cmd}"  {'%%%FOO%%%' if LTA else ''}''')
        # cmd_run(cmd=cmd)
        # print_list_as_vertical(get_windows_opened(), items_name="get_windows_opened()")

        return
    except Exception as e:
        pk_print(f"Error: {str(e)}")


@pk_measure_seconds
def compress_pnx_without_venv_and_idea_via_rar(pnx, d_dst, with_timestamp=1):
    from pkg_py.pk_core_constants import Encoding, PK_BLANK
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    import os
    # todo : 불필요 파일 삭제하는 코드 만들어야함.

    if not LTA:
        # ensure wsl
        config_remote_os = {}
        wsl_distro_n = "Ubuntu-24.04"
        config_remote_os['os_distro_n'] = wsl_distro_n
        config_remote_os['ip'] = get_wsl_ip(wsl_distro_n)
        config_remote_os['port'] = ensure_and_get_wsl_port(wsl_distro_n)
        config_remote_os['user_n'] = get_wsl_user_n(wsl_distro_n)
        config_remote_os['pw'] = get_wsl_pw(wsl_distro_n)
        config_remote_os['local_ssh_public_key'] = os.path.join(D_HOME, ".ssh", "id_ed25519.pub")
        config_remote_os['local_ssh_private_key'] = os.path.expanduser("~/.ssh/id_ed25519")
        ensure_wsl_distro_installed(wsl_distro_n=wsl_distro_n)
        ensure_wsl_distro_session(wsl_distro_n=wsl_distro_n)

        ensure_ubuntu_pkg_to_remote_os(ubuntu_pkg_n='rar', **config_remote_os)

    # 전처리
    pnx = get_pnx_unix_style(pnx=pnx)
    d_dst = get_pnx_unix_style(pnx=d_dst)

    # 정의
    working_d = get_d_working()
    p = get_p(pnx)
    n = get_n(pnx)
    nx = get_nx(pnx)
    x = get_x(pnx)
    x = x.lstrip('.')  # 확장자에서 점 remove

    _rar = ".rar"  # via rar
    timestamp = ""
    if with_timestamp:
        timestamp = rf"{PK_BLANK}{get_time_as_('%Y_%m_%d_%H_%M_%S')}"
    f_rar = rf"{p}/{n}{_rar}"
    f_rar_new = rf"{d_dst}/{n}{_rar}"
    f_rar_new_timestamp = rf"{d_dst}/{n}{timestamp}{_rar}"

    # remove
    move_pnx_to_pk_recycle_bin(pnx=f_rar)
    move_pnx_to_pk_recycle_bin(pnx=f_rar_new)

    # make d 
    ensure_pnx_made(pnx=d_dst, mode='d')

    # move
    pk_chdir(p)

    # todo 압축대상의 용량 확인
    pk_print("압축대상의 용량이 1GB 이상이면 1분 이상 걸릴 수 있습니다", print_color='blue')

    # compress by rar (".venv" 및 ".idea" 제외)
    f_rar_wsl = get_pnx_wsl_unix_style(pnx=f_rar)
    cmd = f'wsl rar a "{f_rar_wsl}" "{nx}" -x"*.venv/*" -x"*.idea/*"'
    cmd_to_os(cmd=cmd, encoding=Encoding.UTF8)

    # copy
    copy_pnx_with_overwrite(pnx=f_rar, dst=d_dst)

    # rename
    rename_pnx(src=f_rar_new, pnx_new=f_rar_new_timestamp)

    dst_nx = rf"{d_dst}/{nx}"

    # del
    if LTA:
        # todo 불필요한 거 최종적으로 삭제하려면 찾아야 한다.
        pk_print(f'''dst_nx={dst_nx} {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''f_rar_new={f_rar_new} {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''dst_nx={dst_nx} {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''f_rar_wsl={f_rar_wsl}  {'%%%FOO%%%' if LTA else ''}''', print_color="blue")
    # move_pnx_to_trash_bin(src=f_rar_new)
    move_pnx_to_pk_recycle_bin(pnx=dst_nx)
    move_pnx_to_pk_recycle_bin(pnx=f_rar_wsl)

    # chdir
    pk_chdir(working_d)

    # logging
    if does_pnx_exist(pnx=f_rar_new_timestamp):
        STAMP_func_n = rf'[{inspect.currentframe().f_code.co_name}()]'
        pk_print(working_str=rf'''{STAMP_func_n} f_rar_new_timestamp={f_rar_new_timestamp}  {'%%%FOO%%%' if LTA else ''}''', print_color='green')
    return f_rar_new_timestamp


def get_str_from_txt_f(pnx):
    prompt = ""
    lines = get_list_from_f(f=pnx)
    lines = get_list_without_none(working_list=lines)
    for line in lines:
        prompt = prompt + line + "\n"
    return prompt


def get_str_from_clipboard():
    # Get-Clipboard  # 클립보드 내용 확인
    return pk_paste()


def pk_copy(working_str):
    import clipboard
    # Set-Clipboard -Value "텍스트"  # 클립보드에 텍스트 저장
    clipboard.copy(working_str)


def is_window_title_front(window_title):
    """탐색기창을 필터하기 위해서 만든 함수"""
    front_window_title = get_front_window_title()
    # pk_print(f'''window_title={window_title}  {'%%%FOO%%%' if LTA else ''}''',print_color="blue")
    # pk_print(f'''front_window_title={front_window_title}  {'%%%FOO%%%' if LTA else ''}''',print_color="blue")
    # pk_print(f'''len(window_title)={len(window_title)}  {'%%%FOO%%%' if LTA else ''}''',print_color="blue")
    # pk_print(f'''len(front_window_title)={len(front_window_title)}  {'%%%FOO%%%' if LTA else ''}''',print_color="blue")
    if not front_window_title is None:
        if window_title == front_window_title:
            return 1
    return 0


def get_front_window_title():
    import pygetwindow
    try:
        active_window = pygetwindow.getActiveWindow()
        if active_window:
            return active_window.title
        else:
            return None  # 활성화된 창이 없다면 None 반환
    except Exception as e:
        return f"Error: {str(e)}"


def print_front_window_title():
    from pkg_py.pk_colorful_cli_util import pk_print
    front_window_title = get_front_window_title()
    pk_print(f'''front_window_title={front_window_title}  {'%%%FOO%%%' if LTA else ''}''', print_color="blue")
    raise


def run_acu_update_v3_exe_and_login_and_run_autoa2zdrive_release_exe(issue_log_index_data):
    import pkg_py.pk_core_constants as pk_core_constants
    import inspect
    import os
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    pk_print(working_str=rf'''{pk_core_constants.UNDERLINE}{func_n}()  {'%%%FOO%%%' if LTA else ''}''')
    AUTOA2ZDRIVE_RELEASE_SW_VERSION_EXE = rf"{pk_core_constants.D_HOME}\Desktop\AutoA2zDrive\AutoA2ZDrive_Release_{issue_log_index_data["SW 버전"]}.exe"
    pk_print(working_str=rf'''AUTOA2ZDRIVE_RELEASE_SW_VERSION_EXE="{AUTOA2ZDRIVE_RELEASE_SW_VERSION_EXE}"  {'%%%FOO%%%' if LTA else ''}''')
    window_title_seg = "acu_update_v3_exe"
    if not does_pnx_exist(pnx=AUTOA2ZDRIVE_RELEASE_SW_VERSION_EXE):
        acu_update_v3_exe = rf"{pk_core_constants.D_HOME}\Desktop\AutoA2zDrive\ACU_update_v3.exe"
        acu_update_v3_exe_p = get_p(pnx=acu_update_v3_exe)
        os.chdir(acu_update_v3_exe_p)
        cmd = rf' start cmd.exe /k "title {window_title_seg} && {pk_core_constants.D_HOME}\Desktop\AutoA2zDrive\ACU_update_v3.exe &" '
        cmd_to_os(cmd=cmd, mode="a")
        pw = get_token_from_f_token(f_token=rf'{pk_core_constants.D_PKG_TXT}\token_linux_pw.txt', initial_str="")
        user_n = get_token_from_f_token(f_token=rf'{pk_core_constants.D_PKG_TXT}\token_linux_id.txt', initial_str="")
        while 1:
            pk_sleep(milliseconds=2000)
            if is_window_opened(window_title_seg=window_title_seg):
                ensure_window_to_front(window_title_seg=window_title_seg)
                pk_sleep(milliseconds=500)
                write_like_person(str_working=user_n)
                pk_press("enter")
                write_like_person(str_working=pw)
                pk_press("enter")
                write_like_person("2")
                pk_press("enter")
                write_like_person(rf"{issue_log_index_data["SW 버전"]}")
                pk_press("enter")
                break
    else:
        run_autoa2zdrive_release_exe()

        # pk_sleep(milliseconds=15000)
        # while 1: #via ocr
        #     # text_string 바운딩박스 클릭 # GPU 연산 지원여부..
        #     # text_string = "downloading : 100%"
        #     text_string = "Press Enter Key To Quit Program...."
        #     text_coordinates = get_text_coordinates_via_easy_ocr(string=text_string)
        #     # text_coordinates = (692.0, 1047.5)
        #     if not text_coordinates:
        #         pk_sleep(milliseconds=30000)
        #     if text_coordinates:
        #         x_abs, y_abs = text_coordinates
        #         move_mouse(x_abs=x_abs, y_abs=y_abs)
        #         click_mouse_left_btn(x_abs=x_abs, y_abs=y_abs)
        #         pk_print(string = rf'''text_string="{text_string}"  {'%%%FOO%%%' if LTA else ''}''')
        #         break
        # img_pnx = rf"{pk_core_constants.PROJECT_D}\pk_image\screenshot_Press_Enter_Key_To_Quit_Program_2024_11_21_11_30_35.png"
        # click_center_of_img_recognized_by_mouse_left(img_pnx=img_pnx, loop_limit_cnt=10)


# def run_pnx_list_via_f_txt():
#     import inspect
#     from pkg_py.pk_colorful_cli_util import pk_print, print_magenta
#     from pkg_py.pk_core_constants import PROJECT_D
#     func_n = inspect.currentframe().f_code.co_name
#     f_func_n_txt = rf'{PROJECT_D}\pkg_txt\{func_n}.txt'
#     make_pnx(pnx=f_func_n_txt, mode="f")
#     print_magenta(rf'''f_func_n_txt={f_func_n_txt}''')
#     open_pnx_by_ext(pnx=f_func_n_txt)
#     txt_list = get_list_from_f(f=f_func_n_txt)
#     # texts=texts.split("\n")
#     txt_list = get_list_striped_element(working_list=txt_list)
#     txt_list = get_list_element_duplicated(working_list=txt_list)
#     for txt_str in txt_list:
#         f = txt_str
#         open_pnx_by_ext(pnx=f)
#     pk_print(str_working=rf'''txt_list="{txt_list}"  {'%%%FOO%%%' if LTA else ''}''')

def run_console_blurred_exe():
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    # console_blurred.exe exec
    cmd_str = rf".\dist\console_blurred\console_blurred.exe"
    cmd_to_os(cmd_str)


def run_pk_release_server(port):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PROJECT
    # explorer "http://localhost:9090"
    # curl -O http://49:9090/1.zip && exit
    func_n = inspect.currentframe().f_code.co_name

    py_pnx = rf'{D_PROJECT}\pk_system_{func_n}.py'
    if not does_pnx_exist(pnx=py_pnx):
        return

    if is_window_opened(window_title_seg=py_pnx):
        # kill_window_duplicated_list_in_loop()
        ensure_window_to_front(window_title_seg=py_pnx)
        return

    server_ip = "localhost"
    pk_print(f'''server_ip={server_ip}''')
    pk_print(f'''server_port={port}''')

    # bat_pnx=rf'{USERPROFILE}\Downloads\pk_system\pk_system_http_server_run.cmd'
    # cmd=rf'start cmd.exe /k "{bat_pnx}"'

    cmd = rf'start cmd.exe /k python "{py_pnx}"'
    cmd_to_os(cmd=cmd, mode="a")
    # pk_print(f'''{cmd} [Negative]"''')

    url = rf'http://{server_ip}:{port}'
    cmd = rf" explorer {url}/"
    cmd_to_os(cmd=cmd, mode="a")
    kill_chrome_tab_duplicated()
    move_chrome_tab_by_url(url=url)

    cmd = rf' netstat -ano | find "{port}" '
    cmd_to_os(cmd=cmd, mode="a")


def ensure_wsl_distro_session(wsl_distro_n):
    import subprocess
    from pkg_py.pk_colorful_cli_util import pk_print

    if is_os_windows():
        if not is_os_wsl_linux():
            if not is_wsl_distro_started(wsl_distro_n):
                subprocess.Popen(f"wsl -d {wsl_distro_n}", creationflags=subprocess.CREATE_NO_WINDOW)
            if is_wsl_distro_started(wsl_distro_n):
                pk_print(f'''{wsl_distro_n} is started already in wsl with keeping session {'%%%FOO%%%' if LTA else ''}''')
            else:
                pk_print(f'''{wsl_distro_n} is not started in wsl with keeping session {'%%%FOO%%%' if LTA else ''}''', print_color='red')
                raise


def open_and_move_wsl_console_to_front(remote_os_distro_n, window_title_seg):
    import time

    ensure_wsl_distro_session(remote_os_distro_n)

    cmd = f'start cmd /k "wsl -d {remote_os_distro_n}"'
    cmd_to_os(cmd=cmd, mode='a')
    time_limit = 20
    time_s = time.time()
    while 1:
        # pk_print(str_working=time.time() - time_s)
        if time.time() - time_s > time_limit:
            break
        if is_window_opened(window_title_seg=window_title_seg):
            break
        pk_sleep(seconds=0.5)

    time_limit = 5
    time_s = time.time()
    while 1:
        # pk_print(str_working=time.time() - time_s)
        if time.time() - time_s > time_limit:
            break
        if is_front_window_title(window_title_seg=window_title_seg):
            break
        else:
            ensure_window_to_front(window_title_seg=window_title_seg)
        pk_sleep(seconds=0.5)
        break

    # cd

    # clear


def run_powershell_exe_as_admin():
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    # cmd_to_os('PowerShell -cmd "Start-Process powershell"')
    cmd_to_os('powershell -cmd "Start-Process powershell -Verb RunAs"')
    window_title_seg = "관리자: Windows PowerShell"
    while 1:
        if not is_front_window_title(window_title_seg=window_title_seg):
            ensure_window_to_front(window_title_seg=window_title_seg)
        if is_front_window_title(window_title_seg=window_title_seg):
            break
    # window_move_to_front_via_win32gui(window_title_seg=window_title_seg)


#
# def process_kill_cmd_exe(debug_mode=True):
#     func_n=inspect.currentframe().f_code.co_name
#     try:
#         pids=get_pids_by_process_name("cmd.exe")
#         for pid in pids:
#             process_kill_via_taskkill(pid=pid)
#     except:
#         pk_print(str_working=rf'''{'%%%FOO%%%' if LTA else ''}''', print_color='red')


def get_token_from_f_txt(f_token, initial_str):
    generate_token_f(f=f_token, initial_str=initial_str)
    token = get_str_from_txt_f(pnx=f_token)
    token = token.replace("\n", "")
    return token


def make_version_new(via_f_txt, working_list=None):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    make_version_new_v_1_0_1(via_f_txt=via_f_txt, working_list=working_list)
    pass


def make_version_new_v_1_0_1(via_f_txt=False, working_list=None, debug_mode=True):
    import inspect
    import os
    import re
    import shutil
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_DOWNLOADS, D_PROJECT
    func_n = inspect.currentframe().f_code.co_name
    f_func_n_txt = rf'{D_PROJECT}\pkg_txt\{func_n}.txt'
    ensure_pnx_made(pnx=f_func_n_txt, mode='f')
    open_pnx_by_ext(pnx=f_func_n_txt)

    def get_next_versioned_nx(f_nx, debug_mode=True):
        func_n = inspect.currentframe().f_code.co_name
        name, ext = os.path.splitext(f_nx)
        files = os.listdir("pkg_friday")

        # 정규표현식으로 "v1.x.y" 형태의 버전을 찾기
        versioned_files = [f for f in files if re.match(fr"{re.escape(name)}_v\d+\.\d+\.\d+{re.escape(ext)}", f)]

        if versioned_files:
            latest_version = max(versioned_files, key=lambda x: list(map(int, re.findall(r"\d+", x)[-3:])))
            major, minor, patch = map(int, re.findall(r"\d+", latest_version)[-3:])
            patch += 1
            next_version = f"{major}.{minor}.{patch}"
        else:
            next_version = "1.0.0"
        next_versioned_pnx = f"{name}_v{next_version}{ext}"
        pk_print(f'''next_versioned_pnx="{next_versioned_pnx}" ''', print_color='white')
        return next_versioned_pnx

    def cp_and_mv_with_version(src, debug_mode=True):
        func_n = inspect.currentframe().f_code.co_name
        # make new version
        # cp
        if not does_pnx_exist(src):
            pk_print(f"{src} f을 찾을 수 없습니다.")
            return
        src_nx = get_nx(src)
        f_next_versioned_nx = get_next_versioned_nx(src_nx)
        shutil.copy2(src, f_next_versioned_nx)
        pk_print(f'''src="{src}"''')
        pk_print(f'''f_next_versioned_nx="{f_next_versioned_nx}"''')
        pk_print(f"''{src}'를  {f_next_versioned_nx}'로 copied.")
        f = src
        f_nx = get_nx(f)
        f_n = get_n(f)
        f_x = get_x(f)

        files = os.listdir("pkg_friday")

        dst = rf"{D_DOWNLOADS}\deprecated"
        os.makedirs(dst, exist_ok=True)

        # mv
        # 버전 f만 추출 #최신버전 원본제외
        f_list_versioned_required = files
        f_list_versioned_required = get_list_leaved_element_contain_prompt(working_list=f_list_versioned_required, prompt=f_n)
        f_list_versioned_required.remove(f_nx)  # 원본제외
        f_list_versioned_required.remove(f_next_versioned_nx)  # 최신버전제외
        print_iterable_as_vertical(item_iterable=f_list_versioned_required, item_iterable_n="f_list_versioned_required")

        pk_print(f'''f="{f}"''')
        pk_print(f'''f_n="{f_n}"''')
        pk_print(f'''f_x="{f_x}"''')
        pk_print(f'''len(f_list_versioned_required)={len(f_list_versioned_required)}''')
        pk_print(f'''len(f_list_versioned_required) >= 1="{len(f_list_versioned_required) >= 1}"''')
        if len(f_list_versioned_required) > 1:
            for f in f_list_versioned_required:
                shutil.move(f, dst)
                pk_print(f"'{f}' moved to '{dst}'")

    if via_f_txt == True and working_list is None:
        working_list = get_list_from_f(f=f_func_n_txt)
        working_list = get_list_removed_element_contain_prompt(working_list=working_list, prompt="#")
        working_list = get_list_replaced_element_from_str_to_str(working_list=working_list, from_str='\n', to_str='')
        for item_str in working_list:
            item_str = get_str_replaced_from_str_to_str_new(item_str=item_str, from_str='PROJECT_D', to_str=D_PROJECT)
            # item=get_pnx_windows_style(pnx=item)
            item_str = get_pnx_unix_style(pnx=item_str)
            pk_print(f'''item_str="{item_str}"''')
            cp_and_mv_with_version(item_str)
    if via_f_txt is not True and working_list is not None:
        for f in working_list:
            cp_and_mv_with_version(f)


def alert_as_gui(title_: str, ment: str, auto_click_positive_btn_after_seconds: int, input_text_default: str = "", btn_list: any = None):
    if not btn_list:
        btn_list: [str] = ["확인"]
    import inspect
    import platform
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_interface_graphic_user import GuiUtil
    from PySide6.QtWidgets import QApplication
    func_n = inspect.currentframe().f_code.co_name
    # should_i_do 가 앱 안과 밖에서도 잘 된다면 deprecated 하자
    if platform.system() == 'Windows':
        func_n = inspect.currentframe().f_code.co_name
        pk_print(f"{func_n}()")

        # QApplication 인스턴스 확인
        app_foo = None
        app = QApplication.instance()
        if app is None:
            app_foo = QApplication()
        if input_text_default == "":
            is_input_text_box = False
        else:
            is_input_text_box = True

        dialog = GuiUtil.CustomQdialog(
            title=title_,
            btn_list=btn_list,
            input_box_mode=is_input_text_box,
            input_box_text_default=input_text_default,
            auto_click_positive_btn_after_seconds=auto_click_positive_btn_after_seconds,
        )
        dialog.exec()
        btn_txt_clicked = dialog.btn_txt_clicked

        if btn_txt_clicked == "":
            pk_print(f'버튼  입니다 {btn_txt_clicked}')
        if app == True:  # .....app 은 bool 이 아닌데. 동작 되고있는데..
            pk_print("여기는 좀 확인을 해야하는데. 호출 안되면 좋겠는데1")
            if isinstance(app_foo, QApplication):
                pk_print("여기는 좀 확인을 해야하는데. 호출 안되면 좋겠는데2")
                app_foo.exec()
        if app == True:
            # app_foo.quit()# QApplication 인스턴스 remove시도 : fail
            # app_foo.deleteLater()# QApplication 인스턴스 파괴시도 : fail
            # del app_foo # QApplication 인스턴스 파괴시도 : fail
            # app_foo=None # QApplication 인스턴스 파괴시도 : fail
            pk_print("여기는 좀 확인을 해야하는데. 호출 안되면 좋겠는데3")
            app_foo.shutdown()  # QApplication 인스턴스 파괴시도 : success  # 성공요인은 app.shutdown()이 호출이 되면서 메모리를 해제까지 수행해주기 때문
            # raise
    else:
        pk_print(f"{ment}")


def classify_pnx_list_at_tree(d_working, mode, with_walking, debug_mode=True):
    from pkg_py.pk_colorful_cli_util import pk_print

    pk_print(working_str=rf'''d="{d_working}" mode="{mode}"  {'%%%FOO%%%' if LTA else ''}''')

    if mode == 'f':
        # todo : ref : f이 너무 많을떄(file_cnt_limit이 100개(?) 넘어가면) without_walking=True
        # classify_pnxs_to_pkg_compressed(pnx)
        # classify_pnxs_to_pkg_document(pnx)
        # classify_pnxs_to_pkg_video(pnx)
        # classify_pnxs_to_pk_image(pnx)
        # classify_pnxs_to_pkg_soundtrack(pnx)
        # classify_pnxs_to_special_keyword_dir(pnx)

        # classify_pnxs_to_pkg_compressed(src=src, without_walking=False)
        # classify_pnxs_to_pkg_document(pnx=src, without_walking=False)
        # classify_pnxs_to_pkg_video(pnx=src, without_walking=False)
        # classify_pnxs_to_pk_image(pnx=src, without_walking=False)
        # classify_pnxs_to_pkg_soundtrack(pnx=src, without_walking=False)
        classify_pnx_list_to_d_special_keyword(d_src=d_working, with_walking=with_walking)

        # classify_pnxs_to_pn_dir(src=src)
        # classify_pnxs_to_pk_image_via_ai() #todo : add : AI 이미지 분류기
        # classify_pnxs_to_pkg_video_via_ai() #todo : add : AI 동영상 분류기 # 동영상 내용보고 분류기준에 따라 분류
        # merge_pnxs_via_text_file() # todo : add : merge d and d


def rename_pnxs_from_pattern_to_pattern_new_via_routines_at_d(d, mode, with_walking):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    # pattern=r'(\[.*?\])'  # [문자열]
    rename_pnxs_from_pattern_twice_to_pattern_new(pnx=d, pattern=r'\d{4}_\d{2}_\d{2}_(월|화|수|목|금|토|일)_\d{2}_\d{2}_\d{2}_\d{3}', mode=mode, with_walking=with_walking)
    rename_pnxs_from_pattern_twice_to_pattern_new(pnx=d, pattern=r'\d{4}_\d{2}_\d{2}_\d{2}_\d{2}_\d{2}', mode=mode, with_walking=with_walking)
    rename_pnxs_from_pattern_twice_to_pattern_new(pnx=d, pattern=r'_\d{11}_\d{11}_', mode=mode, with_walking=with_walking)
    rename_pnxs_from_pattern_twice_to_pattern_new(pnx=d, pattern=r'_\d{10}_\d{10}_', mode=mode, with_walking=with_walking)
    rename_pnxs_from_pattern_twice_to_pattern_new(pnx=d, pattern=r'_\d{11}_', mode=mode, with_walking=with_walking)

    rename_pnxs_from_pattern_once_to_pattern_new(src=d, pattern=r'\d{4}_\d{2}_\d{2}_(월|화|수|목|금|토|일)_\d{2}_\d{2}_\d{2}_\d{3}', pattern_new="_", mode=mode, with_walking=with_walking)
    rename_pnxs_from_pattern_once_to_pattern_new(src=d, pattern=r'jhp##\d{4}_\d{2}_\d{2}', pattern_new="[jhp##]", mode=mode, with_walking=with_walking)
    rename_pnxs_from_pattern_once_to_pattern_new(src=d, pattern=r'jhp##\d{8}', pattern_new="[jhp##]", mode=mode, with_walking=with_walking)
    rename_pnxs_from_pattern_once_to_pattern_new(src=d, pattern=r'\$\d{22}', pattern_new="_", mode=mode, with_walking=with_walking)
    rename_pnxs_from_pattern_once_to_pattern_new(src=d, pattern=r'_\d{29}_', pattern_new="_", mode=mode, with_walking=with_walking)
    rename_pnxs_from_pattern_once_to_pattern_new(src=d, pattern=r'\d{4}_\d{2}_\d{2}_\d{2}_\d{2}_\d{2}', pattern_new=".", mode=mode, with_walking=with_walking)
    rename_pnxs_from_pattern_once_to_pattern_new(src=d, pattern=r'_\d{8}_', pattern_new=".", mode=mode, with_walking=with_walking)
    rename_pnxs_from_pattern_once_to_pattern_new(src=d, pattern=r'_\d{11}.', pattern_new=".", mode=mode, with_walking=with_walking)
    rename_pnxs_from_pattern_once_to_pattern_new(src=d, pattern=r'_\d{11}_', pattern_new=".", mode=mode, with_walking=with_walking)
    rename_pnxs_from_pattern_once_to_pattern_new(src=d, pattern=r'_\d{11}', pattern_new="", mode=mode, with_walking=with_walking)
    rename_pnxs_from_pattern_once_to_pattern_new(src=d, pattern=r'^seg ', pattern_new="_", mode=mode, with_walking=with_walking)
    rename_pnxs_from_pattern_once_to_pattern_new(src=d, pattern=r'^_', pattern_new="[시작문자]", mode=mode, with_walking=with_walking)
    rename_pnxs_from_pattern_once_to_pattern_new(src=d, pattern=r'^#', pattern_new="[시작문자]", mode=mode, with_walking=with_walking)
    rename_pnxs_from_pattern_once_to_pattern_new(src=d, pattern=r'^The ', pattern_new="[시작문자]", mode=mode, with_walking=with_walking)
    rename_pnxs_from_pattern_once_to_pattern_new(src=d, pattern=r'_$', pattern_new="[끝문자]", mode=mode, with_walking=with_walking)
    rename_pnxs_from_pattern_once_to_pattern_new(src=d, pattern=r'\(([^)]+)\)(?=.*\(\1\))', pattern_new="[중복문자]", mode=mode, with_walking=with_walking)  # () 안의 중복문자인 경우데 대한 처리 (a)(a) 인 경우 (a)만 남김
    # rename_pnxs_from_pattern_once_to_pattern_new(src=src, pattern=r'^.', pattern_new="_", mode=mode)  # 시작문자 # 첫글자가 없어진다... 씆지말자
    # rename_pnxs_from_pattern_once_to_pattern_new(src=src, pattern=r'^ ', pattern_new="_", mode=mode)  # 시작문자 # 업데이트가 되긴하는데 ^_ 이 왜 안되는지 모르겠다.
    # rename_pnxs_from_pattern_once_to_pattern_new(src=src, pattern=r'_\d{11}$', pattern_new="",mode=mode) # 끝문자 # 끝문자 안되는 것 같은데...
    # rename_pnxs_from_pattern_once_to_pattern_new(src=src, pattern=r'_\d+$', pattern_new="",mode=mode) # 끝문자
    # rename_pnxs_from_pattern_once_to_pattern_new(src=src, pattern=r'_\d{10}_\d{10}_', pattern_new="",mode=mode)
    # rename_pnxs_from_pattern_once_to_pattern_new(src=src, pattern=r'_\d{10}_', pattern_new="",mode=mode)
    # rename_pnxs_from_pattern_once_to_pattern_new(src=src, pattern= r'\d{10}', pattern_new="",mode=mode)
    # rename_pnxs_from_pattern_once_to_pattern_new(src=src, pattern=r'\$\d{22}', pattern_new="",mode=mode)
    # rename_pnxs_from_pattern_once_to_pattern_new(src=src, pattern=r'_\d{11}', pattern_new="",mode=mode)


def get_data_required_from_f_csv(line_order):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import UNDERLINE
    func_n = inspect.currentframe().f_code.co_name
    pk_print(working_str=rf'''{func_n}()  {'%%%FOO%%%' if LTA else ''}''', print_color='blue')
    df = get_df_from_issues_list_csv_deprecated()
    columns_required = df.columns.tolist()  # 전부
    # columns_required=['주행일자','해결 여부', '문제점 상세',  'SW 버전', 'f 위치', '발생시각', '문제모듈', '개입(크루)',  'Crew 요청사항', '피드백 조치','차량', '지역', '코스', '날씨', 'Crew', '위치(UTM_E)', '위치(UTM_N)', '위치(Azimuth)', '위치(Altitude)','시작 Frame', '종료 Frame','개입(점검)', '위험도', 'DB 분석피드백', 'Comment','수정 여부', '수정 내용', '교육자료', '특이 DB', 'f 크기', ] # 중요도 높은것 앞으로 변경된
    # columns_required=['주행일자', '해결 여부', '문제점 상세', 'SW 버전', 'f 위치', '발생시각', '문제모듈', '개입(크루)', 'Crew 요청사항', '피드백 조치']  # 필요한 것만
    # columns_required=["f명", "차량", "지역", "코스", "SW 버전", "운전자", "로그 분석자", "프레임", "문제점 상세", "Crew 요청사항"] ?
    data_required = {}
    nth_row = get_nth_row(df, n=line_order)
    if nth_row is not None:
        pk_print(working_str=rf'''{UNDERLINE}n="{line_order}"  {'%%%FOO%%%' if LTA else ''}''')
        for col in columns_required:
            if col in df.columns:  # 열이 존재하는 경우만 출력 # todo : chore : get은 get 기능만 출력은 따로..
                pk_print(f"{col}: {nth_row[col]}", print_color='blue')
                # 필요한 것만 추가
                if col == "f 위치":
                    data_required["f 위치"] = nth_row[col]
                if col == "SW 버전":
                    data_required["SW 버전"] = nth_row[col]
                if col == "차량":
                    data_required["차량"] = nth_row[col]
                if col == "지역":
                    data_required["지역"] = nth_row[col]
                if col == "주행일자":
                    data_required["주행일자"] = nth_row[col]
                if col == "코스":
                    data_required["코스"] = nth_row[col]
            else:
                print(f"{col}: N/A")  # 열이 없는 경우 기본값 출력
                # data_required["차량아이디코드번호"] =
            # print(f"'차량아이디코드번호='{nth_row[col]}'") # 데이터 전처리하여 추출 및 딕셔너리 data_required에 추가
    return data_required


def download_issue_data(data_required, original_log=False):
    import inspect
    import re
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name

    # 전처리
    issue_file_name = data_required["f 위치"].split('/')[-1]

    def get_origin_log_file_name(issue_file_name):
        # 정규식 패턴 정의: "_숫자(최대 2자리)_VIDEO"
        pattern = r"_\d{1,2}_VIDEO"
        original_filename = re.sub(pattern, "", issue_file_name)
        return original_filename

    origin_log_file_name = get_origin_log_file_name(issue_file_name)
    data_required["주행일자"] = data_required["f 위치"].split('/')[0]
    data_required["f 위치"] = data_required["f 위치"].replace("/", f"\\")

    # 정의
    if original_log == False:
        src = rf"\\192.168.1.33\01_Issue\{data_required["f 위치"]}"
    else:
        src = rf"\\192.168.1.33\02_Orignal\{data_required["차량"]}\{data_required["지역"]}\{data_required["주행일자"]}\{data_required["코스"]}\{origin_log_file_name}"
        pk_print(working_str=rf'''src="{src}"  {'%%%FOO%%%' if LTA else ''}''')

    dst = rf"C:\log"
    cmd = rf"copy {src} {dst}"
    src_nx = get_nx(pnx=src)
    src_new = rf"{dst}\{src_nx}"

    while 1:
        if does_pnx_exist(pnx=src_new):
            pk_print(working_str=rf'''{src_new} 가 이미 있습니다."  {'%%%FOO%%%' if LTA else ''}''')
            break
        else:
            if not does_pnx_exist(pnx=src_new):
                cmd_to_os(cmd=cmd, mode="a")
                pk_print(working_str=rf'''이슈데이터 다운로드 완료 "{src_new}"  {'%%%FOO%%%' if LTA else ''}''', print_color='blue')
                return


#
# def download_torrent_magnet_from_nyaa_si(string_to_search, driver_selenium, exclude_elements_all, include_elements_any, include_elements_all):
#     func_n=inspect.currentframe().f_code.co_name
#     pk_print(str_working=rf''' {'%%%FOO%%%' if LTA else ''}''', print_color='blue')
#     f_func_n_txt=rf'{PROJECT_D}\pkg_txt\{func_n}.txt'
#     query=urllib.parse.quote(f"{string_to_search}")
#     url=f'https://nyaa.si/?f=0&c=0_0&q={query}'
#     url_decoded=get_str_url_decoded(string=url)
#     driver_selenium.get(url)
#
#     # 페이지 소스 RAW
#     page_src=driver_selenium.page_source  # page_src={page_src}  {'%%%FOO%%%' if LTA else ''}''')
#
#     soup=BeautifulSoup(page_src, "html.parser")
#
#     titles=[]
#     magnets=[]
#
#     string_to_search=string_to_search
#     string_to_search=get_str_removed_last_digit(string_to_search)
#     string_to_search=string_to_search.strip()
#
#     lines=soup.find_all(name="a")
#     for line in lines:
#         magnet=line.get('href')
#         if magnet:
#             magnets.append(magnet)
#     # data=get_dict_removed_element_duplicated(item_dict=data)
#
#     pk_print(str_working=rf'''url="{url}"  {'%%%FOO%%%' if LTA else ''}''')
#     pk_print(str_working=rf'''string_to_search="{string_to_search}"  {'%%%FOO%%%' if LTA else ''}''')
#     pk_print(str_working=rf'''url_decoded="{url_decoded}"  {'%%%FOO%%%' if LTA else ''}''')
#
#     for magnet in magnets:
#         if is_regex_in_string(string=get_str_url_decoded(magnet), regex=string_to_search, debug_mode=True):
#             # pk_print(str_working=rf'''get_str_url_decoded(magnet)="{get_str_url_decoded(magnet)}"  {'%%%FOO%%%' if LTA else ''}''')
#             # if is_regex_in_string(string=href, regex="magnet*", with_case_ignored=False, debug_mode=True):
#             exclude_check=not any(element in get_str_url_decoded(magnet) for element in exclude_elements_all)
#             include_all_check=all(element in get_str_url_decoded(magnet) for element in include_elements_all)
#             include_any_check=any(element in get_str_url_decoded(magnet) for element in include_elements_any)
#
#             # 필터링 조건 평가
#             if (
#                     not exclude_check and
#                     include_all_check and
#                     include_any_check
#             ):
#                 # 결과 출력 및 브라우저 열기
#                 pk_print(str_working=rf'''get_str_url_decoded(magnet)="{get_str_url_decoded(magnet)}"  {'%%%FOO%%%' if LTA else ''}''')
#                 webbrowser.open(magnet)

def get_total_cnt_of_f_torrent_list(h3_text):
    from pkg_py.pk_colorful_cli_util import pk_print
    import re
    total_cnt_of_f_torrent_list = None
    pk_print(f'''h3_text={h3_text}  {'%%%FOO%%%' if LTA else ''}''')
    match = re.search(r"\((\d+)\)", h3_text)
    if match:
        matched_group = match.group(1)  # 첫 번째 캡처 그룹 (숫자) 반환
        pk_print(f'''matched_group={matched_group}  {'%%%FOO%%%' if LTA else ''}''')
        total_cnt_of_f_torrent_list = int(matched_group)
        pk_print(f'''total_cnt_of_f_torrent_list={total_cnt_of_f_torrent_list}  {'%%%FOO%%%' if LTA else ''}''')
    return total_cnt_of_f_torrent_list


def get_page_number_last_of_nyaa_si_page(url, driver):
    from pkg_py.pk_colorful_cli_util import pk_print
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from bs4 import BeautifulSoup
    import re
    page_number_max_in_pagenation = 1
    while 1:
        url_page = f'{url}&p={page_number_max_in_pagenation}'
        driver.get(url_page)
        WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.TAG_NAME, "body")))
        pk_sleep(milliseconds=200)
        page_src = driver.page_source
        soup = BeautifulSoup(page_src, "html.parser")
        # pk_print(f'''soup={soup}  {'%%%FOO%%%' if LTA else ''}''')
        ul_pagination = soup.find("ul", class_="pagination")
        page_number_in_pagenation_list = []
        if ul_pagination:
            # print(ul_pagination.prettify())
            for a_tag in ul_pagination.find_all("a"):
                text = a_tag.get_text(strip=True)
                # 숫자인 경우에만 리스트에 추가
                if text.isdigit():
                    page_number_in_pagenation_list.append(int(text))
        if page_number_in_pagenation_list:
            page_number_max_in_pagenation = max(page_number_in_pagenation_list)
        div_pagination_info = soup.find("div", class_="pagination-page-info")
        if div_pagination_info:
            div_pagination_info_text = div_pagination_info.get_text(strip=True)
            # pk_print(f'''div_pagination_info_text={div_pagination_info_text}  {'%%%FOO%%%' if LTA else ''}''')
            pattern = r"results (\d+-\d+) out of (\d+) results"
            match = re.search(pattern, div_pagination_info_text)
            if match:
                cnt_part_of_results = match.group(1)  # "976-1000"
                cnt_total_of_results = match.group(2)  # "1000"
                pk_print(f'''max_page_number_in_pagenation={page_number_max_in_pagenation} cnt_part_of_results={cnt_part_of_results}  cnt_total_of_results={cnt_total_of_results}  {'%%%FOO%%%' if LTA else ''}''')
                if cnt_part_of_results.split('-')[1] == cnt_total_of_results:
                    page_number_last = page_number_max_in_pagenation
                    return page_number_last
                else:
                    page_number_max_in_pagenation = page_number_max_in_pagenation + 1


@pk_measure_memory
def get_magnets_set_from_nyaa_si_v1(nyaa_si_supplier, search_keyword, driver):  # v1 : txt 파일에 데이터를 수집하는 방식
    from pkg_py.pk_colorful_cli_util import pk_print
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from bs4 import BeautifulSoup
    import math
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    import random

    if driver is None:
        driver = get_driver_selenium(browser_debug_mode=False)

    url = f'https://nyaa.si/user/{nyaa_si_supplier}?f=0&c=0_0&q={get_str_encoded_url(search_keyword)}'
    pk_print(f'''url={url}  {'%%%FOO%%%' if LTA else ''}''')

    driver.get(url)
    page_src = driver.page_source
    soup = BeautifulSoup(page_src, "html.parser")

    page_number_last = None
    files_per_page = 75
    total_cnt_of_f_torrent_list = get_total_cnt_of_f_torrent_list(h3_text=soup.find("h3").text.strip())
    if total_cnt_of_f_torrent_list:
        page_number_last = math.ceil(total_cnt_of_f_torrent_list / files_per_page)
        pk_print(f'''files_per_page={files_per_page}  {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''displayable_magnets_cnt_per_page={files_per_page}  {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''page_number_last={page_number_last}  {'%%%FOO%%%' if LTA else ''}''')
    else:
        page_number_last = get_page_number_last_of_nyaa_si_page(url=url, driver=driver)

    page_number_str_list = [str(i) for i in get_list_from_int_a_to_int_b(int_a=1, int_b=page_number_last)]
    page_number_start_to_download = int(get_pk_input(message='page_number_start_to_download=', answer_options=page_number_str_list))
    page_number_end_to_download = int(get_pk_input(message='page_number_end_to_download=', answer_options=page_number_str_list))

    magnets_set = set()
    pk_print(f'''page_number_end_to_download={page_number_end_to_download}  {'%%%FOO%%%' if LTA else ''}''', print_color="blue")
    for page_number in range(page_number_start_to_download, page_number_end_to_download + 1):
        url_page = f'{url}&p={page_number}'
        url_decoded = get_str_url_decoded(str_working=url_page)
        pk_print(working_str=rf'''url_page={url_page:60s}  url_decoded={url_decoded}  {'%%%FOO%%%' if LTA else ''}''')
        driver.get(url_page)
        WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.TAG_NAME, "body")))
        pk_sleep(milliseconds=random.randint(200, 333))
        page_src = driver.page_source
        soup = BeautifulSoup(page_src, "html.parser")
        # pk_print(f'''soup={soup}  {'%%%FOO%%%' if LTA else ''}''')
        magnet_links = {a["href"] for a in soup.find_all("a", href=True) if a["href"].startswith("magnet:")}
        pk_print(f'''Found {len(magnet_links)} magnet links on page {page_number}''')
        magnets_set |= magnet_links
    pk_print(f'''len(magnets_set)={len(magnets_set)}  {'%%%FOO%%%' if LTA else ''}''')
    return magnets_set


#
# def download_torrent_magnet_from_nyaa_si(string_to_search, driver_selenium, except_elements_all, include_elements_any, include_elements_all):
#     func_n=inspect.currentframe().f_code.co_name
#     pk_print(str_working=rf''' {'%%%FOO%%%' if LTA else ''}''', print_color='blue')
#     f_func_n_txt=rf'{PROJECT_D}\pkg_txt\{func_n}.txt'
#     query=urllib.parse.quote(f"{string_to_search}")
#     url=f'https://nyaa.si/?f=0&c=0_0&q={query}'
#     url_decoded=get_str_url_decoded(string=url)
#     driver_selenium.get(url)
#
#     # Get page source
#     page_src=driver_selenium.page_source
#     soup=BeautifulSoup(page_src, "html.parser")
#
#     hrefs=[]
#     titles=[]
#     lines=soup.find_all(name="a")
#     for line in lines:
#         titles.append(line.get('title'))
#         hrefs.append(line.get('href'))
#
#     hrefs=get_list_removed_element_preprocessed(hrefs)
#     titles=get_list_removed_element_preprocessed(titles)
#
#     # Log search parameters
#     string_to_search=get_str_removed_last_digit(string_to_search).strip()
#     pk_print(str_working=rf'''string_to_search="{string_to_search}"  {'%%%FOO%%%' if LTA else ''}''')
#     pk_print(str_working=rf'''url_decoded="{url_decoded}"  {'%%%FOO%%%' if LTA else ''}''')
#
#     # Match titles with regex
#     titles_matched_as_regex=[title for title in titles if title and is_regex_in_contents_with_case_ignored(contents=title, regex=string_to_search, debug_mode=True)]
#     # pk_print(str_working=rf'''titles_matched_as_regex="{titles_matched_as_regex}"  {'%%%FOO%%%' if LTA else ''}''')
#
#     # Filter titles and magnets
#     filtered_titles_and_magnets=[]
#     for title, magnet in zip(titles_matched_as_regex, hrefs):
#
#         if not magnet or not is_regex_in_contents_v2( target=magnet, regex="magnet*"):
#             continue
#
#         if except_elements_all and any(except_text in title for except_text in except_elements_all):
#             continue
#
#         if include_elements_all and not all(include_text in title for include_text in include_elements_all):
#             continue
#
#         if include_elements_any and not any(include_text in title for include_text in include_elements_any):
#             continue
#
#         filtered_titles_and_magnets.append((title, magnet))
#
#     # log
#     pk_print(f"Filtered Titles: {[tm for tm in filtered_titles_and_magnets]}")
#
#
#     # Open magnets and log
#     for i, (title, magnet) in enumerate(filtered_titles_and_magnets):
#         pk_print(f"{i}:{title}:{magnet}")
#         ipdb.set_trace()
#         webbrowser.open(magnet)
#
#     # Update downloaded list
#     f_func_n_txt_list=get_list_from_text_file(pnx=f_func_n_txt)
#     if f_func_n_txt_list is not None:
#         string_to_search=string_to_search.strip()
#         texts_updated=get_list_striped_element(items=f_func_n_txt_list)
#         texts_updated=list(dict.fromkeys(text for text in texts_updated if text and string_to_search not in text))
#         write_list_to_file(pnx=f_func_n_txt, texts=texts_updated, mode="w")
#
#     # Append next item to download list
#     string_downloaded=string_to_search.strip()
#     new_number=str(int(get_last_digit(string_downloaded)) + 1).zfill(2).strip()
#     text_removed_success_and_last_digit=get_str_removed_last_digit(string_downloaded).strip()
#     write_str_to_f(pnx=f_func_n_txt, text=f"{text_removed_success_and_last_digit} {new_number}\n", mode="a")


def run_cmd_exe():
    cmd_to_os(cmd=rf"start cmd.exe /k", mode="a")


def run_powershell_exe():
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    cmd_to_os('start cmd /k powershell', mode='a')
    # cmd_to_os('start cmd /k powershell')
    window_title_seg = "powershell"
    while 1:
        if not is_front_window_title(window_title_seg=window_title_seg):
            ensure_window_to_front(window_title_seg=window_title_seg)
        if is_front_window_title(window_title_seg=window_title_seg):
            break


def click_string(string, doubleclick_mode=False):
    import time
    time_limit = 20
    time_s = time.time()
    while 1:
        # pk_print(str_working=time.time() - time_s)
        if time.time() - time_s > time_limit:
            break
        if does_text_bounding_box_exist_via_easy_ocr(string=string):
            break
        pk_sleep(seconds=0.5)
    click_mouse_left_btn(doubleclick_mode=doubleclick_mode)


def shoot_custom_screenshot():
    import asyncio
    asyncio.run(shoot_custom_screenshot_via_asyncio())


# def make_plain_light_pkg_for_moving_to_house():
#     pnxs=[
#         rf"{PROJECT_D}\.git",
#         rf"{PROJECT_D}\.idea",
#         rf"{PROJECT_D}\.venv",
#     ]
#     dst= PROJECT_PARENTS_D
#     move_pnxs_without_overwrite(pnxs=pnxs, dst=dst)
#     back_up_pnx_to_dst(src=PROJECT_D, dst=DESKTOP)


def make_pkg(dst):
    from pkg_py.pk_core_constants import D_DESKTOP, D_PROJECT
    """wsl rar   wsl unrar   bz.exe  의존 """
    pnxs_required = get_pnx_list_from_d_working(d_working=D_PROJECT, with_walking=1)
    exclude_paths = [
        rf"{D_PROJECT}\.git",
        rf"{D_PROJECT}\.idea",
        rf"{D_PROJECT}\.venv",
        rf"{D_PROJECT}\__pycache__",
    ]
    pnxs_required = [path for path in pnxs_required if path not in exclude_paths]

    # backup
    # back_up_pnx_to_dst(src=PROJECT_D, dst=ARCHIVED)

    # del # remove됨...유의
    move_pnx_to_pk_recycle_bin(pnx=dst)

    # make
    ensure_pnx_made(pnx=dst, mode='d')

    # cp
    for pnx in pnxs_required:
        copy_pnx_with_overwrite(pnx=pnx, dst=dst)

    # compress
    compress_pnx(src=dst, dst=D_DESKTOP, with_timestamp=0)

    # del
    # move_pnx_to_trash_bin(pnx=dst)

    # decompress
    # decompress_pnx(src= rf"{dst}.rar", dst=DESKTOP)


def get_pnx_list_from_d_working(d_working, with_walking=1):
    import os
    if not os.path.exists(d_working):
        print(f"The pnx '{d_working}' does not exist.")
    if not is_d(d_working):
        print(f"The pnx '{d_working}' is not d")
    pnx_list = []
    if with_walking == 1:
        for root, d_nx_list, f_nx_list in os.walk(d_working):
            for d_nx in d_nx_list:
                pnx_list.append(os.path.join(root, d_nx))
            for f_nx in f_nx_list:
                pnx_list.append(os.path.join(root, f_nx))
        return pnx_list
    if with_walking == 0:
        if os.path.exists(d_working) and is_d(d_working):
            pnx_list = [os.path.join(d_working, item) for item in os.listdir(d_working)]
        return pnx_list


def copy_pnx(pnx_woking, d_dst, with_overwrite=0):
    if with_overwrite == 1:
        copy_pnx_with_overwrite(pnx_woking, d_dst)
    elif with_overwrite == 0:
        copy_pnx_without_overwrite(pnx_woking, d_dst)


def copy_pnx_without_overwrite(pnx, dst):
    import os
    import random
    import re
    import shutil
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    if not os.path.exists(pnx):
        print(f"소스 경로 '{pnx}'가 존재하지 않습니다.")
        return

    if not os.path.exists(dst):
        ensure_pnx_made(pnx=pnx, mode='d')
    if is_f(pnx):
        shutil.copy2(pnx, dst)
        print(f"f '{pnx}'을(를) '{dst}'로 복사했습니다.")
    elif is_d(pnx):
        try:
            pnx_p = os.path.dirname(pnx)
            time_pattern_with_underbar = rf"_{get_time_as_('now')}"
            pnx_n = get_n(pnx)
            pnx_x = get_x(pnx)
            pnx_new = rf"{dst}\{pnx_n}{pnx_x}"
            pattern = r'\d{4}_\d{2}_\d{2}_(월|화|수|목|금|토|일)_\d{2}_\d{2}_\d{2}_\d{3}'
            pnx_n = re.sub(pattern=pattern, repl='', string=pnx_n)
            pk_print(working_str=rf'''pnx="{pnx}"  {'%%%FOO%%%' if LTA else ''}''')
            pk_print(working_str=rf'''dst="{dst}"  {'%%%FOO%%%' if LTA else ''}''')
            dst_nx = None
            if not does_pnx_exist(pnx=pnx_new):
                dst_nx = rf"{dst}\{pnx_n}{pnx_x}"
            else:
                dst_nx = rf"{dst}\{pnx_n}{time_pattern_with_underbar}{random.randint(10, 99)}{pnx_x}"
            shutil.copytree(src=pnx, dst=dst_nx)
        except:
            pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
    else:
        print(f"소스 경로 '{pnx}'는 f도 d도 아닙니다.")


def get_pnx_excluded_list(d_working_list, exclusion_list):
    from pkg_py.pk_core_constants import D_PKG_TXT
    from pkg_py.pk_colorful_cli_util import pk_print
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    f_func_n_txt = rf"{D_PKG_TXT}/{func_n}.txt"
    f_func_n_txt = get_pnx_os_style(f_func_n_txt)
    ensure_pnx_made(pnx=f_func_n_txt, mode='f')
    pk_print(f'''func_n={func_n}  {'%%%FOO%%%' if LTA else ''}''')
    pk_print(f'''f_func_n_txt={f_func_n_txt}  {'%%%FOO%%%' if LTA else ''}''')
    pk_print(f'''d_working_list={d_working_list}  {'%%%FOO%%%' if LTA else ''}''')
    make_pnx_interested_list_to_f_txt_x(d_working_list=d_working_list, exclusion_list=exclusion_list)
    return get_list_from_f(f=f_func_n_txt)


#
# def get_driver_seleniumwire(browser_debug_mode):
#     func_n=inspect.currentframe().f_code.co_name
#
#     # 드라이버 옵션
#     options=get_webdriver_options_customed(browser_show=browser_debug_mode)
#
#     # 드라이버 as 크롬브라우저
#     driver=webdriver.Chrome(options=options)
#     # service=Service('path/to/chromedriver')  # 크롬 드라이버 경로
#     # driver=webdriver.Chrome(service=service, options=options)
#
#     # 브라우저 exec
#     driver.get('about:blank')
#     # driver.get('http://www.naver.com')
#
#     # driver.execute_script("Object.defineProperty(navigator, 'plugins', {get: function() {return[1, 2, 3, 4, 5]}})")  # hide plugin 0EA
#     # driver.execute_script("Object.defineProperty(navigator, 'languages', {get: function() {return ['ko-KR', 'ko']}})")  # hide own lanuages
#     # driver.execute_script("const getParameter=WebGLRenderingContext.getParameter;WebGLRenderingContext.prototype.getParameter=function(parameter) {if (parameter === 37445) {return 'NVIDIA Corporation'} if (parameter === 37446) {return 'NVIDIA GeForce GTX 980 Ti OpenGL Engine';}return getParameter(parameter);};")  # hide own gpu # WebGL렌더러를 Nvidia회사와 GTX980Ti엔진인 ‘척’ 하는 방법입니다.
#
#     # 플러그인 언어 소유GPU 숨기기
#     driver.execute_script("Object.defineProperty(navigator, 'plugins', {get: function() {return[1, 2, 3, 4, 5]}});")
#     # driver.execute_script("Object.defineProperty(navigator, 'languages', {get: function() {return ['ko-KR', 'ko']}});")
#     driver.execute_script(
#         "const getParameter=WebGLRenderingContext.getParameter; WebGLRenderingContext.prototype.getParameter=function(parameter) { if (parameter === 37445) { return 'NVIDIA Corporation'; } if (parameter === 37446) { return 'NVIDIA GeForce GTX 980 Ti OpenGL Engine'; } return getParameter(parameter); };")
#     return driver


def run_wsl(remote_os_distro_n, wsl_window_title_seg):
    # install wsl
    # install_wsl(remote_os_distro_n)

    if not is_window_opened(window_title_seg=wsl_window_title_seg):
        open_and_move_wsl_console_to_front(remote_os_distro_n=remote_os_distro_n, window_title_seg=wsl_window_title_seg)
    while 1:
        if is_front_window_title(window_title_seg=wsl_window_title_seg):
            break
        ensure_window_to_front(window_title_seg=wsl_window_title_seg)


def pk_paste():
    if is_os_wsl_linux():
        cmd_to_os('powershell.exe Get-Clipboard')
    else:
        import clipboard
        return clipboard.paste()


def play_my_video_track():
    import inspect
    from pkg_py.pk_core_constants import F_PKG_VIDEO_POTPLAYER64_DPL
    func_n = inspect.currentframe().f_code.co_name

    # cmd_to_os(cmd=rf'taskkill /f /im "PotPlayer64.exe" ', debug_mode=True)

    # 보던 거 재생
    # 바탕화면에 있는 PotPlayer64.dpl 를 pkg_video에 복사
    ensure_pnx_made(pnx=F_PKG_VIDEO_POTPLAYER64_DPL, mode='f')
    cmd_to_os(cmd=rf'explorer "{F_PKG_VIDEO_POTPLAYER64_DPL}" ')

    # 보지않은 거 틀기
    # classifying 안의 비디오들 재생
    pass


def remmina(users, ip, remote_os_distro_n, wsl_window_title_seg, pw, exit_mode):
    # todo
    cmd = 'wsl sudo apt update'
    cmd_to_os(cmd=cmd)

    cmd = 'sudo apt install remmina'
    cmd_to_os(cmd=cmd)

    cmd_to_wsl_os_like_person(cmd=rf'remmina -c rdp://{users}@{ip}', remote_os_distro_n=remote_os_distro_n, wsl_window_title_seg=wsl_window_title_seg)
    pass


def xfreerdp(users, ip, remote_os_distro_n, wsl_window_title_seg, pw, exit_mode):
    # todo
    cmd = 'wsl sudo apt update'
    cmd_to_os(cmd=cmd)

    cmd = 'sudo apt install freerdp2-x11'
    cmd_to_os(cmd=cmd)

    #         write_like_person(rf'xfreerdp /v:{ip}:3390 /u:{users} /p:{pw} /sec:nla /clipboard',remote_os_distro_n=remote_os_distro_n, wsl_window_title_seg=wsl_window_title_seg)
    #         write_like_person(rf'xfreerdp /v:{ip}:3390 /u:{users} /p:{pw} /sec:tls /clipboard',remote_os_distro_n=remote_os_distro_n, wsl_window_title_seg=wsl_window_title_seg)
    cmd_to_wsl_os_like_person(cmd=rf'xfreerdp /v:{ip}:3390 /u:{users} /p:{pw} /clipboard', remote_os_distro_n=remote_os_distro_n, wsl_window_title_seg=wsl_window_title_seg)


@pk_measure_seconds
def ping_v1(ip):
    # pk : windows 10 pro 에서 정상동작 확인
    # pk : 다만 평균속도가 1초로 느린편
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import Encoding, PK_BLANK
    if not ip:
        pk_print(f'''ping {ip} ''', print_color='red')
        return 0
    signiture = None
    if is_os_windows():
        cmd = rf"ping -n 1 -w 500 {ip}"  # 3600000ms 타임아웃
        signiture_list = ["(0% loss)", '(0% 손실)']
    else:
        cmd = rf"ping -c 1 -W 0.5 {ip}"  # 3600초 타임아웃
        signiture_list = [f'{PK_BLANK}0% packet loss']
    std_list = cmd_to_os(cmd=cmd, encoding=Encoding.UTF8)
    for line in std_list:
        if any(signiture in line for signiture in signiture_list):
            if LTA:
                pk_print(f'''ping {ip} ''', print_color='green')
            return 1
    pk_print(f'''ping {ip} ''', print_color='red')
    return 0


@pk_measure_seconds
def ping_v2(ip, timeout_ms=1000):
    # lazy import
    import subprocess
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import PK_BLANK

    if not ip:
        pk_print(f'ping {ip}', print_color='red')
        return 0

    # OS별 ping 명령어 및 성공 시그널 정의
    if is_os_windows():
        cmd = f"ping -n 1 -w {timeout_ms} {ip}"
        signatures = ["(0% loss)", "(0% 손실)"]
    else:
        sec = max(1, timeout_ms // 1000)
        cmd = f"ping -c 1 -W {sec} {ip}"
        signatures = [f"{PK_BLANK}0% packet loss"]

    try:
        proc = subprocess.Popen(
            cmd,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            text=True,  # universal_newlines=True 와 동일
            encoding='utf-8',  # utf-8로 디코딩 시도
            errors='ignore'  # 디코딩 오류 무시
        )
        stdout, _ = proc.communicate(timeout=(timeout_ms / 1000) + 0.5)
    except subprocess.TimeoutExpired:
        proc.kill()
        stdout = ""
    except Exception:
        stdout = ""

    # None 또는 빈값 방어
    if not stdout:
        stdout = ""

    # 결과 판정
    for line in stdout.splitlines():
        if any(sig in line for sig in signatures):
            if LTA:
                pk_print(f'ping {ip}', print_color='green')
            return 1

    pk_print(f'ping {ip}', print_color='red')
    return 0


@pk_measure_seconds
def ping_v3(ip, timeout_ms=1000):
    import subprocess
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import PK_BLANK

    if not ip:
        pk_print(f'ping {ip}', print_color='red')
        return 0

    # OS별 명령어 및 성공 시그널 정의
    if is_os_windows():
        cmd = f"ping -n 1 -w {timeout_ms} {ip}"
        signatures = ["(0% loss)", "(0% 손실)"]
        encoding = 'mbcs'  # ANSI 코드 페이지(한국어 Windows: CP949)
    else:
        sec = max(1, timeout_ms // 1000)
        cmd = f"ping -c 1 -W {sec} {ip}"
        signatures = [f"{PK_BLANK}0% packet loss"]
        encoding = 'utf-8'

    try:
        proc = subprocess.Popen(
            cmd,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            text=True,
            encoding=encoding,
            errors='ignore'
        )
        stdout, _ = proc.communicate(timeout=(timeout_ms / 1000) + 0.5)
    except subprocess.TimeoutExpired:
        proc.kill()
        stdout = ""
    except Exception:
        stdout = ""

    # stdout이 None이거나 빈값 방어
    if not stdout:
        stdout = ""

    # **리턴코드 우선 검사** (0이면 성공)
    if proc.returncode == 0:
        if LTA:
            pk_print(f'ping {ip}', print_color='green')
        return 1

    # 리턴코드로도 판단 안 될 때만 시그니처 검사
    for line in stdout.splitlines():
        if any(sig in line for sig in signatures):
            if LTA:
                pk_print(f'ping {ip}', print_color='green')
            return 1

    pk_print(f'ping {ip}', print_color='red')
    return 0


def ping(ip):
    return ping_v3(ip)


def check_signiture_in_loop(time_limit, working_list, signiture, signiture_found_ment):
    import time
    from pkg_py.pk_colorful_cli_util import pk_print
    lines = working_list
    time_s = time.time()
    while 1:
        for line in lines:
            if signiture in line:
                if LTA:
                    pk_print(working_str=rf'''{signiture_found_ment}  {'%%%FOO%%%' if LTA else ''}''', print_color="green")
                return 1
        if time.time() - time_s > time_limit:
            return 0
        pk_sleep(seconds=0.5)


@pk_measure_memory
def collect_magnet_set_from_nyaa_si(search_keyword=None, driver=None, via_f_txt=False, via_input=False):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    from urllib.parse import unquote, urlparse, parse_qs
    from pkg_py.pk_core_constants import D_PKG_TXT, D_PROJECT
    func_n = inspect.currentframe().f_code.co_name

    if not is_internet_connected():
        raise

    f = rf'{D_PKG_TXT}/pk_magnets.txt'
    ensure_pnx_made(pnx=f, mode="f")
    # answer = get_pk_input_via_tab(message=f'can i open {get_nx(f)} (o/x)=', tab_completer_iterable=['o', 'x'])
    # if is_os_windows():
    #     if answer == 'o':
    #         cmd_to_os(cmd=rf'explorer "{get_pnx_windows_style(f)}"', mode="a")
    # else:
    #     pk_print(working_str=rf'''{get_pnx_unix_style(f)}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
    #     pass # todo

    f_func_n_txt = rf'{D_PROJECT}\pkg_txt\{func_n}.txt'
    ensure_pnx_made(pnx=f_func_n_txt, mode="f")
    # window_title_seg = get_nx(f_func_n_txt)

    # include_elements_all = ['1080']
    # include_elements_any = ['SubsPlease', 'Moozzi']
    # exclude_elements_all = ["[New-raws]", "[LoliHouse]", "[Erai-raws]", "[Koi-Raws]", '[EMBER]', '[Lilith-Raws]', '[Yameii]', '[ASW]', '[shincaps]', '[AsukaRaws]']
    magnets_set = set()
    search_keyword_list = []

    ensure_pnx_made(pnx=rf'historical_{func_n}.txt', mode='f')
    historical_search_keyword_list = get_historical_list(f=rf'historical_{func_n}.txt')
    tab_completer_iterable = ['', '1080 [Batch]'] + historical_search_keyword_list
    search_keyword = get_pk_input(message='search_keyword=', answer_options=tab_completer_iterable)
    search_keyword = search_keyword.strip()
    write_list_to_f(f=rf'historical_{func_n}.txt', working_list=[search_keyword] + historical_search_keyword_list, mode="w")

    search_keyword = search_keyword.strip()
    search_keyword_list.append(search_keyword)

    # if via_f_txt:
    #     pk_print(f'''mode is via_f_txt mode''')
    #     pk_print(f'''via_f_txt={via_f_txt}  {'%%%FOO%%%' if LTA else ''}''')
    #     search_keyword_list = get_list_from_f(f=f_func_n_txt)
    #     search_keyword_list = get_list_removed_element_contain_prompt(working_list=search_keyword_list, prompt="#")
    #     search_keyword_list = get_list_replaced_element_from_str_to_str(working_list=search_keyword_list, from_str='pk_ani ', to_str='')
    #     search_keyword_list = get_list_replaced_element_from_str_to_str(working_list=search_keyword_list, from_str='pk_movie ', to_str='')
    #     search_keyword_list = get_list_replaced_element_from_str_to_str(working_list=search_keyword_list, from_str='pk_music ', to_str='')

    pk_print(f'''len(search_keyword_list)={len(search_keyword_list)}  {'%%%FOO%%%' if LTA else ''}''')
    # print_iterable_as_vertical(item_iterable=search_keyword_list, item_iterable_n="search_keyword_list")

    search_keyword_list = get_list_striped_element(working_list=search_keyword_list)
    search_keyword_list = get_list_deduplicated(working_list=search_keyword_list)

    if driver is None:
        driver = get_driver_selenium(browser_debug_mode=False)

    nyaa_si_supplier = get_pk_input(message='nyaa_si_supplier=', answer_options=['SubsPlease', '', 'Erai-raws'])
    magnets_set = magnets_set | get_magnets_set_from_nyaa_si(nyaa_si_supplier=nyaa_si_supplier, search_keyword=search_keyword, driver=driver)

    magnets_set_filtered = set()

    positive_filter_keywords = get_pk_input(message='positive_filter_keywords=', answer_options=['1080'])
    for magnet in magnets_set:
        decoded_magnet = unquote(magnet)
        parsed = urlparse(decoded_magnet)
        qs = parse_qs(parsed.query)
        dn = qs.get('dn', [''])[0]
        if all(keyword in dn for keyword in positive_filter_keywords):
            magnets_set_filtered.add(magnet)
    magnets_set = magnets_set_filtered
    pk_print(f'''len(magnets_set)={len(magnets_set)}  {'%%%FOO%%%' if LTA else ''}''', print_color="green")

    magnets_set_filtered = set()
    negative_filter_keywords = [
        "Yami Shibai 8",
        "Yami Shibai 9",
        "360p",
        "720p",
        "480p",
    ]
    print_iterable_as_vertical(item_iterable=negative_filter_keywords, item_iterable_n="negative_filter_keywords")
    for magnet in magnets_set:
        decoded_magnet = unquote(magnet)
        parsed = urlparse(decoded_magnet)
        qs = parse_qs(parsed.query)
        dn = qs.get('dn', [''])[0]
        if not any(keyword in dn for keyword in negative_filter_keywords):
            magnets_set_filtered.add(magnet)
    magnets_set = magnets_set_filtered

    f = rf'{D_PKG_TXT}/pk_magnets.txt'
    magnets_list = get_list_url_decoded_element(magnets_set)
    magnets_list = [magnet for magnet in sorted(magnets_list, key=lambda magnet: magnet.split("&dn=")[1] if "&dn=" in magnet else "")]
    write_list_to_f(f=f, working_list=magnets_list, mode="a")

    # magnets 중복remove
    magnets_list = get_list_from_f(f=f)
    magnets_list = get_list_striped_element(working_list=magnets_list)
    magnets_list = get_list_removed_element_empty(working_list=magnets_list)
    magnets_list = get_list_deduplicated(working_list=magnets_list)
    write_list_to_f(f=f, working_list=magnets_list, mode="w")

    # search_keyword_list 목록추가, search_keyword_list 중복remove
    search_keyword_list = get_list_from_f(f=f_func_n_txt) + search_keyword_list
    search_keyword_list = get_list_striped_element(working_list=search_keyword_list)
    search_keyword_list = get_list_removed_element_empty(working_list=search_keyword_list)
    search_keyword_list = get_list_deduplicated(working_list=search_keyword_list)
    write_list_to_f(f=f_func_n_txt, working_list=search_keyword_list, mode="w")


def get_list_contained_with_stamp_from_f(f, STAMP):
    from pkg_py.pk_colorful_cli_util import pk_print
    list_filtered = get_list_from_f(f=f)
    pk_print(f'''STAMP={STAMP}  {'%%%FOO%%%' if LTA else ''}''')
    list_filtered = get_list_contained_element(working_list=list_filtered, prefix=rf"{STAMP} ")
    pk_print(f'''list_filtered={list_filtered}  {'%%%FOO%%%' if LTA else ''}''')
    list_filtered = get_list_deduplicated(working_list=list_filtered)
    pk_print(f'''list_filtered={list_filtered}  {'%%%FOO%%%' if LTA else ''}''')
    list_filtered = get_list_removed_element_contain_prompt(working_list=list_filtered, prompt="#")
    pk_print(f'''list_filtered={list_filtered}  {'%%%FOO%%%' if LTA else ''}''')
    list_filtered = get_list_replaced_element_from_str_to_str(working_list=list_filtered, from_str=STAMP, to_str="")
    pk_print(f'''list_filtered={list_filtered}  {'%%%FOO%%%' if LTA else ''}''')
    list_filtered = get_list_striped_element(working_list=list_filtered)
    pk_print(f'''list_filtered={list_filtered}  {'%%%FOO%%%' if LTA else ''}''')
    return list_filtered


def collect_magnets_from_torrentqq(search_keyword=None, driver=None, via_f_txt=True):
    import sys
    from pkg_py.pk_core_constants import STAMP_TORRENTQQ
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PKG_TXT
    try:
        if not is_internet_connected():
            raise

        collect_magnets_from_nyaa_si_txt = rf'{D_PKG_TXT}/collect_magnets_from_nyaa_si.txt'
        magnets_set = set()

        # [OPTION]
        # window_title_seg = get_nx(collect_magnets_from_nyaa_si_txt)
        # if not is_window_open(window_title_seg=window_title_seg):
        # open_pnx_by_ext(pnx=f_func_n_txt)
        # move_window_to_front(window_title_seg=window_title_seg)
        # cmd_to_os(cmd=rf'explorer "{f_func_n_txt}" ', debug_mode=True, mode="a")

        # [OPTION]
        # search_keyword = search_keyword
        # search_keyword ="________________"
        # search_keyword = input_validated("serch_keyword")

        # [OPTION]
        # filtered_list.append(search_keyword)
        filtered_list = get_list_contained_with_stamp_from_f(f=collect_magnets_from_nyaa_si_txt, STAMP=STAMP_TORRENTQQ)

        # 전처리
        pk_print(f'''search_keyword_list={filtered_list}  {'%%%FOO%%%' if LTA else ''}''')
        filtered_list = get_list_removed_element_contain_prompt(working_list=filtered_list, prompt="#")  # 시작 문자가 '#'인 요소를 remove
        pk_print(f'''search_keyword_list={filtered_list}  {'%%%FOO%%%' if LTA else ''}''')
        filtered_list = get_list_striped_element(working_list=filtered_list)
        pk_print(f'''search_keyword_list={filtered_list}  {'%%%FOO%%%' if LTA else ''}''')
        filtered_list = get_list_removed_element_empty(working_list=filtered_list)
        pk_print(f'''search_keyword_list={filtered_list}  {'%%%FOO%%%' if LTA else ''}''')
        filtered_list = get_list_deduplicated(working_list=filtered_list)
        pk_print(f'''search_keyword_list={filtered_list}  {'%%%FOO%%%' if LTA else ''}''')
        print_iterable_as_vertical(item_iterable=filtered_list, item_iterable_n='search_keyword_list')
        pk_print(working_str=rf'''len(search_keyword_list)="{len(filtered_list)}"  {'%%%FOO%%%' if LTA else ''}''')

        # if driver is None:
        #     driver = get_driver_selenium_solved_cloudflare_sequrity()
        # get_driver_selenium_solved_cloudflare_sequrity() 재사용하면 magnet_link not found

        for search_keyword in filtered_list:
            # magnets_set = magnets_set | get_magnets_set_from_torrent_qq(search_keyword=search_keyword, driver=driver)# fail
            magnets_set = magnets_set | get_magnets_set_from_torrent_qq(search_keyword=search_keyword)

            # save magnets collected
            magnets_txt = rf'{D_PKG_TXT}/pk_magnets.txt'
            magnets_list = get_list_url_decoded_element(magnets_set)
            magnets_list = [magnet for magnet in sorted(magnets_list, key=lambda magnet: magnet.split("&dn=")[1] if "&dn=" in magnet else "")]
            magnets_list = [magnet for magnet in sorted(magnets_list, key=lambda magnet: magnet.split("&mgt_url=")[1] if "&mgt_url=" in magnet else "")]
            write_list_to_f(f=magnets_txt, working_list=magnets_list, mode="a")

            # magnets 중복remove
            magnets_list = get_list_from_f(f=magnets_txt)
            magnets_list = get_list_striped_element(working_list=magnets_list)
            magnets_list = get_list_removed_element_empty(working_list=magnets_list)
            magnets_list = get_list_deduplicated(working_list=magnets_list)
            write_list_to_f(f=magnets_txt, working_list=magnets_list, mode="w")

        # search_keyword_list 목록추가, search_keyword_list 중복remove
        filtered_list = get_list_from_f(f=collect_magnets_from_nyaa_si_txt) + filtered_list
        filtered_list = get_list_striped_element(working_list=filtered_list)
        filtered_list = get_list_removed_element_empty(working_list=filtered_list)
        filtered_list = get_list_deduplicated(working_list=filtered_list)
        write_list_to_f(f=collect_magnets_from_nyaa_si_txt, working_list=filtered_list, mode="w")

    except:
        traceback.print_exc(file=sys.stdout)


def collect_magnet_set():
    driver = get_driver_selenium(browser_debug_mode=False)
    # collect_magnet_set_from_nyaa_si(via_f_txt=True, driver=driver)

    import inspect
    func_n = inspect.currentframe().f_code.co_name
    ensure_pnx_made(pnx=rf'historical_{func_n}.txt', mode='f')
    historical_search_keyword_list = get_historical_list(f=rf'historical_{func_n}.txt')
    # tab_completer_iterable = ['', '1080 [Batch]'] + historical_search_keyword_list
    # search_keyword = get_pk_input_via_tab(message='search_keyword=', tab_completer_iterable=tab_completer_iterable).strip()
    # nyaa_si_supplier = get_pk_input_via_tab(message='nyaa_si_supplier=', tab_completer_iterable=['SubsPlease', '', 'Erai-raws'])
    search_keyword = ''  # pk_test
    nyaa_si_supplier = 'SubsPlease'  # pk_test
    collect_magnet_set_from_nyaa_si_p1(nyaa_si_supplier=nyaa_si_supplier, search_keyword=search_keyword, driver=driver)

    # collect_magnets_from_torrentqq(via_f_txt=True, driver=driver)


@pk_measure_seconds
def load_magnet_set_to_bittorrent():
    import webbrowser
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_HOME, D_PKG_TXT

    if not is_internet_connected():
        raise

    # pk_magnets.txt explorer
    f = rf'{D_PKG_TXT}/pk_magnets.txt'
    if is_os_windows():
        cmd_to_os(cmd=rf'explorer "{get_pnx_windows_style(f)}"', mode="a")
        if not is_front_window_title(window_title_seg=get_nx(f)):
            ensure_window_to_front(window_title_seg=get_nx(f))
    # else:
    #     f = get_pnx_unix_style(f)
    # cmd_to_os(cmd=rf'sudo nano "{f}"', debug_mode=True, mode="a")

    answer = get_pk_input(message='answer(o/x)=', answer_options=['o', 'x'])
    if answer != 'o':
        return
    magnet_list = get_list_from_f(f=get_pnx_os_style(f))

    # f.torrent 이 있는 경우, # magnets_set 에서  magnet remove
    d_bittorrent = [
        rf'{D_HOME}\AppData\Roaming\bittorrent',
    ]
    exclusion_list = [
        rf'.dat', rf'.dll', rf'.exe', rf'.dmp', rf'.lng', rf'.zip',
        rf'D:\$RECYCLE.BIN',
        rf'D:\System Volume Information',

        rf'E:\$RECYCLE.BIN',
        rf'E:\System Volume Information',

        rf'F:\$RECYCLE.BIN',
        rf'F:\System Volume Information',

        rf'deprecated',
        rf'archived',
        rf'.git',
        rf'.idea',
        rf'venv',
        rf'node_modules',
        rf'test_flutter',
        rf'pkg_font',
        rf'telegram memo export by static web',
        rf'docker_image_maker',
        rf'e-magazine',
        rf'netlify-web',
    ]
    pk_print(f'''d_bittorrent={d_bittorrent}  {'%%%FOO%%%' if LTA else ''}''')
    pk_print(f'''exclusion_list={exclusion_list}  {'%%%FOO%%%' if LTA else ''}''')
    f_torrent_from_d_bittorrent_list = get_pnx_excluded_list(d_working_list=d_bittorrent, exclusion_list=exclusion_list)
    pk_print(f'''f_torrent_from_d_bittorrent_list={f_torrent_from_d_bittorrent_list}  {'%%%FOO%%%' if LTA else ''}''')
    f_torrent_from_d_bittorrent_list = get_list_interested_from_list(working_list=f_torrent_from_d_bittorrent_list, ext_list_include=[".torrent"])
    pk_print(f'''f_torrent_from_d_bittorrent_list={f_torrent_from_d_bittorrent_list}  {'%%%FOO%%%' if LTA else ''}''')
    f_torrent_from_d_bittorrent_list = get_list_replaced_element_from_str_to_str(working_list=f_torrent_from_d_bittorrent_list, from_str=f'C:\\Users\\WIN10PROPC3\\AppData\\Roaming\\bittorrent\\', to_str='')
    pk_print(f'''f_torrent_from_d_bittorrent_list={f_torrent_from_d_bittorrent_list}  {'%%%FOO%%%' if LTA else ''}''')
    f_torrent_from_d_bittorrent_list = get_list_replaced_element_from_str_to_str(working_list=f_torrent_from_d_bittorrent_list, from_str=rf'.torrent', to_str='')
    pk_print(f'''f_torrent_from_d_bittorrent_list={f_torrent_from_d_bittorrent_list}  {'%%%FOO%%%' if LTA else ''}''')
    f_torrent_set = get_set_from_list(working_list=f_torrent_from_d_bittorrent_list)
    pk_print(f'''f_torrent_set={f_torrent_set}  {'%%%FOO%%%' if LTA else ''}''')
    magnet_required_set = {magnet for magnet in magnet_list if not any(torrent in magnet for torrent in f_torrent_set)}
    magnet_set = magnet_required_set
    magnet_list = get_list_from_set(magnet_set)
    magnet_list = [magnet for magnet in sorted(magnet_list, key=lambda magnet: magnet.split("&dn=")[1] if "&dn=" in magnet else "")]
    pk_print(f'''{len(magnet_list)} magnets are loading...  {'%%%FOO%%%' if LTA else ''}''')
    for magnet in magnet_list:
        if magnet.strip() == "":
            continue
        pk_print(f'''magnet={magnet}  {'%%%FOO%%%' if LTA else ''}''')
        interval_seconds = int(get_pk_input(message='interval_seconds=', answer_options=['1000', '5000', '10000']))
        if "&mgt_url=" in magnet:
            magnet = magnet.split("&mgt_url=")[1].strip()
            webbrowser.open(magnet)
        else:
            webbrowser.open(magnet)
        pk_sleep(milliseconds=interval_seconds)
        pk_press("alt", "n")


def move_f_via_telegram_bot_v2(f):
    from telegram import Bot
    from pkg_py.pk_core_constants import D_PKG_TXT
    token_telegram = get_token_from_f_token(f_token=rf'{D_PKG_TXT}\token_telegram.txt', initial_str="")
    token_telegram_chat_id = get_token_from_f_token(f_token=rf'{D_PKG_TXT}\token_telegram_chat_id.txt', initial_str="")
    bot = Bot(token=token_telegram)

    async def move_f_to_telegram_bot_chat_room():
        try:
            with open(f, "rb") as f_obj:
                await bot.send_document(chat_id=token_telegram_chat_id, document=f_obj, timeout=60)  # 기본 20초에서 60초로 증가
            print("_f_ 전송 성공!")
        except Exception as e:
            print(f"❌ 오류 발생: {e}")

    import asyncio
    asyncio.run(move_f_to_telegram_bot_chat_room())


def assist_to_command_via_voice_kiri():
    import random
    import traceback
    import speech_recognition as sr
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_ARCHIVED, D_PROJECT, D_WORKING, D_HOME
    from colorama import init as pk_colorama_init
    import os
    pk_colorama_init(autoreset=True)

    # ensure wsl
    config_remote_os = {}
    wsl_distro_n = "Ubuntu-24.04"
    config_remote_os['os_distro_n'] = wsl_distro_n
    config_remote_os['ip'] = get_wsl_ip(wsl_distro_n)
    config_remote_os['port'] = ensure_and_get_wsl_port(wsl_distro_n)
    config_remote_os['user_n'] = get_wsl_user_n(wsl_distro_n)
    config_remote_os['pw'] = get_wsl_pw(wsl_distro_n)
    config_remote_os['local_ssh_public_key'] = os.path.join(D_HOME, ".ssh", "id_ed25519.pub")
    config_remote_os['local_ssh_private_key'] = os.path.expanduser("~/.ssh/id_ed25519")
    ensure_wsl_distro_installed(wsl_distro_n=wsl_distro_n)
    ensure_wsl_distro_session(wsl_distro_n=wsl_distro_n)

    ensure_python_pkg_to_remote_os(py_pkg_n='SpeechRecognition', **config_remote_os)
    ensure_python_pkg_to_remote_os(py_pkg_n='PyAudio', **config_remote_os)

    # ensure_general_ubuntu_pkg()
    # mpg123 을 wsl 에 install 해서 써볼까? mpg123은 제어가 쉬울지도
    # ensure_ubuntu_pkg_to_remote_os(ubuntu_pkg_n='mpg123', ** config_remote_os)

    if not is_os_windows():
        cmd = 'sudo apt install mpg123'
        cmd_to_os(cmd=cmd)

    if is_internet_connected():
        # recognizer=sr.Recognizer()
        # with sr.Microphone() as source:
        #     pk_print(working_str="음성을 말하세요...")
        #     recognizer.adjust_for_ambient_noise(source)
        #     audio=recognizer.listen(source)
        pass
    else:
        # # CMU Sphinx로 음성 인식 (오프라인 사용 가능)
        # try:
        #     speak("음성을 인식 중...")
        #     text=recognizer.recognize_sphinx(audio)
        #     speak("인식된 텍스트: " + text)
        # except sr.UnknownValueError:
        #     speak("음성을 이해할 수 없습니다.")
        # except sr.RequestError as e:
        #     speak(f"음성 인식 서비스에 오류가 발생했습니다: {e}")
        pass

    # speak_like_parrot("테스트입니다")

    # os.system(rf"mpg123 ./{temp_mp3}")  # Linux 재생 명령
    # os.system(rf"start {temp_mp3}")  # Windows용 재생 명령

    recognizer = None
    if is_mic_device_connected():
        pk_print(f'''mic is connected. {'%%%FOO%%%' if LTA else ''}''')
        recognizer = sr.Recognizer()
    else:
        pk_print(f'''mic is disconnected. {'%%%FOO%%%' if LTA else ''}''', print_color='red')

    loop_cnt = 0
    while 1:
        if loop_cnt == 0:
            ice_breaking_ments = [
                "hello! i am mini, i am ready to assist",
                "Hello! How can I assist you today?",
                "",
            ]
            ice_breaking_ment = get_element_random(working_list=ice_breaking_ments)
            pk_print_and_speak(ice_breaking_ment)
        if loop_cnt % 11 == 0:
            ice_breaking_ments = [
                "please. give a command.",
                "i am boring. give a command."
                "i am boring. give a something."
                # get_str_today_day_info(),
            ]
            ice_breaking_ment = get_element_random(working_list=ice_breaking_ments)
            pk_print_and_speak(ice_breaking_ment)

        try:
            if working_str is None:
                with sr.Microphone() as source:
                    # recognizer.adjust_for_ambient_noise(source, duration=1.0)  # 주변 소음 보정 # adjust_for_ambient_noise no attribution
                    while 1:
                        try:
                            pk_print("지금 말씀하실것을 추천드립니다.", print_color='blue')
                            # audio = recognizer.listen(source, phrase_time_limit=10)  # 음성 듣기
                            working_str = recognizer.recognize_google(audio, language="ko")  # Google STT
                            break
                        except sr.UnknownValueError:
                            pk_print(f"UnknownValueError {working_str}")
                        except sr.RequestError as e:
                            pk_print(f"Google Speech Recognition service access", print_color='red')
            working_str = working_str.replace(' ', '')
            pk_print(rf"{working_str}", print_color='blue')
            if any(keyword in working_str for keyword in ["ipdb"]):
                import ipdb
                ipdb.set_trace()
            elif any(keyword in working_str for keyword in ["테스트", "test"]):
                pk_count_down()
            elif any(keyword in working_str for keyword in ["휴지통비워", "휴지통정리", "empty_trash_bin"]):
                empty_recycle_bin()
                pk_print_and_speak("I have emptied the trash bin")
            elif any(keyword in working_str for keyword in ["플레인", "플래인"]):
                pk_print_and_speak("yes. i am here")
            elif any(keyword in working_str for keyword in ["영어공부"]):
                pk_print_and_speak("What is the weather like?")
                pk_sleep(seconds=random.randint(a=200, b=500))
                pk_print_and_speak("I can't directly access weather information, but if you share your location, I can guide you!")
                pk_sleep(seconds=random.randint(a=200, b=500))
                pk_print_and_speak("Quit")
                pk_sleep(seconds=random.randint(a=200, b=500))
                pk_print_and_speak("Ending the conversation. Goodbye!")
            elif any(keyword in working_str for keyword in ["업무_d_생성", '업무_d_']):
                make_d_with_timestamp(d_nx=rf"생산관리", dst=rf"{D_WORKING}")
                assist_to_make_d_for_work()
            elif any(keyword in working_str for keyword in ["sound interactive mode"]):
                # guide_todo(days=1)  # todo : add : 등록된 스케쥴시간확인
                pk_print(working_str="Please give a cmd", print_color='blue')
                # print_and_speak("시키실 일 없으신가요.", after_delay=1.0) #random
                with sr.Microphone() as source:
                    # recognizer.adjust_for_ambient_noise(source)
                    recognizer.adjust_for_ambient_noise(source, duration=0.5)
                    # audio=recognizer.listen(source, time_limit=15, phrase_time_limit=10)
                    audio = recognizer.listen(source, phrase_time_limit=10)  # phrase_time_limit: Limit the maximum length of a phrase.
                    working_str = recognizer.recognize_google(audio, language="ko")
            elif any(keyword in working_str for keyword in ["버전자동업데이트", '버저닝']):
                make_version_new(via_f_txt=True)
            elif any(keyword in working_str for keyword in ["프로젝트백업", "백업", "백업해라"]):
                from pkg_py.pk_core_constants import D_PKG_PY
                restart_f_list_with_new_window_as_async([rf"{D_PKG_PY}/pk_kill_cmd_exe.py"])
            elif any(keyword in working_str for keyword in ["프로젝트백업", "백업", "백업해라"]):
                from pkg_py.pk_core_constants import D_PKG_PY
                restart_f_list_with_new_window_as_async([rf"{D_PKG_PY}/pk_back_up_project.py"])
            elif any(keyword in working_str for keyword in ["텔레그램으로 백업"]):
                import nest_asyncio
                import asyncio
                f = pk_back_up_pnx_without_venv_and_idea(pnx_working=D_PROJECT, d_dst=D_ARCHIVED, with_timestamp=0)
                nest_asyncio.apply()
                # asyncio.run(send_f_via_telegram_bot(f)) #  --> limit discovered : 단일파일 50MB 이상은 전송 불가 --> send_f_via_telegram_bot_v2(f)
                # send_f_via_telegram_bot_v2(f) # -->  fail --> timeout
                asyncio.run(move_f_via_telegram_bot_v3(f))  # -->
                # change_os_mode_to_power_saving_mode_as_s4()
                return  # return is necceary code, 처리 안시키면 PC 부팅 시 최대절전모드로 무한 진입, 컴퓨터 전원 재연결해야 된다 -> keyword = '' and use continue -> 시도하면 아마될듯 
                keyword = ''
                continue
            elif any(keyword in working_str for keyword in ["퇴근해", "자자"]):
                from pkg_py.pk_core_constants import D_PKG_PY
                restart_f_list_with_new_window_as_async([rf"{D_PKG_PY}/pk_자자.py"])
                keyword = ''
                continue
            elif any(keyword in working_str for keyword in ["트리정리"]):
                from pkg_py.pk_core_constants import D_PKG_PY
                restart_f_list_with_new_window_as_async([rf"{D_PKG_PY}/pk_organize_tree.py"])
                keyword = ''
                continue
            elif any(keyword in working_str for keyword in ["피케이"]):
                cmd_f_in_cmd_exe_like_person(cmd_prefix='python', f=rf"{D_PROJECT}/pk.py")
            elif any(keyword in working_str for keyword in ["할일", "스케쥴러", "스케쥴가이드"]):
                guide_todo()
            elif any(keyword in working_str for keyword in ["토렌트", "토렌트다운로드"]):
                pass
            elif any(keyword in working_str for keyword in ["유튜브다운로드"]):
                pass
            elif any(keyword in working_str for keyword in ["youtube channel download", "유튜브채널다운로드"]):
                pass
            elif any(keyword in working_str for keyword in ["ytctd", "youtube channel thumbnail download", "유튜브채널썸네일다운로드"]):
                youtube_channel_main_page_url = input('youtube_channel_main_page_url=')
                youtube_channel_main_page_url = youtube_channel_main_page_url.strip()
                download_youtube_thumbnails_from_youtube_channel_main_page_url(youtube_channel_main_page_url)
            elif any(keyword in working_str for keyword in ["오늘무슨날", "무슨날"]):
                pk_speak('today is christmas. happy christmas')
                pk_speak('today is newyear')
            elif any(keyword in working_str for keyword in ["오늘날짜", "날짜"]):
                speak_today_info_as_korean()
            elif any(keyword in working_str for keyword in ["요일", "오늘요일", "몇요일"]):
                pk_speak(f'{get_weekday_as_english()}')
            elif any(keyword in working_str for keyword in ["시간", "몇시야", "몇시"]):
                HH = get_time_as_('%H')
                mm = get_time_as_('%M')
                pk_speak(f'{int(HH)} hour {int(mm)} minutes')
            elif any(keyword in working_str for keyword in ["몇분이야", "몇분", "몇분"]):
                mm = get_time_as_('%M')
                pk_speak(f'{int(mm)} minutes')
            elif any(keyword in working_str for keyword in ["몇초야", "몇초"]):
                server_seconds = get_time_as_('%S')
                pk_speak(f'{server_seconds} seconds')
            elif any(keyword in working_str for keyword in ["날씨"]):
                pk_print_and_speak("Searching for weather...")
                get_comprehensive_weather_information_from_web()
            elif any(keyword in working_str for keyword in ["음악"]):
                play_my_sound_track()
                pk_print_and_speak("Playing music...")
            elif any(keyword in working_str for keyword in ["게임", "미니게임"]):
                run_up_and_down_game()
                pk_print_and_speak("Playing mini game...")
            elif any(keyword in working_str for keyword in ["exit"]):
                raise
            elif any(keyword in working_str for keyword in ["비디오"]):
                play_my_video_track()
                pk_print_and_speak("Playing video...")
            elif any(keyword in working_str for keyword in ["최대절전모드", "powersave", "sleep"]):
                save_power_as_s4()
                return  # return is necceary code, 처리 안시키면 PC 부팅 시 최대절전모드로 무한 진입, 컴퓨터 전원 재연결해야 된다.
            elif any(keyword in working_str for keyword in ["화면보호기", "화면보호"]):
                save_screen()
            else:
                pk_print(rf"it was Unknown command", print_color='yellow')  # woas
        except:
            pk_print_and_speak(f'''{__file__} 코드 exec 중 오류가 발생했습니다" ''', print_color='red')
            pk_print(f"{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}", print_color='red')
            if not is_mic_device_connected():
                pk_print(f'''mic is disconnected. {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        loop_cnt += 1
        pk_sleep(milliseconds=200)


def run_voice_note():
    import traceback
    import speech_recognition as sr
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import Encoding, UNDERLINE, D_PKG_TXT

    f_txt = rf"{D_PKG_TXT}/voice_memo.txt"

    f_txt = get_pnx_unix_style(pnx=f_txt)
    if not does_pnx_exist(pnx=f_txt):
        ensure_pnx_made(pnx=f_txt, mode='f')

    write_str_to_f(txt=f"{UNDERLINE}{get_time_as_('now')}\n", f=f_txt)

    f_txt = get_pnx_windows_style(pnx=f_txt)
    cmd = rf"explorer {f_txt}"
    cmd_to_os(cmd=cmd, mode='a')

    pk_print_and_speak("저는 텍스트f에 받아쓰는 음성메모장 voice_note 입니다")
    recognizer = sr.Recognizer()

    while 1:
        try:
            pk_print_and_speak("말씀해주세요", print_color='blue')
            with sr.Microphone() as source:
                recognizer.adjust_for_ambient_noise(source)
                audio = recognizer.listen(source)
            str_prompt = recognizer.recognize_google(audio, language="ko")
            pk_print_and_speak(rf"{str_prompt}")

            # 텍스트를 f에 저장
            with open(file=rf"{D_PKG_TXT}/voice_memo.txt", mode="a", encoding=Encoding.UTF8.value) as file:
                file.write(str_prompt + "\n")
        except sr.UnknownValueError:
            pass  # 음성을 인식하지 못한 경우 무시
        except OSError:
            pk_print(f'''마이크 장비가 없습니다" ''', print_color='red')
            break
        except:
            pk_print(f'''"음성 인식 서비스에 오류가 발생했습니다"" ''', print_color='red')
            pk_print(f"{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}", print_color='red')


def run_parrot():
    import traceback
    import speech_recognition as sr
    from pkg_py.pk_colorful_cli_util import pk_print
    recognizer = sr.Recognizer()
    pk_print_and_speak("저는 따라쟁이 앵무새 parrot 입니다")
    while 1:
        try:
            pk_print(working_str="말씀해주세요", print_color='blue')
            with sr.Microphone() as source:
                recognizer.adjust_for_ambient_noise(source)
                audio = recognizer.listen(source)
            str_prompt = recognizer.recognize_google(audio, language="ko")
            pk_print_and_speak(rf"{str_prompt}")
        except sr.UnknownValueError:
            pass
        except OSError:
            pk_print(f'''마이크 장비가 없습니다" ''', print_color='red')
            break
        except:
            pk_print(f'''"음성 인식 서비스에 오류가 발생했습니다"" ''', print_color='red')
            pk_print(f"{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}", print_color='red')


def get_videos_urls_from_youtube_channel_main_page(youtube_channel_main_page_url, debug_mode=True):
    from pkg_py.pk_colorful_cli_util import pk_print
    from selenium.webdriver.common.by import By
    driver = get_driver_selenium(browser_debug_mode=debug_mode)
    driver.get(youtube_channel_main_page_url)

    # 스크롤을 끝까지 내리기
    last_height = driver.execute_script("return document.documentElement.scrollHeight")
    while 1:
        driver.execute_script("window.scrollTo(0, document.documentElement.scrollHeight);")
        # sleep(seconds=random.randint(a=2, b=10))
        pk_sleep(seconds=5)  # 스크롤 사이에 대기시간 추가
        new_height = driver.execute_script("return document.documentElement.scrollHeight")
        if new_height == last_height:
            break
        last_height = new_height

    # 동영상탭 처리
    video_urls = set()
    videos = driver.find_elements(By.XPATH, '//a[@id="thumbnail"]')
    for video in videos:
        url = video.get_attribute("href")
        if url and "watch" in url:  # 영상 링크인지 확인
            video_urls.add(url)

    # shorts탭 처리
    shorts_elements = driver.find_elements(By.CSS_SELECTOR, "a.shortsLockupViewModelHostEndpoint")
    for element in shorts_elements:
        href = element.get_attribute("href")
        if href and "/shorts/" in href:
            video_urls.add(href)

    driver.quit()

    video_urls_list = None
    video_urls_list = list(video_urls)
    pk_print(f'''len(video_urls_list)="{len(video_urls_list)}"  {'%%%FOO%%%' if LTA else ''}''')
    for idx, url in enumerate(video_urls, start=1):
        pk_print(f'''f"{idx}: {url}"''')
    return video_urls_list


def get_f_video_of_d_working(d_working, ext_list_allowed):
    from pkg_py.pk_colorful_cli_util import pk_print
    import os
    pk_print(f'''d_working={d_working} extension_list_allowed={ext_list_allowed} {'%%%FOO%%%' if LTA else ''}''')
    if not os.path.exists(d_working):
        pk_print(f"d_working does not exists {d_working}")
    if os.path.exists(d_working):
        for f_nx in os.listdir(d_working):
            f = os.path.join(d_working, f_nx)
            ext = os.path.splitext(f)[1].lower()
            if not ext in ext_list_allowed:
                # pk_print(f"f={f}, ext={ext}, 조건 만족 여부: {ext in extensions}")
                pass
    f_list_of_d_working = [os.path.join(d_working, f) for f in os.listdir(d_working)]
    pk_print(f'''len(f_list_of_d_working)={len(f_list_of_d_working)}  {'%%%FOO%%%' if LTA else ''}''')
    f_video_list_allowed = [
        f for f in f_list_of_d_working
        if os.path.splitext(f)[1].lower() in ext_list_allowed
           and not any(keyword in os.path.basename(f).lower() for keyword in ["seg", "temp"])
    ]
    pk_print(f'''len(f_video_list_allowed)={len(f_video_list_allowed)}  {'%%%FOO%%%' if LTA else ''}''')
    if f_video_list_allowed:
        f_video_list_allowed.sort()
        return f_video_list_allowed[0]
    else:
        pk_print("조건에 맞는 f 없습니다.", print_color='red')
        return None


def get_f_video_list_allowed_to_load(ext_list_allowed, d_working):
    from pkg_py.pk_core_constants import F_VIDEO_LIST_ALLOWED_TO_LOAD_TXT
    from pkg_py.pk_colorful_cli_util import pk_print
    import os
    if LTA:
        pk_print(f'''ext_list_allowed={ext_list_allowed}  {'%%%FOO%%%' if LTA else ''}''')
    f_video_list_allowed = []
    pnx_list = get_pnx_list_from_d_working(d_working=d_working, with_walking=0)
    write_list_to_f(working_list=pnx_list, f=F_VIDEO_LIST_ALLOWED_TO_LOAD_TXT, mode='w')

    for f in get_list_from_f(F_VIDEO_LIST_ALLOWED_TO_LOAD_TXT):
        f = f.replace("\n", '')
        f_x = os.path.splitext(f)[1].replace("\n", '')
        f_nx = os.path.basename(f).lower()

        if not f_x:  # 확장자가 없을 경우 빈 문자열이기 때문에 예외 처리
            if LTA:
                pk_print(f"[NOT ALLOWED] [확장자 없음]: {f}", print_color='red')
            continue

        f_x = f_x.lower()  # 확장자가 있을 때만 소문자로 변환

        if f_x not in ext_list_allowed:
            if LTA:
                pk_print(f"[NOT ALLOWED] [확장자 불가]: f={f}", print_color='red')
            continue

        if any(keyword in f_nx for keyword in {"seg", "temp"}):
            if LTA:
                pk_print(f"[NOT ALLOWED] [금지 키워드 포함] : f={f} f_x={f_x}", print_color='red')
            continue
        if LTA:
            pk_print(f"[ALLOWED] [확장자 가능]: f={f} f_x={f_x}", print_color='green')
        f_video_list_allowed.append(f)

    return f_video_list_allowed


def ensure_d_size_consistently_stable(d_monitored, seconds_interval=0.1, check_times=30):
    """
    d_working _d_의 크기를 seconds_interval 초 동안 check_times 번 측정하고, 모든 측정 결과가 동일하면 True를 반환.

    :param d_monitored: 모니터링할 _d_의 절대경로
    :param seconds_interval: 측정 간격 (기본값 0.1초, 총 3초 동안 30번 측정)
    :param check_times: 총 측정 횟수 (기본값 30번)
    :return: 크기가 변하지 않으면 True, 변하면 False
    """

    import os
    def get_d_size(path):
        """_d_의 총 크기(바이트)를 반환하는 함수"""
        total_size = 0
        for dirpath, _, filenames in os.walk(path):
            for f in filenames:
                fp = os.path.join(dirpath, f)
                if os.path.isfile(fp):
                    total_size += os.path.getsize(fp)
        return total_size

    # 첫 번째 측정
    initial_size = get_d_size(d_monitored)
    for _ in range(check_times):
        pk_sleep(seconds=seconds_interval)
        current_size = get_d_size(d_monitored)
        if current_size != initial_size:
            return 0  # 크기가 변하면 False 반환
    return 1  # 30번 동안 크기가 동일하면 True 반환


def handle_losslesscut_loading(window_title, time_limit, with_key_handing=True):
    from pkg_py.pk_colorful_cli_util import pk_print
    import time
    if is_window_title_opened(window_title=window_title):
        time_s = time.time()
        while time.time() - time_s <= time_limit:  # 깔끔한 시간제한루프 예시
            f_loading_nx = get_f_loading_nx_by_pattern(pattern=r"_f_ 불러오는 중 - (.+?) - LosslessCut")
            if is_window_title_opened(window_title=rf"_f_ 불러오는 중 - {f_loading_nx} - LosslessCut"):
                pk_press("esc")
                pk_sleep(milliseconds=300)
                pk_press("space")
                break
            ensure_window_to_front(window_title_seg=window_title)
            # todo : 재생여부가 playing 이 아니면 재생하도록 하고 싶은데 CPU 점유율로는 재생여부를 알 수 가 없네.
    pk_print(rf"handle_losslesscut_loading {window_title} ... {'%%%FOO%%%' if LTA else ''}")


def get_d_size_fast(path):
    """_d_의 총 크기를 빠르게 계산하는 함수"""
    import os
    total_size = 0
    with os.scandir(path) as it:
        for entry in it:
            try:
                if entry.is_file():
                    total_size += entry.stat().st_size
                elif entry.is_dir():
                    total_size += get_d_size_fast(entry.path)  # 재귀적으로 크기 계산
            except FileNotFoundError:
                pass  # f이 이동 중이거나 삭제된 경우 무시
    return total_size


def get_d_size_and_f_cnt(d_working):
    """_d_ f개수 크기 반환"""
    import os
    total_size = 0
    f_cnt = 0
    with os.scandir(d_working) as it:
        for entry in it:
            try:
                if entry.is_file():
                    total_size += entry.stat().st_size
                    f_cnt += 1
                elif entry.is_dir():
                    sub_size, sub_count = get_d_size_and_f_cnt(entry.path)
                    total_size += sub_size
                    f_cnt += sub_count
            except FileNotFoundError:
                pass  # 이동 중 삭제된 f 처리
    return total_size, f_cnt


def ensure_d_size_stable(d_working, limit_seconds):
    """_d_ 크기와 f 개수가 일정한지 확인"""
    from pkg_py.pk_context_state_util import set_pk_context_state
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_context_state_util import pk_context_state
    import time
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    prev_size, prev_count = get_d_size_and_f_cnt(d_working)

    time_s = time.time()
    pk_print(f'''started at {time_s} for {limit_seconds} seconds stable monitoring{'%%%FOO%%%' if LTA else ''}''')
    while 1:
        pk_sleep(milliseconds=pk_context_state.milliseconds_for_speed_control)
        cur_size, cur_count = get_d_size_and_f_cnt(d_working)  # 현재 크기 및 f 개수 확인
        set_pk_context_state((cur_size, cur_count))  # 상태 변화 감지

        pk_print(f'''d size: {cur_size}, f cnt: {cur_count}, pk_state.milliseconds_for_speed_control={pk_context_state.milliseconds_for_speed_control} {'%%%FOO%%%' if LTA else ''}''')

        # _d_ 크기나 f 개수가 변경되면 즉시 0 반환
        if cur_size != prev_size or cur_count != prev_count:
            if LTA:
                pk_print(f"d size stable = 0")
            return 0
        time_e = time.time()
        time_delta = time_e - time_s
        if limit_seconds < time_delta:
            if LTA:
                pk_print(f"d size stable = 1")
            pk_print(f'''ensured d size is stable for {limit_seconds} seconds{'%%%FOO%%%' if LTA else ''}''')
            return 1  # 일정 시간 동안 변화가 없으면 안정적이라고 판단


def get_pnx_new(d_working, pnx):
    # move_pnx 에  mode_count 로 통합
    """중복되지 않는 새로운 f명을 생성"""
    import os
    pnx_nx = get_nx(pnx)
    pnx_n, pnx_x = os.path.splitext(pnx_nx)
    counter = 1
    pnx_new = os.path.join(d_working, pnx_nx)
    while os.path.exists(pnx_new):
        pnx_new = os.path.join(d_working, f"{pnx_n}_{counter}{pnx_x}")
        counter += 1
    return get_pnx_unix_style(pnx=pnx_new)


def pk_ensure_f_list_organized_by_keyword_and_x():
    import os
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_DOWNLOADS, D_PROJECT, D_WORKING
    try:
        while 1:
            d_working = get_pk_input(message='d_working=', answer_options=[os.getcwd(), D_WORKING, D_PROJECT, D_DOWNLOADS])
            keyword_to_organize_list = get_pk_input_list_via_tab(message='keyword_to_organize_list=', tab_completer_nested_iterable=[['seg', 'SEG']])
            x_to_organize_list = get_pk_input_list_via_tab(message='x_to_organize_list=', tab_completer_nested_iterable=[['mp4', 'mkv', 'avi'], ['.jpg', '.jpeg', '.png', '.webp', '.jfif']])
            if ensure_d_size_stable(d_working, limit_seconds=5):
                pnx_nx_list = os.listdir(d_working)  # _d_ 목록 가져오기
                for pnx_nx in pnx_nx_list:
                    pnx = os.path.join(d_working, pnx_nx)
                    if not os.path.isfile(pnx):
                        continue  # _d_는 무시
                    f_nx = pnx_nx
                    x_extracted = get_x(pnx).lower()  # 확장자 캐싱
                    for keyword in keyword_to_organize_list:
                        if keyword in f_nx:
                            d_new = os.path.join(d_working, keyword.lower())
                            os.makedirs(d_new, exist_ok=True)
                            f_new = get_pnx_new(d_working=d_new, pnx=pnx)
                            if not os.path.exists(f_new):
                                move_pnx(pnx=pnx, d_dst=d_new)
                                pk_print(f"f 이동 {f_nx} → {f_new}", print_color='green')
                    if x_extracted in x_to_organize_list:
                        d_new = os.path.join(d_working, x_extracted.replace(".", ""))
                        os.makedirs(d_new, exist_ok=True)
                        f_new = get_pnx_new(d_working=d_new, pnx=pnx)
                        if not os.path.exists(f_new):
                            move_pnx(pnx=pnx, d_dst=d_new)
                            pk_print(f"f 이동 {f_nx} → {f_new}", print_color='green')
    except KeyboardInterrupt:
        pk_print("\n 모니터링 중지됨.")


def pk_organize_f_list_by_nx_delimiter(d_working, nx_delimiter):
    import inspect
    import os
    from pkg_py.pk_colorful_cli_util import pk_print
    import shutil

    d_dst = os.path.join(d_working, nx_delimiter)
    if not os.path.exists(d_dst):
        os.makedirs(d_dst)
        pk_print(f'''d_dst={d_dst}  {'%%%FOO%%%' if LTA else ''}''')

    f_list_moved_flag = False
    for f_nx in os.listdir(d_working):
        f_filtered = os.path.join(d_working, f_nx)

        if not os.path.isfile(f_filtered):  # _d_는 무시
            continue

        if nx_delimiter in f_nx:
            f_target = os.path.join(d_dst, f_nx)

            if os.path.exists(f_target):
                pk_print(f"이동 불가: '{f_nx}' f이 이미 존재합니다.", print_color='red')
                continue

            shutil.move(f_filtered, f_target)
            func_n = inspect.currentframe().f_code.co_name
            stamp_func_n = rf'''[{func_n}()]'''
            pk_print(f"'{stamp_func_n} {f_nx}' f이 '{d_dst}'로 이동되었습니다.")
            f_list_moved_flag = True

    if not f_list_moved_flag:
        pk_print(f"'{nx_delimiter}'를 포함하는 f이 없습니다.")


def print_state_debugger_for_lossless_cut(stamp, state_running, state_loading, state_loaded, state_playing):
    from pkg_py.pk_colorful_cli_util import pk_print
    if LTA:
        pk_print(f'''state_running={state_running} {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''state_loading={state_loading} {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''state_loaded={state_loaded} {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''state_playing={state_playing} {'%%%FOO%%%' if LTA else ''}''')
        pk_print(stamp)
        input('press enter')


def pk_debug_state_for_object(stamp, **kwargs):
    # todo
    pass


# def pk_print(txt_whole, highlight_config_dict):
#     from pkg_py.pk_colorful_cli_util import print_as_log
#     if highlight_config_dict:
#         print_as_log(get_txt_highlighted(txt_whole=txt_whole, config_highlight_dict=highlight_config_dict))
#     else:
#         print_as_log(txt_whole)


def pk_debug_state_for_py_data_type_v2(pk_stamp, data_working, highlight_config_dict, with_LTA=1):
    from pkg_py.pk_core_constants import STAMP_PK_DEBUGER_ENVIRONMENT
    from pkg_py.pk_colorful_cli_util import pk_print
    import time
    if with_LTA == 1:
        if LTA == 1:
            if data_working:
                if isinstance(data_working, list):
                    for element in data_working:
                        # pk_print(f'''element={element} {'%%%FOO%%%' if LTA else ''}''')
                        pk_print(element, highlight_config_dict)
                elif isinstance(data_working, dict):
                    for key, value in data_working.items():
                        pk_print(f'{key}: {value}', highlight_config_dict)
                elif isinstance(data_working, str):
                    pk_print(f'{data_working}', highlight_config_dict)

            pk_time_limit = 30
            pk_time_s = time.time()
            while 1:
                elapsed = time.time() - pk_time_s
                if elapsed >= pk_time_limit:
                    pk_print(f'''time out (pk_time_limit={pk_time_limit}) {'%%%FOO%%%' if LTA else ''}''')
                    break
                user_input = pk_input_with_timeout(working_str=rf'{STAMP_PK_DEBUGER_ENVIRONMENT} {pk_stamp} Press Enter to continue.', timeout_secs=int(pk_time_limit - elapsed))
                if not user_input:
                    user_input = ""
                if user_input == "":
                    break
    elif with_LTA == 0:  # LTA=0 이더라도 출력은 그대로 쓸때
        if data_working:
            if isinstance(data_working, list):
                for element in data_working:
                    pk_print(element, highlight_config_dict)
            elif isinstance(data_working, dict):
                for key, value in data_working.items():
                    pk_print(f'{key}: {value}', highlight_config_dict)
            elif isinstance(data_working, str):
                pk_print(f'{data_working}', highlight_config_dict)


def pk_debug_state_for_py_data_type(pk_stamp, data_working, highlight_config_dict=None, with_LTA=1):
    pk_debug_state_for_py_data_type_v2(pk_stamp=pk_stamp, data_working=data_working, highlight_config_dict=highlight_config_dict, with_LTA=with_LTA)


# def save_to_f_and_get_f_video_list_allowed(f, d_working):
#     if not does_pnx_exist(pnx=f):
#         ensure_pnx_made(pnx=f, mode='f')
#     f_video_list_allowed_to_load = get_f_video_list_allowed_to_load(ext_list_allowed=EXT_ALLOWED_LIST, d_working=d_working)
#     write_list_to_f(working_list=f_video_list_allowed_to_load, f=f, mode='w')
#     return f_video_list_allowed_to_load

def check_root_right():
    # root 권한 검사
    import os
    if os.geteuid() != 0:
        return False
    return True


def clear_console():
    if is_os_windows():
        import os
        os.system('cls')


def get_pk_wsl_mount_d_v1(windows_path, path_to_mount):
    from pkg_py.pk_colorful_cli_util import pk_print
    if is_os_wsl_linux():
        check_root_right()
        import subprocess
        import os
        import sys
        # 1) 사용자 입력 받기
        ensure_pnx_made(pnx=windows_path, mode='f')
        windows_path = windows_path
        mount_point = path_to_mount
        windows_path = get_pnx_windows_style(pnx=windows_path)

        try:
            # 3) 마운트 지점 디렉토리 생성
            print(f"[*] 디렉토리 생성: sudo mkdir -p {mount_point}")
            subprocess.run(["sudo", "mkdir", "-p", mount_point], check=True)

            # 4) drvfs 마운트
            print(f"[*] 마운트: sudo mount -t drvfs '{windows_path}' {mount_point}")
            subprocess.run(["sudo", "mount", "-t", "drvfs", windows_path, mount_point], check=True)

            # current session
            # sudo mkdir -p /home/pk/Downloads/pk_working
            # sudo mount -t drvfs 'C:\Users\WIN10PROPC3\Downloads\pk_working' /home/pk/Downloads/pk_working
            # sudo chown 1000:1000 /home/pk/Downloads/pk_working

            # 5) 소유권을 현재 WSL 사용자로 변경
            uid = os.getuid()
            gid = os.getgid()
            print(f"[*] 소유권 변경: sudo chown {uid}:{gid} {mount_point}")
            subprocess.run(["sudo", "chown", f"{uid}:{gid}", mount_point], check=True)

        except subprocess.CalledProcessError as e:
            print(f"\n[!] 오류 발생 (exit {e.returncode}):\n{e.stdout or e.output}")
            sys.exit(1)

        if does_pnx_exist(pnx=mount_point):
            print(f"{mount_point} is mounted successfully.")
    elif is_os_windows():
        pk_print(f'''get_pk_wsl_mount_d is not supported in Windows. {'%%%FOO%%%' if LTA else ''}''')
    else:
        # (순수 Linux 등, WSL도 아니고 Windows도 아닌 경우 별도 처리 없음)
        pass


def get_pk_wsl_mount_d(windows_path, path_to_mount):
    get_pk_wsl_mount_d_v1(windows_path=windows_path, path_to_mount=path_to_mount)
    # get_pk_wsl_mount_d_v2(        windows_path=windows_path,        path_to_mount=path_to_mount)    


@lru_cache(maxsize=128)
def get_pk_wsl_mount_d_v2(windows_path: str, path_to_mount: str = 'Downloads/pk_working') -> str:
    # v1 속도 개선 시도 
    import os
    import subprocess

    # 윈도우 경로 -> WSL 경로로 변환
    try:
        # sample: C:\Users\WIN10PROPC3\Downloads\Videos → /mnt/c/Users/...
        wsl_path = subprocess.check_output(["wslpath", "-u", windows_path], text=True).strip()
    except Exception as e:
        raise RuntimeError(f"wslpath 변환 실패: {windows_path} → {e}")

    # 실제 마운트 경로를 구성해서 반환
    home_dir = os.path.expanduser("~")
    mounted_path = os.path.join(home_dir, path_to_mount)

    # 최종 경로로 매핑 (사용자 컨벤션에 따라 적절히 조합)
    # 여기서는 그냥 wslpath 결과를 반환하는 형태로 유지
    return wsl_path


def pk_print_state(state, pk_id, state_header=None):
    from pkg_py.pk_colorful_cli_util import pk_print
    if state_header is not None:
        pk_print(f'''{state_header} {f'{pk_id}' if LTA else ''}''', print_color='green')
    pk_print(f'''{state} {f'{pk_id}' if LTA else ''}''', print_color='green')


def get_video_filtered_list(d_working, ext_allowed_list, video_ignored_keyword_list):
    # return get_video_filtered_list_v3(d_working, ext_allowed_list, video_ignored_keyword_list)
    return get_video_filtered_list_v4(d_working, ext_allowed_list, video_ignored_keyword_list)


def get_video_filtered_list_v3(d_working, ext_allowed_list, video_ignored_keyword_list):
    import os
    import pickle
    import hashlib
    import inspect
    import time
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PKG_PKL

    func_n = inspect.currentframe().f_code.co_name

    # --- 캐시 파일 경로 ---
    # 키가 되는 인자를 해시 처리
    key_src = f"{d_working}|{sorted(ext_allowed_list)}|{sorted(video_ignored_keyword_list)}"
    key_hash = hashlib.md5(key_src.encode()).hexdigest()
    F_CACHE = f"{D_PKG_PKL}/{func_n}_{key_hash}.pkl"
    CACHE_TTL_SECONDS = 60  # 60초 이내라면 캐시 사용

    # --- WSL 경로 처리 ---
    if is_os_wsl_linux():
        d_working = get_pk_wsl_mount_d(windows_path=d_working, path_to_mount='Downloads/pk_working')

    # --- 캐시 로드 시도 ---
    if os.path.exists(F_CACHE):
        try:
            with open(F_CACHE, "rb") as f:
                cache = pickle.load(f)
            if time.time() - cache["timestamp"] < CACHE_TTL_SECONDS:
                pk_print(f"[CACHE] using video list cache from {F_CACHE}", print_color='cyan')
                return cache["video_list"]
        except Exception:
            pass  # 손상된 캐시는 무시

    # --- 파일 목록 생성 ---
    try:
        f_list = [os.path.join(d_working, f) for f in os.listdir(d_working)]
    except Exception as e:
        pk_print(f"[ERROR] Failed to read files from {d_working}: {e}", print_color='red')
        return []

    filtered = [
        f for f in f_list
        if os.path.splitext(f)[1].lower() in ext_allowed_list
           and os.path.isfile(f)
           and not any(keyword in os.path.basename(f) for keyword in video_ignored_keyword_list)
    ]

    # --- 캐시 저장 ---
    os.makedirs(os.path.dirname(F_CACHE), exist_ok=True)
    with open(F_CACHE, "wb") as f_obj:
        pickle.dump({
            "timestamp": time.time(),
            "video_list": filtered
        }, f_obj)

    pk_print(f"[CACHE] refreshed video list and saved to {F_CACHE}", print_color='green')
    return filtered


def get_video_filtered_list_v4(
        d_working,
        ext_allowed_list,
        video_ignored_keyword_list,
        cache_ttl=60,
        verbose=True,
        skip_hash_prefix=True,
        use_cache=True
):
    import os
    import pickle
    import hashlib
    import inspect
    import time
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PKG_PKL
    from pkg_py.pk_core import is_os_wsl_linux, get_pk_wsl_mount_d

    func_n = inspect.currentframe().f_code.co_name

    # --- WSL 경로 대응 ---
    if is_os_wsl_linux():
        d_working = get_pk_wsl_mount_d(windows_path=d_working, path_to_mount='Downloads/pk_working')

    # --- 캐시 경로 생성 ---
    key_src = f"{d_working}|{sorted(ext_allowed_list)}|{sorted(video_ignored_keyword_list)}|{skip_hash_prefix}"
    key_hash = hashlib.md5(key_src.encode()).hexdigest()
    f_cache = os.path.join(D_PKG_PKL, f"{func_n}_{key_hash}.pkl")

    # --- 캐시 로드 시도 ---
    if use_cache and os.path.exists(f_cache):
        try:
            with open(f_cache, "rb") as f:
                cache = pickle.load(f)
            if time.time() - cache.get("timestamp", 0) < cache_ttl:
                if verbose:
                    pk_print(f"[CACHE] using video list cache from {f_cache}", print_color='cyan')
                return cache["video_list"]
        except Exception as e:
            if verbose:
                pk_print(f"[CACHE] failed to load cache ({e}), will refresh", print_color='yellow')

    # --- 파일 목록 가져오기 ---
    try:
        file_list = [os.path.join(d_working, f) for f in os.listdir(d_working)]
    except Exception as e:
        pk_print(f"[ERROR] Failed to read files from {d_working}: {e}", print_color='red')
        return []

    ext_set = set(ext.lower() for ext in ext_allowed_list)
    filtered_list = []

    for f in file_list:
        base = os.path.basename(f)
        ext = os.path.splitext(f)[1].lower()

        if not os.path.isfile(f):
            continue
        if ext not in ext_set:
            continue
        if skip_hash_prefix and base.startswith("#"):
            continue
        if any(keyword in base for keyword in video_ignored_keyword_list):
            continue

        filtered_list.append(f)

    # --- 캐시 저장 ---
    if use_cache:
        try:
            os.makedirs(os.path.dirname(f_cache), exist_ok=True)
            with open(f_cache, "wb") as f:
                pickle.dump({
                    "timestamp": time.time(),
                    "video_list": filtered_list
                }, f)
            if verbose:
                pk_print(f"[CACHE] refreshed video list and saved to {f_cache}", print_color='green')
        except Exception as e:
            if verbose:
                pk_print(f"[CACHE] failed to save cache ({e})", print_color='red')

    return filtered_list


def update_if_changed(prev_cnt):
    from pkg_py.pk_colorful_cli_util import pk_print
    d_working = get_d_working()
    import os
    current_cnt = len(os.listdir(d_working))
    delta_cnt = current_cnt - prev_cnt
    if delta_cnt != 0:
        pk_print(f"f_cnt is not stable → update list ({prev_cnt}->{current_cnt}({delta_cnt}))", print_color='blue')
        return True, current_cnt
    pk_print(f"f_cnt is stable")
    return False, prev_cnt


def save_to_f_and_get_video_list(f, d_working, ext_allowed_list, video_ignored_keyword_list):
    from pkg_py.pk_colorful_cli_util import pk_print
    pk_print(f'''f={f} {'%%%FOO%%%' if LTA else ''}''')
    if not does_pnx_exist(pnx=f):
        ensure_pnx_made(pnx=f, mode='f')
    v_f_list = get_video_filtered_list(d_working, ext_allowed_list, video_ignored_keyword_list)
    write_list_to_f(v_f_list, f, mode='w')
    return v_f_list


@pk_measure_seconds
def load_f_video_on_losslesscut(f_video):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_LOSSLESSCUT_EXE
    if f_video is not None:
        if does_pnx_exist(f_video):
            cmd_to_os(cmd=rf'''start "" /MAX "{F_LOSSLESSCUT_EXE}" "{f_video}"''')
    else:
        pk_print(f'''f_video is None {'%%%FOO%%%' if LTA else ''}''')


@pk_measure_seconds
def run_losslesscut():
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_LOSSLESSCUT_EXE
    import os
    f_losslesscut_exe = get_pnx_windows_style(pnx=F_LOSSLESSCUT_EXE)
    if not os.path.exists(f_losslesscut_exe):
        if LTA:
            pk_print(f"{get_nx(f_losslesscut_exe)} is not installed", print_color='red')
    else:
        if LTA:
            pk_print(f"{get_nx(f_losslesscut_exe)} is installed", print_color='green')
    cmd_to_os(cmd=rf'''start "" /MAX "{f_losslesscut_exe}"''', mode='a')


def get_f_video_to_load(video_working_list):
    import os
    for f in video_working_list:
        f = f.strip()
        if os.path.exists(f):
            return f
    return None


def rerun_losslesscut(F_CACHE):
    kill_losslesscut()
    while 1:
        if not is_losslesscut_running(F_CACHE):
            run_losslesscut()
            break


def kill_losslesscut():
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_LOSSLESSCUT_EXE
    f_losslesscut_exe = get_pnx_windows_style(pnx=F_LOSSLESSCUT_EXE)
    cmd_to_os(cmd='taskkill.exe /im LosslessCut.exe /f')
    pk_print(f"{get_nx(f_losslesscut_exe)} is killed", print_color='green')


def is_losslesscut_running(F_CACHE):
    return is_losslesscut_running_v1()  # 느림지면. 재부팅해야 쓸만한 속도.
    # return is_losslesscut_running_v2()
    # return is_losslesscut_running_v3(F_CACHE) # 초기에 F_CASHE 갱신이 안되는 문제가 있음.


# def is_losslesscut_running_v2():
#     for proc in psutil.process_iter(['name']):
#         if proc.info['name'] == 'LosslessCut.exe':
#             return True
#     return False

def is_losslesscut_running_v1():
    # too slow
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_LOSSLESSCUT_EXE
    f_losslesscut_exe = get_pnx_windows_style(pnx=F_LOSSLESSCUT_EXE)
    std_list = cmd_to_os(cmd='tasklist.exe | findstr "LosslessCut.exe"')
    if len(std_list) == 0:
        pk_print(f"{get_nx(f_losslesscut_exe)} is not running", print_color='red')
        return False
    pk_print(f"{get_nx(f_losslesscut_exe)} is running", print_color='green')
    return True


def save_cash_to_f_pkl(F_CACHE, status):
    import time
    import pickle
    with open(F_CACHE, "wb") as f:
        pickle.dump({
            "timestamp": time.time(),
            "status": status
        }, f)


def is_losslesscut_running_v3(F_CACHE):
    import inspect
    import os
    import pickle
    import time
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_LOSSLESSCUT_EXE
    func_n = inspect.currentframe().f_code.co_name
    CACHE_TTL_SECONDS = 60

    f_losslesscut_exe = get_pnx_windows_style(pnx=F_LOSSLESSCUT_EXE)
    if not os.path.exists(F_CACHE):
        ensure_pnx_made(pnx=F_CACHE, mode='f')
        std_list = cmd_to_os(cmd='tasklist.exe | findstr "LosslessCut.exe"')
        status = len(std_list) > 0
        pk_print(f"status={status}", print_color='green')
        save_cash_to_f_pkl(F_CACHE, status=status)
    else:
        try:
            # 캐시, 유효한 캐시
            with open(F_CACHE, "rb") as f:
                cache = pickle.load(f)
            if time.time() - cache["timestamp"] < CACHE_TTL_SECONDS:
                status = cache["status"]
                pk_print(f"[CACHE] LosslessCut is {'running' if status else 'not running'}", print_color='blue')
                return status
            else:
                std_list = cmd_to_os(cmd='tasklist.exe | findstr "LosslessCut.exe"')
                status = len(std_list) > 0
                pk_print(f"status={status}", print_color='green')
                save_cash_to_f_pkl(F_CACHE, status=status)
                pk_print(f"{get_nx(f_losslesscut_exe)} is {'running' if status else 'not running'}", print_color='green' if status else 'red')
                return status
        except Exception:
            pass

        # def assist_to_load_video_at_losslesscut_v1(d_working):


#     from pkg_py.pk_core_constants import F_VIDEO_LIST_ALLOWED_TO_LOAD_TXT
#     EXT_ALLOWED_LIST = ['.mp4', '.mkv', '.avi', '.mov', '.wmv', '.flv', '.webm']
#     SPEED_CONTROLLER = []
#
#     save_to_f_and_get_f_video_list_allowed(f=F_VIDEO_LIST_ALLOWED_TO_LOAD_TXT, d_working=d_working)
#     ensure_f_video_loaded_at_losslesscut(d_working=d_working)


# def assist_to_load_video_at_losslesscut_v2(d_working, max_files=30):
#     import os
#     import time
#     import inspect
#     from pkg_py.pk_core_constants import F_VIDEO_LIST_ALLOWED_TO_LOAD_TXT
#     from pkg_py.pk_colorful_cli_util import pk_print
#     from pkg_py.pk_context_state_util import set_pk_context_state, pk_context_state
#
#     ext_allowed_list = ['.mp4', '.mkv', '.avi', '.mov', '.wmv', '.flv', '.webm']
#     video_ignored_keyword_list = ['-seg', 'SEG-']
#     state = [0, 0, 0, 0]
#     pk_print_state(state=state, pk_id="%%%FOO%%%")
#     state_running = 0
#     state_loading = 0
#     state_loaded = 0
#     state_playing = 0
#     time_limit = 4
#     loop_cnt = 1
#     f_cnt = len(os.listdir(d_working))
#     f_video_to_load = None
#     f_video_list_allowed = get_video_filtered_list(d_working, ext_allowed_list, video_ignored_keyword_list)[:max_files]
#     f_video_to_load = get_f_video_to_load(f_video_list_allowed)
#     save_to_f_and_get_video_list(f=f_video_to_load, video_ignored_keyword_list=F_VIDEO_LIST_ALLOWED_TO_LOAD_TXT, ext_allowed_list=ext_allowed_list)
#     rerun_losslesscut()
#     try:
#         while True:
#             # if f_video_to_load is None:
#             #     continue
#             changed, f_cnt = update_if_changed(f_cnt)
#             pk_print(f'''changed={changed} {'%%%FOO%%%' if LTA else ''}''')
#             if changed:
#                 f_video_list_allowed = get_video_filtered_list(d_working, ext_allowed_list, video_ignored_keyword_list)[:max_files]
#                 f_video_to_load = get_f_video_to_load(f_video_list_allowed)
#                 if not f_video_to_load:
#                     pk_print("변경 이후 처리할 비디오 없음. 종료.", print_color='yellow')
#                     continue
#                 save_to_f_and_get_video_list(f=f_video_to_load, video_ignored_keyword_list=F_VIDEO_LIST_ALLOWED_TO_LOAD_TXT, ext_allowed_list=ext_allowed_list)
#             state = [state_running, state_loading, state_loaded, state_playing]
#             pk_print_state(state=state, pk_id="%%%FOO%%%")
#             set_pk_context_state((state_running, state_loading, state_loaded, state_playing))
#             pk_sleep(milliseconds=pk_context_state.milliseconds_for_speed_control)
#             if state == [1, 1, 0, 0]:
#                 window_title = f"파일 불러오는 중 - {get_nx(f_video_to_load)} - LosslessCut"
#                 time_s = time.time()
#                 while time.time() - time_s <= time_limit:
#                     ensure_window_to_front(window_title_seg=window_title)
#                     if is_window_title_front(window_title):
#                         pk_press("esc")
#                         pk_sleep(milliseconds=300)
#                         pk_press("space")
#                         state_playing = 1
#                         continue
#             pk_print_state(state=state, pk_id="%%%FOO%%%")
#             if not state_running:
#                 # run_losslesscut()
#                 load_f_video_on_losslesscut(f_video_to_load)
#                 state_running = 1
#             pk_print_state(state=state, pk_id="%%%FOO%%%")
#             if is_window_title_opened("Loading file - LosslessCut") or \
#                     is_window_title_opened("파일 불러오는 중 - LosslessCut") or \
#                     is_window_title_opened(f"파일 불러오는 중 - {get_nx(f_video_to_load)} - LosslessCut"):
#                 state_loading = 1
#                 state_loaded = 0
#                 continue
#             pk_print_state(state=state, pk_id="%%%FOO%%%")
#             if is_window_title_opened(f"{get_nx(f_video_to_load)} - LosslessCut"):
#                 state_loading = 0
#                 state_loaded = 1
#             pk_print_state(state=state, pk_id="%%%FOO%%%")
#             if state_running and not state_loading and not state_loaded:
#                 load_f_video_on_losslesscut(f_video_to_load)
#                 state_loading = 1
#             pk_print_state(state=state, pk_id="%%%FOO%%%")
#             if state_running and state_loaded and not state_playing:
#                 window_title = f"{get_nx(f_video_to_load)} - LosslessCut"
#                 time_s = time.time()
#                 pk_print_state(state=state, pk_id="%%%FOO%%%")
#                 while time.time() - time_s <= time_limit:
#                     pk_print_state(state=state, pk_id="%%%FOO%%%")
#                     ensure_window_to_front(window_title_seg=window_title)
#                     if is_window_title_front(window_title):
#                         pk_press("esc")
#                         pk_sleep(milliseconds=300)
#                         pk_press("space")
#                         state_playing = 1
#                         break
#             pk_print_state(state=state, pk_id="%%%FOO%%%")
#             loop_cnt = loop_cnt + 1
#     except Exception as e:
#         func_n = inspect.currentframe().f_code.co_name
#         pk_print(f"[{func_n}()] {e}", print_color='red')


# def assist_to_load_video_at_losslesscut_v4(d_working, max_files=30):
#     import traceback
#     from pkg_py.pk_context_state_util import pk_context_state, set_pk_context_state
#     from pkg_py.pk_colorful_cli_util import pk_print
#
#     ext_allowed_list = ['.mp4', '.mkv', '.avi', '.mov', '.wmv', '.flv', '.webm']
#     video_ignored_keyword_list = ['-seg', 'SEG-']
#     state = {'running': 0, 'loading': 0, 'loaded': 0, 'playing': 0}
#     loop_cnt = 1
#
#     def press_escape_if_front(title):
#         ensure_window_to_front(window_title_seg=title)
#         if is_window_title_front(window_title=title):
#             pk_press("esc")
#
#     try:
#         f_video_list = get_video_filtered_list(d_working, ext_allowed_list, video_ignored_keyword_list)[:max_files]
#         f_video_to_load = get_f_video_to_load(f_video_list)
#
#         while True:
#             pk_print_state(state=state, pk_id="%%%FOO%%%")
#
#             if not does_pnx_exist(f_video_to_load):
#                 f_video_to_load = get_f_video_to_load(f_video_list)
#                 pk_print(f'f_video_to_load={f_video_to_load} %%%FOO%%%')
#
#             if state == {'running': 1, 'loading': 0, 'loaded': 1, 'playing': 0}:
#                 state = {'running': 0, 'loading': 0, 'loaded': 0, 'playing': 0}
#
#             if state == {'running': 1, 'loading': 1, 'loaded': 1, 'playing': 0}:
#                 if is_window_opened("정리 중 - LosslessCut"):
#                     # state = {k: 0 for k in state}
#                     state = {'running': 0, 'loading': 0, 'loaded': 0, 'playing': 0}
#                     continue
#
#             pk_print_state(state=state, pk_id="%%%FOO%%%")
#
#             if not is_losslesscut_running():
#                 rerun_losslesscut()
#                 state['playing'] = 0
#                 if f_video_to_load is None:
#                     return
#                 load_f_video_on_losslesscut(f_video_to_load)
#                 state['running'] = int(is_losslesscut_running())
#             else:
#                 state['running'] = 1
#
#             pk_print_state(state=state, pk_id="%%%FOO%%%")
#
#             if is_window_title_opened("LosslessCut"):
#                 load_f_video_on_losslesscut(f_video_to_load)
#                 continue
#
#             loading_titles = [
#                 "Loading file - LosslessCut",
#                 "파일 불러오는 중 - LosslessCut",
#                 f"파일 불러오는 중 - {get_nx(f_video_to_load)} - LosslessCut"
#             ]
#             for title in loading_titles:
#                 if is_window_title_opened(title):
#                     press_escape_if_front(title)
#                     state['loading'] = 1
#                     state['playing'] = 0
#                     break
#
#             video_title = f"{get_nx(f_video_to_load)} - LosslessCut"
#             if is_window_title_opened(video_title):
#                 state['loaded'] = 1
#
#             pk_print_state(state=state, pk_id="%%%FOO%%%")
#
#             if state == {'running': 1, 'loading': 1, 'loaded': 1, 'playing': 0}:
#                 while True:
#                     ensure_window_to_front(video_title)
#                     if is_window_title_front(video_title):
#                         pk_press("esc")
#                         pk_sleep(milliseconds=300)
#                         pk_press("space")
#                         state['playing'] = 1
#                         break
#
#             pk_print_state(state=state, pk_id="%%%FOO%%%")
#             set_pk_context_state(state)
#             if loop_cnt % 100 == 2:
#                 pk_sleep(milliseconds=pk_context_state.milliseconds_for_speed_control)
#             pk_sleep(milliseconds=20)
#             # pk_sleep(milliseconds=pk_context_state.milliseconds_for_speed_control)
#             loop_cnt += 1
#
#     except Exception:
#         pk_print(traceback.format_exc() + "  %%%FOO%%%", print_color='red')


def assist_to_load_video_at_losslesscut_v5(max_files=30):
    # it wors at windows 
    from pkg_py.pk_context_state_util import pk_context_state, set_pk_context_state
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_context_state_util import set_pk_context_state_milliseconds_for_speed_control_forcely
    from pkg_py.pk_core_constants import D_DOWNLOADS, D_PROJECT, D_WORKING, F_HISTORICAL_PNX, D_PKG_PKL
    import inspect
    try:
        func_n = inspect.currentframe().f_code.co_name
        F_CACHE = f"{D_PKG_PKL}/{func_n}.pkl"
        # ensure_pnx_removed(pnx=F_CACHE)
        # if not does_pnx_exist(pnx=F_CACHE):
        #     pk_print(f'''의도대로 동작''', print_color='green')      
        #     return
        historical_pnx_list = get_historical_list(f=F_HISTORICAL_PNX)
        tab_completer_iterable = historical_pnx_list + get_list_sorted(working_list=[get_d_working(), D_WORKING, D_PROJECT, D_DOWNLOADS], mode_asc=1)
        d_working = get_pk_input(message='d_working=', answer_options=tab_completer_iterable)
        d_working = get_pnx_os_style(pnx=d_working)
        d_working = d_working.strip()
        if does_pnx_exist(d_working):
            write_list_to_f(f=F_HISTORICAL_PNX, working_list=[d_working] + historical_pnx_list, mode="w")
        ext_allowed_list = ['.mp4', '.mkv', '.avi', '.mov', '.wmv', '.flv', '.webm']
        video_ignored_keyword_list = ['-seg', 'SEG-']
        f_video_list_allowed = get_video_filtered_list(d_working, ext_allowed_list, video_ignored_keyword_list)[:max_files]
        f_video_to_load = get_f_video_to_load(f_video_list_allowed)
        loop_cnt = 1
        state = {'running': 0, 'loading': 0, 'loaded': 0, 'playing': 0}
        while True:
            clear_console()
            if f_video_to_load is None:
                pk_print(f'''f_video_to_load is None {'%%%FOO%%%' if LTA else ''}''')
                f_video_list_allowed = get_video_filtered_list(d_working, ext_allowed_list, video_ignored_keyword_list)[:max_files]
                f_video_to_load = get_f_video_to_load(f_video_list_allowed)
                continue
            pk_print_state(state=state, pk_id="%%%FOO%%%")
            if not does_pnx_exist(pnx=f_video_to_load):
                f_video_to_load = get_f_video_to_load(f_video_list_allowed)
                set_pk_context_state_milliseconds_for_speed_control_forcely(value=100)
                state['playing'] = 0
            if state == {'running': 1, 'loading': 1, 'loaded': 1, 'playing': 0}:
                window_title = f"정리 중 - LosslessCut"
                if is_window_opened(window_title_seg=window_title):
                    state = {'running': 0, 'loading': 0, 'loaded': 0, 'playing': 0}
                    continue
            pk_print_state(state=state, pk_id="%%%FOO%%%")
            if not is_losslesscut_running(F_CACHE):
                rerun_losslesscut(F_CACHE)
                state['running'] = 1
                # if f_video_to_load is None:
                #     return
                load_f_video_on_losslesscut(f_video_to_load)
                state['playing'] = 0
            else:
                state['running'] = 1
            pk_print_state(state=state, pk_id="%%%FOO%%%")
            window_title = "LosslessCut"
            if is_window_title_opened(window_title):
                load_f_video_on_losslesscut(f_video_to_load)
                state['playing'] = 0
                continue
            window_title = "Loading file - LosslessCut"
            if is_window_title_opened(window_title):
                ensure_window_to_front(window_title_seg=window_title)
                if is_window_title_front(window_title):
                    pk_press("esc")
                state['loading'] = 1
                state['playing'] = 0
                continue
            window_title = "파일 불러오는 중 - LosslessCut"
            if is_window_title_opened(window_title):
                ensure_window_to_front(window_title_seg=window_title)
                if is_window_title_front(window_title):
                    pk_press("esc")
                state['loading'] = 1
                state['playing'] = 0
                continue
            window_title = f"파일 불러오는 중 - {get_nx(f_video_to_load)} - LosslessCut"
            if is_window_title_opened(window_title):
                ensure_window_to_front(window_title_seg=window_title)
                if is_window_title_front(window_title):
                    pk_press("esc")
                state['loading'] = 1
                state['playing'] = 0
                continue
            pk_print_state(state=state, pk_id="%%%FOO%%%")
            if is_window_title_opened(f"{get_nx(f_video_to_load)} - LosslessCut"):
                state['loaded'] = 1
            pk_print_state(state=state, pk_id="%%%FOO%%%")
            if state == {'running': 1, 'loading': 1, 'loaded': 1, 'playing': 0}:
                window_title = f"{get_nx(f_video_to_load)} - LosslessCut"
                while 1:
                    ensure_window_to_front(window_title_seg=window_title)
                    if is_window_title_front(window_title):
                        pk_press("esc")
                        pk_sleep(milliseconds=300)
                        pk_press("space")
                        state['playing'] = 1
                        # for _ in range(10):
                        #     pk_sleep(milliseconds=300)
                        #     pk_press("tab")
                        # pk_sleep(milliseconds=300)
                        # pk_press("space")
                        # click_mouse_left_display_center()
                        pk_print(f'''step 1{'%%%FOO%%%' if LTA else ''}''')
                        break
            pk_print_state(state=state, pk_id="%%%FOO%%%")
            if state == {'running': 1, 'loading': 0, 'loaded': 1, 'playing': 0}:
                window_title = f"{get_nx(f_video_to_load)} - LosslessCut"
                while 1:
                    ensure_window_to_front(window_title_seg=window_title)
                    if is_window_title_front(window_title):
                        pk_press("esc")
                        pk_sleep(milliseconds=300)
                        pk_press("space")
                        state['playing'] = 1
                        pk_sleep(milliseconds=300)
                        pk_press("f11")
                        pk_sleep(milliseconds=300)
                        pk_print(f'''step 2{'%%%FOO%%%' if LTA else ''}''')
                        break
                state = {'running': 1, 'loading': 1, 'loaded': 1, 'playing': 1}
            pk_print_state(state=state, pk_id="%%%FOO%%%")
            set_pk_context_state(state)
            pk_sleep(milliseconds=pk_context_state.milliseconds_for_speed_control)
            loop_cnt = loop_cnt + 1
    except Exception as e:
        import traceback
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')


def assist_to_load_video_at_losslesscut():
    # assist_to_load_video_at_losslesscut_v4(d_working) # code for gpt
    assist_to_load_video_at_losslesscut_v5()  # 안정적인 것으로 판단, 그러나 느린 상태를 디버깅 필요. v6


def get_cmd_to_autorun():
    import winreg
    try:
        with winreg.OpenKey(winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Command Processor") as key:
            value, _ = winreg.QueryValueEx(key, "Autorun")
            return value
    except FileNotFoundError:
        return None


async def terminate_process_async(pid, name, cmd_exe_title):
    """
    특정 PID의 프로세스를 종료하는 비동기 함수
    """
    import psutil
    import asyncio
    from pkg_py.pk_colorful_cli_util import pk_print
    try:
        proc = psutil.Process(pid)
        await asyncio.to_thread(proc.terminate)  # 프로세스 종료 요청 (비동기 exec )
        await asyncio.to_thread(proc.wait, timeout=5)  # 종료될 때까지 비동기 대기
        pk_print(f"[PROCESS TERMINATED] cmd_exe_title={cmd_exe_title} PID={pid} Name={name}", print_color="green")
    except psutil.TimeoutExpired:
        pk_print(f"[PROCESS TERMINATION TIMEOUT] cmd_exe_title={cmd_exe_title} PID={pid}", print_color='red')
    except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
        pass  # 무시하고 넘어감


async def pk_run_process_as_async_v2(f, mode_with_window=1):
    '''todo : python 프로세스 말고 다른 프로세스도 동작되도록 추가.'''
    from pkg_py.pk_colorful_cli_util import pk_print
    import inspect
    import subprocess
    import os

    func_n = inspect.currentframe().f_code.co_name
    stamp_func_n = rf'''[{func_n}()]'''

    f = get_pnx_os_style(pnx=f)

    cmd_to_run = None
    if get_x(f) == '.py':
        cmd_to_run = 'python'
    elif get_x(f) == '':
        cmd_to_run = 'explorer'
    elif get_x(f) == '.cpp':
        pass  # 빌드된 실행 파일을 실행하도록 나중에 처리
    else:
        cmd_to_run = 'python'

    full_cmd = [cmd_to_run, f]
    pk_print(f'''full_cmd={full_cmd}  {'%%%FOO%%%' if LTA else ''}''')

    if mode_with_window == 0:  # 창 없이 실행
        create_no_window = 0x08000000
        subprocess.Popen(
            full_cmd,
            creationflags=create_no_window,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
    else:  # 기존처럼 실행
        cmd = f'start "" {cmd_to_run} "{f}"'
        pk_print(f'''cmd={cmd} {'%%%FOO%%%' if LTA else ''}''')
        os.system(cmd)
    pk_print(f"{stamp_func_n} {get_nx(f)} ", print_color="green")  # 눈속임


async def pk_run_process_as_async(f, mode_with_window=1):
    await pk_run_process_as_async_v2(f, mode_with_window=mode_with_window)


async def pk_run_process_as_async_v1(f, mode_with_window=1):
    '''todo : python 프로세스 말고 다른 프로세스도 동작되도록 추가.'''
    '''mode_with_window =0 하면 창이 안뜨는 것을 기대하나 안되는 현상 발견 '''
    '''원인은 cmd /k 로 명령어를 수행하는 행위'''
    from pkg_py.pk_colorful_cli_util import pk_print
    import inspect

    func_n = inspect.currentframe().f_code.co_name
    stamp_func_n = rf'''[{func_n}()]'''

    f = get_pnx_os_style(pnx=f)

    cmd_to_run = None
    if get_x(f) == '.py':
        cmd_to_run = 'python'
    elif get_x(f) == '':
        cmd_to_run = 'explorer'
    elif get_x(f) == '.cpp':
        pass
    else:
        cmd_to_run = 'python'
    cmd_to_autorun = get_cmd_to_autorun()
    if cmd_to_autorun:
        cmd = f'start "" cmd.exe /k "{cmd_to_autorun} && title {get_nx(f)}&& {cmd_to_run} {f}"'
    else:
        cmd = f'start "" cmd.exe /k "title {get_nx(f)}&& {cmd_to_run} {f}"'
    pk_print(f'''cmd={cmd}  {'%%%FOO%%%' if LTA else ''}''')
    cmd_to_os(cmd=cmd, mode='a', mode_with_window=mode_with_window)
    # pk_print(f"{stamp_func_n} get_nx(f)={get_nx(f)} ", print_color="green")  # 눈속임
    pk_print(f"{stamp_func_n} {get_nx(f)} ", print_color="green")  # 눈속임


# @debuger
def guide_todo():
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_MEMO_TRASH_BIN_TOML, F_MEMO_WORK_PK
    import re
    from datetime import datetime
    pk_sleep(milliseconds=1000)

    from colorama import init as pk_colorama_init
    pk_colorama_init(autoreset=True)

    # pnx by os style
    MEMO_DONE_TXT, MEMO_TODO_TXT, MEMO_TRASH_BIN_TXT = map(get_pnx_os_style, (F_MEMO_WORK_PK, F_MEMO_WORK_PK, F_MEMO_TRASH_BIN_TOML))

    # explorer
    # open_pnx_by_ext(pnx=MEMO_TODO_TXT)

    # f = rf'{__file__}'

    pnxs = [
        MEMO_TODO_TXT,
        # f,
    ]

    if not is_f(MEMO_TODO_TXT):
        print(f"할일 목록 f을 찾을 수 없습니다 {MEMO_TODO_TXT}")
        return

    # lios
    # todo_lines_list = get_list_from_f(f=memo_todo_txt)
    # todo_lines_list = get_list_removed_element_contain_str(working_list=todo_lines_list, string="#")
    # todo_lines_str = get_str_from_list(working_list=todo_lines_list, item_connector='')
    # print_with_highlighted(txt_whole=todo_lines_str, txt_highlighted_list=['2025'])
    # print_memo_titles(f=f)

    # bring MEMO_TODO_TXT
    todo_lines_list = get_list_from_f(f=MEMO_TODO_TXT)

    # ## 처리
    move_memo_lines_containing_keywords_to_f(f_from=MEMO_TODO_TXT, f_to=MEMO_TRASH_BIN_TXT, keyword='##')  # useless
    # # 처리
    move_memo_lines_containing_keywords_to_f(f_from=MEMO_TODO_TXT, f_to=MEMO_DONE_TXT, keyword='#')  # done

    # 오름차순 정렬
    # todo_lines_list = get_list_sorted_element(working_list=todo_lines_list)

    # 단어간 간격 정렬
    todo_lines_list = get_list_aligned_words_gap(working_list=todo_lines_list, size=40)

    # todo : ref : 중복지우면 안된다.
    # todo_lines_list = get_list_removed_element_duplicated(working_list=todo_lines_list)

    # rewrite
    write_list_to_f(working_list=todo_lines_list, f=MEMO_TODO_TXT, mode='w', line_feed_mode=0, head_line_mode=False)

    stamp_todo_task_list = []
    # today_task_list = []
    today_and_past_task_list = []
    while 1:
        try:
            lines = get_list_from_f(f=MEMO_TODO_TXT)

            for line in lines:
                if line.startswith("[todo] "):
                    stamp_todo_task_list.append(line)

            # 오늘 날짜를 'YYYY-MM-DD' 형식으로 가져옴
            today = datetime.now().strftime('%Y-%m-%d')
            pattern_date_and_time = re.compile(r'^\[todo\] (\d{4}-\d{2}-\d{2}) \(\w+\) (\d{2}:\d{2}|__:__)')
            for line in stamp_todo_task_list:
                match = pattern_date_and_time.match(line)
                if match:
                    date_str, time_str = match.groups()
                    if date_str <= today:
                        today_and_past_task_list.append(line)
            task_name = None
            for today_and_past_task in today_and_past_task_list:
                pk_print(f'''today_and_past_task={today_and_past_task}  {'%%%FOO%%%' if LTA else ''}''')
                pattern_date_and_time = re.compile(r'^\[todo\] (\d{4}-\d{2}-\d{2}) \(\w+\) (\d{2}:\d{2}|__:__)')
                match = pattern_date_and_time.match(today_and_past_task)
                date_str, time_str = match.groups()
                pattern_time = r'\b\d{2}:\d{2}\b'
                match = re.search(pattern_time, today_and_past_task)
                if match:
                    stamp_time = match.group()
                    HH = match.group().split(':')[0]
                    mm = match.group().split(':')[1]
                else:
                    stamp_time = "__:__"
                task_name = today_and_past_task.split(stamp_time)[1].split("[")[0].split('"')[1].strip()
                pk_print(f'{task_name} 수행미션 부여되었습니다 ({date_str} {stamp_time})', print_color='blue')
                # speak(f'{task_name} 수행미션 부여되었습니다')
                pk_print("미션을 완료하셨다면 Enter 키를 눌러주세요...", print_color='white')
                # speak("미션을 완료하셨다면 Enter 키를 눌러주세요...")
                answer = input()
                answer = answer.strip()
                if answer == "":
                    prompt_positive = rf"{task_name.replace("\n", "")}를 수행미션완료 처리합니다"
                    pk_print(prompt_positive)
                    # speak(prompt_positive)
                    today_and_past_task_list.remove(today_and_past_task)
                    # 해당 줄을 주석 처리
                    line_hashtaged = f"# {today_and_past_task}\n"
                    # f에 변경사항을 저장
                    task_list = get_list_from_f(f=MEMO_TODO_TXT)
                    task_list = get_list_deduplicated(working_list=task_list)
                    task_list.remove(today_and_past_task)
                    task_list.append(line_hashtaged)
                    write_list_to_f(f=MEMO_TODO_TXT, working_list=task_list, mode="w", line_feed_mode=0)
                # print(rf"{today_task} {today_task.split(':')[:2]}")
            pk_print("오늘도 모든 미션을 수행하셨습니다. 수고하셨습니다")
            # speak("오늘도 모든 미션을 수행하셨습니다. 수고하셨습니다")
            pk_sleep(seconds=1)
        except KeyboardInterrupt:
            pk_print("프로그램이 사용자에 의해 종료되었습니다.")
            break
        except Exception as e:
            pk_print(f"오류가 발생했습니다: {e}", print_color='red')
            pk_sleep(seconds=60)  # 오류 발생 시 1분 후 재시도


def open_pnx_by_ext(pnx):
    # TBD : tab 으로 뭘로 열지 설정하도록 하는게 좋은 것 같다.
    from pkg_py.pk_colorful_cli_util import pk_print
    import os
    # x = get_x(pnx).replace('.', '')
    x = os.path.splitext(pnx)[1].lower().replace('.', '')
    text_editor = None
    ext_to_program = None
    if get_os_n() == 'windows':
        # ext_to_program = get_pk_input_via_tab(message="ext_to_program=", tab_completer_iterable=['xc', 'nx', 'no'])
        ext_to_program = {
            '': ('explorer.exe', 'directory, opening in explorer'),
            'txt': ('explorer.exe', 'text file, opening in explorer'),
            'csv': ('explorer.exe', 'csv file, opening in excel'),
            'xlsx': ('explorer.exe', 'excel file, opening in excel'),
            'xlsm': ('explorer.exe', 'excel file, opening in excel'),
            'xls': ('explorer.exe', 'excel file, opening in excel'),

            # Video files
            'mp4': ('explorer.exe', 'video file, opening in default player'),
            'avi': ('explorer.exe', 'video file, opening in default player'),
            'mkv': ('explorer.exe', 'video file, opening in default player'),
            'mov': ('explorer.exe', 'video file, opening in default player'),
            'wmv': ('explorer.exe', 'video file, opening in default player'),
            'flv': ('explorer.exe', 'video file, opening in default player'),
            'webm': ('explorer.exe', 'video file, opening in default player'),
        }
    program, description = ext_to_program.get(x, (None, None))
    if program:
        text_editor = program
        pnx = get_pnx_windows_style(pnx=pnx)
        pk_print(f"open_pnx_by_ext: {pnx} is a {description}", print_color='blue')
    cmd = f'{text_editor} "{pnx}" '
    cmd_to_os(cmd=cmd, mode='a')
    # else:
    #     if x == '':  # d 인 경우
    #         text_editor = 'explorer.exe'
    #     elif x == 'txt':
    #         text_editor = 'gedit' # nvim, nano, vim, code
    #     # elif x == 'csv':
    #     #     text_editor = 'explorer.exe'
    #     # elif x == 'xlsx':
    #     #     text_editor = 'explorer.exe'
    #     # elif x == 'xls':
    #     #     text_editor = 'explorer.exe'
    #     pnx = get_pnx_unix_style(pnx=pnx)


def get_pnx_os_style(pnx):
    if is_os_wsl_linux():
        pnx = get_pnx_wsl_unix_style(pnx=pnx)
        return pnx
    if is_os_windows():
        pnx = get_pnx_windows_style(pnx=pnx)
        return pnx
    else:
        pnx = get_pnx_unix_style(pnx=pnx)
        return pnx


def get_result_tuple_contained_f_and_status(d):
    import os
    from pkg_py.pk_colorful_cli_util import pk_print
    d = get_pnx_os_style(d)
    if is_d(d):
        result_tuple = {}
        for root, _, f_nx_list in os.walk(d):
            for f_nx in f_nx_list:
                f = os.path.join(root, f_nx)
                try:
                    if os.path.exists(f):
                        result_tuple[f] = os.path.getmtime(f)
                        # pk_print(f'''result_tuple[f]={result_tuple[f]}  {'%%%FOO%%%' if LTA else ''}''',print_color="blue")
                    else:
                        pk_print(f"f not found: {f}", print_color='red')
                except FileNotFoundError:
                    pk_print(f"Error accessing file: {f}", print_color='red')
        return result_tuple
    return {}


# def get_f_changed_list_from_d_interested_list(d_interested_list, monitoring_interval=0.2, time_limit=None, change_cnt_limit=None):
#     import time
#     from pkg_py.pk_colorful_cli_util import pk_print
#     from pkg_py.pk_core_constants import DOWNLOADS
#
#     d_interested_list = [get_pnx_os_style(d) for d in d_interested_list]
#
#     # Initialize the monitored file statuses
#     monitored_status_set = {}
#
#     for index,  d in enumerate(d_interested_list):
#         monitored_status_set.update(get_result_tuple_contained_f_and_status(d))
#
#     f_change_level = 0
#     start_time = time.time() if time_limit is not None else None
#     f_changed_list = []
#
#     pk_print(rf"[DETECT F_CHANGED LOOP STATED] monitoring_interval={monitoring_interval} len(d_interested_list)={len(d_interested_list)} ", print_color='blue')
#
#     while 1:
#         current_status_set = {}
#
#         for d in d_interested_list:
#             current_status_set.update(get_result_tuple_contained_f_and_status(d))
#
#         f_previous_set = set(monitored_status_set.keys())
#         f_current_set = set(current_status_set.keys())
#
#         if len(f_previous_set) != len(f_current_set):
#             pk_print(f'''len(f_previous_set)={len(f_previous_set)} len(f_current_set)={len(f_current_set)}  {'%%%FOO%%%' if LTA else ''}''', print_color="blue")
#             f_change_level += 1
#
#             for d in d_interested_list:
#                 print(rf"d={d}")
#
#             f_created_list = f_current_set - f_previous_set
#             for f_created in f_created_list:
#                 pk_print(f"f_created={f_created}")
#                 f_changed_list.append(f_created)
#
#             f_deleted_list = f_previous_set - f_current_set
#             for f_deleted in f_deleted_list:
#                 pk_print(f"f_deleted={f_deleted}")
#                 f_changed_list.append(f_deleted)
#
#             for f_modified in f_previous_set & f_current_set:
#                 if monitored_status_set[f_modified] != current_status_set[f_modified]:
#                     pk_print(f"f_modified={f_modified}")
#                     f_changed_list.append(f_modified)
#
#             pk_print(f'''f_changed_list={f_changed_list}  {'%%%FOO%%%' if LTA else ''}''')
#
#         monitored_status_set = current_status_set
#         sleep(seconds=monitoring_interval)
#
#         if change_cnt_limit is not None and f_change_level >= change_cnt_limit:
#             return f_changed_list
#
#         if time_limit is not None and time.time() - start_time > time_limit:
#             return f_changed_list

def get_str_replaced_from_str_to_str_new(item_str, from_str, to_str):
    from pkg_py.pk_colorful_cli_util import pk_print
    pk_print(f'''item_str="{item_str}"''')
    pk_print(f'''from_str="{from_str}"''')
    pk_print(f'''to_str="{to_str}"''')
    if not isinstance(item_str, str):
        raise TypeError("item_str must be a string.")
    if not isinstance(from_str, str):
        raise TypeError("from_str must be a string.")
    if not isinstance(to_str, str):
        raise TypeError("to_str must be a string.")
    item_str = item_str.replace(from_str, to_str)
    pk_print(f'''item_str="{item_str}"''')
    return item_str


def move_pnx_to_pk_recycle_bin(pnx):
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    # import send2trash
    import inspect
    from pkg_py.pk_core_constants import D_PK_RECYCLE_BIN
    func_n = inspect.currentframe().f_code.co_name
    pnx = get_pnx_os_style(pnx=pnx)
    if does_pnx_exist(pnx):
        try:
            # send2trash.send2trash(pnx)
            # shutil.move(pnx, D_PK_RECYCLE_BIN)
            ensure_pnx_made(D_PK_RECYCLE_BIN, mode='d')
            move_pnx(pnx=pnx, d_dst=D_PK_RECYCLE_BIN)
        except:
            pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
    if does_pnx_exist(pnx):
        pk_print(f'''{func_n}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
    if not does_pnx_exist(pnx):
        pk_print(f'''{func_n}  {'%%%FOO%%%' if LTA else ''}''', print_color='green')


def move_f_video_seg_and_image(d_working, d_dst_extension_to_move=None):
    from pkg_py.pk_colorful_cli_util import pk_print
    import os
    import shutil

    # 대상 d 생성
    for _, d_n in d_dst_extension_to_move.items():
        d = os.path.join(d_working, d_n)
        if not os.path.exists(d):
            os.makedirs(d)

    # d 내 f 탐색 및 이동
    for f_nx in os.listdir(d_working):
        f = os.path.join(d_working, f_nx)

        # f만 처리
        if is_f(f):
            # f_ext = f_nx.split('.')[-1].lower()  # 확장자를 소문자로 변환

            d_n = None
            for key, dir_name in d_dst_extension_to_move.items():  # todo : dir_name 를 d_n 으로 변경 후 정상적인지 테스트 해보기
                if key in f_nx.lower():  # f 이름 또는 확장자에 키가 포함되면 매핑
                    d_n = dir_name
                    break

            if d_n:
                d_dst = os.path.join(d_working, d_n)
                f_dst = os.path.join(d_dst, f_nx)

                # 동일한 f이 있을 경우 이름 변경
                base, ext = os.path.splitext(f_nx)
                counter = 1
                while os.path.exists(f_dst):
                    f_dst = os.path.join(d_dst, f"{base}_{counter}{ext}")
                    counter += 1

                # f 이동
                try:
                    shutil.move(f, f_dst)
                    pk_print(f"f 이동 {f_dst}", print_color='green')
                except Exception as e:
                    pk_print(f"f 이동 {f_dst}. 오류: {e}", print_color='red')


def run_hot_reload_to_x():
    from pkg_py.pk_core_constants import D_DOWNLOADS

    # make
    # make_version_new(via_f_txt=True, debug_mode=True)

    # define
    dst = rf"{D_DOWNLOADS}\[]\[Moozzi2] Eighty-Six [ 4K Ver. ] - TV"
    dst = get_pnx_unix_style(pnx=dst)
    src = rf"{dst}\pk_system_organize_video_seg_and_image_here.cmd"
    pnx_new = get_pnx_new(d_working=dst, pnx=src)
    pnx_new = get_pnx_windows_style(pnx=pnx_new)

    # del
    if does_pnx_exist(pnx=pnx_new):
        cmd_to_os(cmd=rf'echo y | del /f "{pnx_new}"')
        # pk_sleep(milliseconds=500)

    # copy
    copy_pnx_with_overwrite(pnx=src, dst=dst)

    # cd
    pk_chdir(dst)

    # call
    try:
        cmd_to_os(cmd=rf'call "{pnx_new}"', mode='a')  # todo : ?
        # lines=cmd_to_os_v_1_0_1(cmd=rf'call "{pnx_new}/"')
        # cmd_to_os_like_person(cmd=rf'"{pnx_new}"')
    except:
        pass


def cmd_f_in_cmd_exe_like_person(cmd_prefix, f):
    from pkg_py.pk_core_constants import D_PROJECT
    # make
    # make_version_new(via_f_txt=True, debug_mode=True)

    # src
    f = get_pnx_unix_style(pnx=f)

    dst = get_p(f)
    dst = get_pnx_unix_style(pnx=dst)

    # pnx_new
    pnx_new = get_pnx_new(d_working=dst, pnx=f)
    pnx_new = get_pnx_windows_style(pnx=pnx_new)

    # kill
    # kill_process_via_taskkill(process_name='cmd.exe')
    # kill_process_via_wmic(process_img_n='cmd.exe')
    window_title_seg = f
    window_title_seg = get_pnx_windows_style(window_title_seg)
    kill_window_like_person(window_title_seg=window_title_seg)

    # run
    try:
        cmd_to_os_like_person(cmd=rf'"{D_PROJECT}\.venv\Scripts\activate.cmd"')
        cmd_to_os_like_person(cmd=rf'{cmd_prefix} "{pnx_new}"')
    except:
        pass

    # move (to pycharm64.exe)
    move_window_to_front_of_pycharm()


def kill_window_like_person(window_title_seg):
    from pkg_py.pk_colorful_cli_util import pk_print
    pk_print(f'''window_title_seg="{window_title_seg}"''')
    pk_print(f'''window_title_seg == is_front_window_title(window_title_seg=window_title_seg)="{window_title_seg == is_front_window_title(window_title_seg=window_title_seg)}"''')
    while 1:
        if not is_front_window_title(window_title_seg=window_title_seg):
            ensure_window_to_front(window_title_seg=window_title_seg)
        if is_front_window_title(window_title_seg=window_title_seg):
            pk_press("alt", "f4")
        if not is_window_opened(window_title_seg=window_title_seg):
            pk_print(f'''  {'%%%FOO%%%' if LTA else ''}" {window_title_seg} 창를 닫았습니다''', print_color='blue')
            return


def is_mic_device_connected():
    import pyaudio
    audio = pyaudio.PyAudio()
    device_count = audio.get_device_count()
    mic_found = False
    for i in range(device_count):
        device_info = audio.get_device_info_by_index(i)
        # 장치가 입력 장치인지 확인
        if device_info.get("maxInputChannels") > 0:
            mic_found = True
            break
    audio.terminate()
    if mic_found:
        return 1
    else:
        return 0


def get_str_today_day_info():
    yyyy = get_time_as_('%Y')
    MM = get_time_as_('%m')
    dd = get_time_as_('%d')
    HH = get_time_as_('%H')
    mm = get_time_as_('%M')
    # week_name=get_weekday_as_korean()
    # return f'대한민국 표준시 기준, 현재시각 {int(yyyy)}년 {int(MM)}월 {int(dd)}일 {week_name}요일 {int(HH)}시 {int(mm)}분'
    week_name = get_weekday_as_english()
    # return f'Based on Korea Standard Time, the current time is {int(yyyy)} year {int(MM)} month {int(dd)} day, {week_name}, {int(HH)} hour {int(mm)} minute'
    # return f'the current time is {int(yyyy)} year {int(MM)} month {int(dd)} day, {week_name}, {int(HH)} hour {int(mm)} minute'
    return f'{int(yyyy)} {int(MM)} {int(dd)} {week_name} {int(HH)} {int(mm)}'


# def print_pids_via_tasklist():
#     import inspect
#     func_n = inspect.currentframe().f_code.co_name
#     pids = get_pids()
#     print_iterable_as_vertical(item_iterable=pids)

# def print_pids():
#     pids = get_pids()
#     print_iterable_as_vertical(item_iterable=pids, item_iterable_n='pids')

def print_highlighted(txt_whole, highlight_config_dict):
    from colorama import init as pk_colorama_init
    pk_colorama_init(autoreset=True)
    print(get_txt_highlighted(txt_whole, highlight_config_dict))


# def get_txt_highlighted_v1(txt_whole, highlight_config_dict):
#     import re
#     from colorama import init as pk_colorama_init
#     pk_colorama_init(autoreset=True)
#     ansi_color_map_dict = {
#         "black": "\033[30m",
#         'red': "\033[31m",
#         "green": "\033[32m",
#         "yellow": "\033[33m",
#         "blue": "\033[34m",
#         "magenta": "\033[35m",
#         "cyan": "\033[36m",
#         "white": "\033[37m",
#         "bright_black": "\033[90m", "grey": "\033[90m",
#         "bright_red": "\033[91m",
#         "bright_green": "\033[92m",
#         "bright_yellow": "\033[93m",
#         "bright_blue": "\033[94m",
#         "bright_magenta": "\033[95m",
#         "bright_cyan": "\033[96m",
#         "bright_white": "\033[97m",
#     }
#     reset_code = "\033[0m"
#     for color_nick_name, keyword_list in highlight_config_dict.items():
#         color_code = ansi_color_map_dict.get(color_nick_name, ansi_color_map_dict['bright_black'])
#         for keyword in keyword_list:
#             pattern = re.escape(keyword)
#             txt_whole = re.sub(
#                 pattern,
#                 lambda match: f"{color_code}{match.group(0)}{reset_code}",
#                 txt_whole
#             )
#     return txt_whole


def get_txt_highlighted(txt_whole, config_highlight_dict):
    import re
    # mkr.
    # from colorama import init as pk_colorama_init
    # pk_colorama_init(autoreset=True)
    ansi_color_map_dict = {
        "black": "\033[30m",
        'red': "\033[31m",
        "green": "\033[32m",
        "yellow": "\033[33m",
        "blue": "\033[34m",
        "magenta": "\033[35m",
        "cyan": "\033[36m",
        "white": "\033[37m",
        "grey": "\033[90m",
        "bright_black": "\033[90m",
        "bright_red": "\033[91m",
        "bright_green": "\033[92m",
        "bright_yellow": "\033[93m",
        "bright_blue": "\033[94m",
        "bright_magenta": "\033[95m",
        "bright_cyan": "\033[96m",
        "bright_white": "\033[97m",
    }
    reset_code = "\033[0m"
    # 색칠할 영역 추출 (위치 정보 포함)
    highlight_spans = []
    for color, keywords in config_highlight_dict.items():
        color_code = ansi_color_map_dict.get(color, ansi_color_map_dict["grey"])
        for kw in keywords:
            for match in re.finditer(re.escape(kw), txt_whole):
                start, end = match.span()
                highlight_spans.append((start, end, color_code))
    # 겹치는 영역 remove: 앞쪽 우선, 긴 단어 우선 적용
    highlight_spans.sort(key=lambda x: (x[0], -(x[1] - x[0])))
    filtered = []
    last_end = -1
    for start, end, color_code in highlight_spans:
        if start >= last_end:
            filtered.append((start, end, color_code))
            last_end = end
    # 색상 적용
    result = []
    last_idx = 0
    for start, end, color_code in filtered:
        result.append(txt_whole[last_idx:start])
        result.append(f"{color_code}{txt_whole[start:end]}{reset_code}")
        last_idx = end
    result.append(txt_whole[last_idx:])
    return ''.join(result)


def get_list_leaved_element_pattern(items, pattern):
    import re
    if isinstance(pattern, str):
        pattern = re.compile(pattern)
    matches = []
    for line in items:
        if isinstance(line, bytes):
            try:
                line = line.decode('utf-8')  # 기본 UTF-8 시도
            except UnicodeDecodeError:
                line = line.decode('cp949')  # UTF-8 실패 시 CP949로 디코딩
        found = pattern.findall(line)
        if found:
            matches.extend(found)
    return matches


def organize_tree(d_working, with_walking):
    # src=rf"{USERPROFILE}\Downloads" # __init__.py   init_.py 가 되어 문제가 되었다.
    mode = 'f'
    gather_f_useless_at_tree(d_working=d_working)
    rename_pnx_list_at_d(d_working=d_working, mode=mode, with_walking=with_walking)
    classify_pnx_list_at_tree(d_working=d_working, mode=mode, with_walking=with_walking)
    rename_pnx_list_at_d(d_working=d_working, mode=mode, with_walking=with_walking)
    gather_empty_d(d_working=d_working)
    # empty_recycle_bin() # 비우기

    mode = 'd'
    gather_f_useless_at_tree(d_working=d_working)
    rename_pnx_list_at_d(d_working=d_working, mode=mode, with_walking=with_walking)
    classify_pnx_list_at_tree(d_working=d_working, mode=mode, with_walking=with_walking)
    rename_pnx_list_at_d(d_working=d_working, mode=mode, with_walking=with_walking)
    gather_empty_d(d_working=d_working)
    # empty_recycle_bin()  # 비우기


def does_pnx_that_have_str_unique_in_tree(str_unique, str_positive, tree_pnx=None):
    import os
    from pkg_py.pk_colorful_cli_util import pk_print
    if tree_pnx is None:
        f_list = os.listdir()
    else:
        f_list = []
        for root, d_nx_list, f_nx_list in os.walk(tree_pnx):
            for f_nx in f_nx_list:
                item_pnx = os.path.abspath(os.path.join(root, f_nx))
                f_list.append(item_pnx)

    for f in f_list:
        if is_pattern_in_prompt(f, str_unique):
            pk_print(str_positive, print_color='blue')
            return 1
    else:
        return 0


def download_youtube_thumbnail(youtube_video_url, f_dst_jpg):
    import requests
    youtube_video_id = youtube_video_url.split('v=')[-1].split('&')[0]
    # 최대 해상도 썸네일 URL
    thumbnail_url = f'https://img.youtube.com/vi/{youtube_video_id}/maxresdefault.jpg'
    # 이미지 다운로드 및 저장
    try:
        response = requests.get(thumbnail_url, stream=True)
        response.raise_for_status()
        with open(file=f_dst_jpg, mode='wb') as f:
            for chunk in response.iter_content(1024):
                f.write(chunk)
        print(f"downloaded : {f_dst_jpg}")
    except requests.exceptions.RequestException as e:
        print(f"썸네일 다운로드 실패: {e}")


def dynamic_image_download(thumbnail_urls, dst: str, channel_name: str, retry_limit: int = 3, delay: int = 1):
    import os
    import tqdm
    import requests
    os.makedirs(dst, exist_ok=True)
    try:
        if not thumbnail_urls:
            print(f"No thumbnails found.")
            return

        print(f"Collected {len(thumbnail_urls)} thumbnails.")

        # 프로그래스 바 설정
        with tqdm(total=len(thumbnail_urls), desc="Downloading Thumbnails", unit="file") as pbar:
            for index, url in enumerate(thumbnail_urls, start=1):
                retries = 0
                success = False

                while retries < retry_limit and not success:
                    try:
                        # 이미지 요청
                        response = requests.get(url, stream=True, timeout=10)
                        response.raise_for_status()

                        # 저장 f 경로 설정
                        f = os.path.join(dst, f"{channel_name}_thumbnail_{index}.jpg")

                        # 이미지 저장
                        with open(file=f, mode="wb") as file:
                            for chunk in response.iter_content(1024):
                                file.write(chunk)

                        # f 검증
                        from PIL import Image, ImageFont, ImageDraw, ImageFilter
                        with Image.open(f) as img:
                            img.verify()

                        if os.path.getsize(f) > 0:
                            print(f"Downloaded: {f}")
                            success = True
                        else:
                            print(f"Failed: {f} (File is empty or does not exist)")

                    except requests.exceptions.HTTPError as e:
                        if e.response.status_code == 404:
                            print(f"404 Not Found: {url}")
                            break  # 404 에러는 재시도하지 않음
                        else:
                            print(f"HTTP Error {e.response.status_code}: {url}")
                    except Exception as e:
                        print(f"Error downloading {url}: {str(e)}")

                    retries += 1
                    if not success and retries < retry_limit:
                        print(f"Retrying ({retries}/{retry_limit}) for {url}")
                        pk_sleep(seconds=delay)  # 지연 시간 추가

                # 진행 상황 업데이트
                pbar.update(1)

                # 모든 재시도가 실패한 경우 로그 출력
                if not success:
                    print(f"Failed to download after {retry_limit} attempts: {url}")

    except Exception as e:
        print(f"Error during Selenium image collection or download: {e}")


def get_channel_n(channel_url, driver=None):
    from selenium.webdriver.common.by import By
    if driver is None:
        driver = get_driver_selenium(browser_debug_mode=True)

    driver.get(channel_url)
    pk_sleep(seconds=2)  # 페이지 로드 대기

    channel_name = driver.find_element(By.CSS_SELECTOR, "meta[itemprop='name']").get_attribute("content")
    channel_name = get_pnx_unix_style(channel_name)
    return channel_name


def download_youtube_thumbnails_from_youtube_channel_main_page_url(youtube_channel_main_page_url):
    import os
    from pkg_py.pk_core_constants import D_WORKING_EXTERNAL
    youtube_video_url_list = get_videos_urls_from_youtube_channel_main_page(youtube_channel_main_page_url=youtube_channel_main_page_url)
    channel_n = get_channel_n(channel_url=youtube_channel_main_page_url)
    d_dst = rf'{D_WORKING_EXTERNAL}/thumbnails/{channel_n}'
    # dst = get_pnx_unix_style(pnx=dst)
    d_dst = get_pnx_os_style(pnx=d_dst)
    ensure_pnx_made(d_dst, mode="d")
    cnt = 0
    for youtube_video_url in youtube_video_url_list:
        cnt += 1
        f_jpg = os.path.join(d_dst, f"{channel_n}_thumbnail_maxresdefault_{cnt}.jpg")
        download_youtube_thumbnail(youtube_video_url=youtube_video_url, f_dst_jpg=f_jpg)


# [tool]
def fix_f_n_weired(working_d, f_nx_from='init_.py', f_nx_to='__init__.py'):
    import os
    """
    주어진 디렉터리 내의 모든 'init_.py' f을 '__init__.py'로 이름 변경합니다.
    """
    for root, d_nx_list, f_nx_list in os.walk(working_d):
        for f_nx in f_nx_list:
            if f_nx == f_nx_from:
                old_f = os.path.join(root, f_nx)
                new_f = os.path.join(root, f_nx_to)
                try:
                    os.rename(old_f, new_f)
                    print(f"Renamed: {old_f} ->> {new_f}")
                except Exception as e:
                    print(f"Error renaming {old_f}: {e}")


# def get_list_converted_from_byte_list_to_str_list(item_byte_list, encoding=Encoding.UTF8.value):
#     return [item.decode(encoding) for item in item_byte_list]

def get_list_converted_from_byte_list_to_str_list(item_byte_list, encoding=None):
    """
    기본적으로 utf-8로 디코딩을 시도하되,
    실패할 경우 cp949로 재시도하고,
    둘 다 실패하면 대체문자로 표시합니다.
    """
    from pkg_py.pk_core_constants import Encoding
    encoding = encoding or Encoding.UTF8
    result = []
    for item in item_byte_list:
        try:
            # 1) 우선 utf-8 디코딩
            decoded = item.decode(encoding)
        except UnicodeDecodeError:
            try:
                # 2) 실패하면 cp949로 재시도
                decoded = item.decode('cp949')
            except UnicodeDecodeError:
                # 3) 그래도 안 되면 대체문자 처리
                decoded = item.decode('utf-8', errors='replace')
        result.append(decoded)
    return result


def get_list_added_suffix_each_element(working_list, suffix):
    return [f"{line}{suffix}" for line in working_list]


def copy_pnx_to_wsl(f, dst="~/Downloads/"):
    f = get_pnx_wsl_unix_style(f)
    cmd_to_os(cmd=rf'wsl sudo cp -r {f} {dst}')


def search_f_list_contains_search_key(target, search_key):
    import os
    # todo : chore : not working for encoding problem
    """
    특정 경로를 순회하며 f 내용을 검색하여 문자열이 포함된 f명을 출력합니다.  

    :param target_path: 검색할 d
    :param search_string: 찾고자 하는 문자열
    """
    for root, dirs, f_nx_list in os.walk(target):
        for f_nx in f_nx_list:
            f = os.path.join(root, f_nx)
            try:
                # f 바이너리 모드로 열기
                with open(file=f, mode='rb') as f_tmp:
                    raw_data = f_tmp.read()

                import chardet
                detected_encoding = chardet.detect(raw_data)['encoding']

                # 인코딩이 감지되지 않으면 utf-8로 시도
                if detected_encoding is None:
                    # detected_encoding=Encoding.UTF8
                    detected_encoding = 'cp949'

                # 감지된 인코딩으로 텍스트 읽기
                text_content = raw_data.decode(detected_encoding)

                # 특정 문자열 검색
                if search_key in text_content:
                    print(f"문자열 '{search_key}'이 포함된 f: {f}")

            except UnicodeDecodeError as e:
                print(f"f을 디코딩할 수 없습니다: {f}, 이유: {e}")
            except Exception as e:
                print(f"f을 읽을 수 없습니다: {f}, 이유: {e}")


def get_list_from_set(working_set):
    return list(working_set)


def get_next_element_from_set(item_set):
    """
    ipdb 와 함께 디버깅용으로 편함.
    """
    from pkg_py.pk_colorful_cli_util import pk_print
    # 반복자 생성
    if not hasattr(get_next_element_from_set, "iterator"):
        get_next_element_from_set.iterator = iter(item_set)

    try:
        # 다음 요소 반환
        return next(get_next_element_from_set.iterator)
    except StopIteration:
        # 끝에 도달했을 때 메시지 출력
        pk_print(working_str="다 돌았습니다")
        # 반복자를 새로 생성
        get_next_element_from_set.iterator = iter(item_set)
        return next(get_next_element_from_set.iterator)


def is_two_lists_equal(list1, list2):
    """
    두 리스트의 요소들이 동일한지 확인
    """
    if len(list1) != len(list2):
        return 0
    for i in range(len(list1)):
        if list1[i] != list2[i]:
            return 0
    return 1


def aes_encrypt(key, plaintext):
    from cryptography.hazmat.backends import default_backend
    from cryptography.hazmat.primitives import padding
    from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes

    """AES 암호화: 대칭키암호화 ECB 모드, 보안취약"""
    # 키 생성
    cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())
    encryptor = cipher.encryptor()

    # 패딩 추가
    padder = padding.PKCS7(128).padder()
    padded_data = padder.update(plaintext) + padder.finalize()

    # 암호화 수행
    ciphertext = encryptor.update(padded_data) + encryptor.finalize()
    return ciphertext


def aes_decrypt(key, ciphertext):
    from cryptography.hazmat.backends import default_backend
    from cryptography.hazmat.primitives import padding
    from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes

    """AES 복호화"""
    # 키 생성
    cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())
    decryptor = cipher.decryptor()

    # 복호화 수행
    decrypted_data = decryptor.update(ciphertext) + decryptor.finalize()

    # 언패딩
    unpadder = padding.PKCS7(128).unpadder()
    plaintext = unpadder.update(decrypted_data) + unpadder.finalize()
    return plaintext


def encode_as_lzw_algorizm(txt_plain: str):
    import zlib
    r"""
    LZW 알고리즘을 사용하여 문자열을 압축하는 함수
        def compress_string(original_strin
        from cryptography.hazmat.backends import default_backend
        import random
        import random
    import secrets
    import string
    from datetime import timedelta
    import re
    import secrets
    import string
    import zlib
    from cryptography.hazmat.primitives import padding
    from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
        g):
             return compressed_string

    LZW 알고리즘을 사용하여 압축된 문자열을 해제하는 함수
        def decompress_string(compressed_strin
        from cryptography.hazmat.backends import default_backend
        import random
        import random
    import secrets
    import string
    from datetime import timedelta
    import re
    import secrets
    import string
    import zlib
    from cryptography.hazmat.primitives import padding
    from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
        g):
             return original_string

    문자열 압축
        current_directory_state = compress_string(current_directory_state)

    문자열 압축해제
        current_directory_state = decompress_string(current_directory_state)
    """
    return zlib.compress(txt_plain.encode('utf-8'))


def decode_as_lzw_algorizm(encrypted_text):
    import zlib

    return zlib.decompress(encrypted_text.decode('utf-8'))


def convent_bytes_to_str(target: bytes):
    return target.decode('utf-8')


def convent_str_to_bytes(target: str):
    return target.encode('utf-8')


def get_random_alphabet():
    import random
    import string

    # pk_print(f"{inspect.currentframe().f_code.co_name}()")
    return random.choice(string.ascii_letters)


def get_random_bytes():
    import secrets
    return secrets.token_bytes(16)  # 16바이트의 보안적으로 안전한 난수 생성


def get_random_int():
    import secrets
    # pk_print(f"{inspect.currentframe().f_code.co_name}()")
    return secrets.randbelow(100)  # 0부터 99까지의 난수 생성


def get_random_korean_name():
    import secrets
    return secrets.choice([
        "김민지", "이준호", "박지영", "정성민", "홍길동", "김지현", "박민수", "이서연", "정현우", "한지원", "박정훈"
    ])


def get_random_korean_phone_number():
    import secrets
    return secrets.choice([
        "010-1234-5678", "02-9876-5432", "031-111-2222", "051-555-7777", "070-1234-5678",
        # "+1-123-456-7890", "+44-20-1234-5678", "+81-3-1234-5678", "+86-10-1234-5678", "+61-2-1234-5678"
    ])


def get_random_korean_e_mail():
    import secrets
    return secrets.choice([
        'john.doe@gmail.com', 'jane.smith@yahoo.com', 'david.wilson@hotmail.com', 'emily.johnson@outlook.com', 'michael.brown@aol.com', 'sarah.jones@icloud.com', 'robert.davis@protonmail.com', 'lisa.thomas@zoho.com', 'william.martin@yandex.com', 'jessica.anderson@mail.com',
        'matthew.harris@live.com', 'laura.miller@gmx.com', 'james.jackson@fastmail.com', 'olivia.rodriguez@inbox.com',
        'benjamin.carter@ymail.com', 'mia.walker@rocketmail.com', 'ethan.white@tutanota.com', 'ava.hall@rediffmail.com', 'alexander.lee@mailinator.com', 'sophia.green@protonmail.ch', 'jacob.adams@yandex.ru', 'emma.baker@outlook.com', 'daniel.cook@zoho.eu', 'madison.lopez@google.com',
        'logan.morgan@yahoo.co.uk', 'chloe.roberts@icloud.com', 'jayden.kelly@mail.com', 'grace.bennett@fastmail.fm',
        'samuel.rogers@protonmail.com', 'harper.edwards@outlook.com'
    ])


def get_random_address():
    pass


def generate_random_address_usa():
    import random
    street_number = random.randint(1, 9999)
    street_name = random.choice(['Main Street', 'Park Avenue', 'Oak Lane', 'Maple Avenue', 'Cedar Road'])
    city = random.choice(['New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix'])
    state = random.choice(['California', 'Texas', 'Florida', 'New York', 'Illinois'])
    zip_code = random.randint(10000, 99999)
    return f"{street_number} {street_name}, {city}, {state} {zip_code}"


def generate_random_address_kor():
    import random

    street = random.choice(['서울특별시', '부산광역시', '대구광역시', '인천광역시', '광주광역시', '대전광역시', '울산광역시', '세종특별자치시', '경기도', '강원도', '충청북도', '충청남도', '전라북도', '전라남도', '경상북도', '경상남도', '제주특별자치도'])
    city = random.choice(['서초구', '강남구', '송파구', '강동구', '관악구', '강서구', '영등포구', '구로구', '금천구', '양천구', '마포구', '서대문구', '은평구', '동작구', '광진구', '성동구', '중랑구', '동대문구', '성북구', '강북구', '도봉구', '노원구', '중구', '종로구'])
    dong = random.choice(['반포동', '삼성동', '청담동', '논현동', '압구정동', '서초동', '잠실동', '천호동', '신림동', '구로동', '영등포동', '신도림동', '여의도동', '목동', '신정동', '신촌동', '홍대입구동', '이태원동', '성수동', '왕십리동'])
    street_number = random.randint(1, 200)
    building_name = random.choice(['아파트', '빌라', '주택', '오피스텔'])
    return f"{street} {city} {dong} {street_number}-{random.randint(1, 20)}, {building_name}"
    # return random.choice([generate_random_address_kor() for _ in range(100)])


def get_random_id(length_limit: int):
    import random
    import string

    characters = string.ascii_letters + string.digits
    return ''.join(random.choice(characters) for _ in range(length_limit))


def get_random_pw(length_limit: int):
    import random
    import string
    characters = string.ascii_letters + string.digits
    return ''.join(random.choice(characters) for _ in range(length_limit))


def get_random_korean(length_limit: int):
    import random
    import string

    result = ''
    for _ in range(length_limit):
        result += random.choice(string.printable)
    return result


def get_random_date():
    import random
    from datetime import timedelta
    from datetime import datetime

    # 현재 날짜 가져오기
    current_date = datetime.now()
    # 시작 날짜 설정 (sample: 1970년 1월 1일)
    start_date = datetime(1970, 1, 1)
    # 현재 날짜와 시작 날짜 사이의 일수 계산
    days_diff = (current_date - start_date).days
    # 랜덤하게 선택된 일수 더하기
    random_date = start_date + timedelta(days=random.randint(0, days_diff))
    # "yyyy-yy-yy" 형식으로 포맷팅
    formatted_date = random_date.strftime("%Y-%y-%y")
    return formatted_date


def get_random_special_character(length_limit: int):
    import random
    import string

    result = ''
    for _ in range(length_limit):
        result += random.choice(string.printable)
    return


def get_random_user_trial_input_case():
    import random
    import string

    options = [
        get_random_korean_name(),
        get_random_korean_phone_number(),
        get_random_id(30),
        get_random_special_character(30),
        string.punctuation,
        get_random_special_character(30),
        # get_random_hex(),
        # get_random_bytes(),
        get_random_date(),
        "None",
        None,
        ""
    ]
    return random.choice(options)


def get_random_hex():
    import secrets

    return secrets.token_hex(16)  # 16바이트의 난수를 16진수 문자열로 생성


def get_random_urlsafe():
    import secrets

    return secrets.token_urlsafe(16)  # 16바이트의 난수를 URL-safe 문자열로 생성


def is_sql_injection_safe_simply(data: str):
    import re

    sql_pattern = r"(SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER|DROP|TRUNCATE|GRANT|REVOKE)"
    match = re.search(sql_pattern, data, re.IGNORECASE)
    if match:
        return 0
    return 1


def print_system_environment_variables():
    import sys
    """print 시스템 환경변수 path"""
    from os.path import dirname
    sys.path.insert(0, dirname)
    sys.path.append(r'C:\Python312\Lib\site-packages')
    for i in sys.path:
        print(i)


def get_minuites_from_(seconds):  # 큰단위로 단위변환 시 숫자는 작아지니 숫자가 작아지도록 약속된 숫자를 곱하면 된다. # seconds ->> min  인 경우 큰단위로 변환되고 있고 약속된 숫자는 60 이다. 작은 숫자를 생성 위해서 1/60 을 곱한다.
    return round(seconds / 60, 2)


def get_minuites_and_remaining_secs(seconds):  # 큰단위로 단위변환 시 숫자는 작아지니 숫자가 작아지도록 약속된 숫자를 곱하면 된다.
    mins = seconds // 60
    secs_remaining = seconds % 60
    return mins, secs_remaining


def get_value_splited_integer_part_and_decimal_part_from_(value):  # 큰단위로 단위변환 시 숫자는 작아지니 숫자가 작아지도록 약속된 숫자를 곱하면 된다.
    import math
    decimal_part, integer_part = math.modf(value)
    decimal_part = abs(decimal_part)  # 음수 부호 remove
    return [integer_part, decimal_part]


def analize_tree(d_src):
    from pkg_py.pk_colorful_cli_util import pk_print
    # todo : print_size : 드래그한상태에서 특정단축키를 누르면, chatgpt 에게 질문을 하는 프로세스
    import os
    largest_f = None
    largest_size = 0
    for root, d_nx_list, f_nx_list in os.walk(d_src):
        for f_nx in f_nx_list:
            f = os.path.join(root, f_nx)
            try:
                file_size = os.path.getsize(f)  # f 크기 확인
                if file_size > largest_size:
                    largest_size = file_size
                    largest_f = f
            except Exception as e:
                print(f"f 크기를 확인할 수 없습니다: {f}. 오류: {e}")
    if largest_f:
        pk_print(f'''largest_f={largest_f}''')
    else:
        pk_print(working_str="d에 f이 없거나 f 크기를 확인할 수 없습니다.")


def should_i_do_cli(title, search_keyword_default=""):
    from pkg_py.pk_colorful_cli_util import pk_print
    pk_print(f'''{title}  {'%%%FOO%%%' if LTA else ''}''', print_color="blue")
    pk_print(f'''search_keyword_default={search_keyword_default}  {'%%%FOO%%%' if LTA else ''}''', print_color="blue")
    if search_keyword_default == "":
        txt_written = input("search_keyword:").strip()
    else:
        txt_written = search_keyword_default
    return txt_written


def should_i_search_to_google():
    # todo : ref : as gui : demerit : slow
    # import pk_core_constants
    # txt_clicked, function, txt_written = should_i_do(
    #     string=rf"can i search contents dragged to google?",
    #     btns=[pk_core_constants.POSITIVE, pk_core_constants.NEGATIVE],
    #     function=partial(ask_to_google, question=question),
    #     auto_click_negative_btn_after_seconds=30,
    #     title=f" {'%%%FOO%%%' if LTA else ''}",
    #     input_box_mode=True,
    #     input_box_text_default=question,
    # )
    # if txt_clicked == pk_core_constants.NEGATIVE:
    #     pk_print(f'''{pk_core_constants.NEGATIVE} pressed  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
    #     return
    # if txt_clicked == pk_core_constants.POSITIVE:
    #     pk_print(f'''txt_clicked={txt_clicked}  {'%%%FOO%%%' if LTA else ''}''', print_color="blue")
    #     pk_print(f'''txt_written={txt_written}  {'%%%FOO%%%' if LTA else ''}''', print_color="blue")
    #     function()

    # todo : ref : as cli
    txt_written = should_i_do_cli(
        title=rf"can i search contents dragged to google?",
        search_keyword_default="",
    )
    txt_written = txt_written.strip()
    if txt_written != "":
        ask_to_google(txt_written)


def should_i_search_to_chatGPT():
    # todo : chatGPT 4o with 임시 채팅
    txt_written = should_i_do_cli(
        title=rf"can i search contents dragged to chatGPT?",
        search_keyword_default="",
    )
    txt_written = txt_written.strip()
    if txt_written != "":
        ask_to_chatGPT(txt_written)


def print_txt_dragged_changed():
    from pkg_py.pk_colorful_cli_util import pk_print
    # todo : chore : detect is changed dragged txt
    # previous_question = None
    # while 1:
    #     question = get_txt_dragged()
    #     question = question.strip()
    #     if question != previous_question:
    #         previous_question = question
    #         question_list = question.split("\n")
    #         question_list = get_list_striped_element(working_list=question_list, mode='rstrip')
    #         for question in question_list:
    #             pk_print(f'''[question_layer] {question}  {'%%%FOO%%%' if LTA else ''}''', print_color="blue")
    #     print()
    #     print()
    #     print()
    #     print()
    #     sleep(seconds=3)
    from pynput import mouse
    class DragTracker:
        def __init__(self):
            self.drag_ing_state = False
            self.is_dragging = False
            self.start_listener()
            pk_print(working_str="track drag state.")

        def start_listener(self):
            with mouse.Listener(
                    on_click=self.on_click,
                    on_move=self.on_move,
            ) as listener:
                listener.join()

        def on_click(self, x, y, button, pressed):
            if button == mouse.Button.left:
                if pressed:
                    self.is_dragging = True
                    # print(f"드래그 시작: ({x}, {y})")
                else:
                    if self.is_dragging:
                        if self.drag_ing_state == True:
                            # print(f"드래그 종료: ({x}, {y})")
                            question = get_txt_dragged()
                            previous_question = question
                            question_list = question.split("\n")
                            question_list = get_list_striped_element(working_list=question_list, mode='rstrip')
                            for question in question_list:
                                pk_print(f'''[dragged_text_layer] {question}  {'%%%FOO%%%' if LTA else ''}''', print_color="blue")
                            print()
                            print()
                            print()
                            print()
                            pass
                            self.drag_ing_state = False
                    self.is_dragging = False

        def on_move(self, x, y):
            if self.is_dragging:
                self.drag_ing_state = True
                pass

    DragTracker()


def set_wake_up_via_schtasks(seconds):
    from pkg_py.pk_colorful_cli_util import pk_print
    from datetime import datetime, timedelta

    # 현재 시간을 기준으로 깨울 시간을 계산
    current_time_str = datetime.now().strftime("%H:%M:%S")
    wake_time = datetime.now() + timedelta(seconds=seconds)
    wake_time_str = wake_time.strftime("%H:%M:%S")
    pk_print(
        f"현재 시간: {current_time_str}, {wake_time_str} 후에 컴퓨터를 깨웁니다 {'%%%FOO%%%' if LTA else ''}",
        print_color="blue"
    )

    # 작업 예약 명령어 생성
    task_name = "WakeComputer"
    cmd = f'schtasks /create /tn "{task_name}" /tr "cmd.exe /c exit" /sc once /st {wake_time.strftime("%H:%M")} /f /it'
    pk_print(f''' {cmd}  {'%%%FOO%%%' if LTA else ''}''', print_color="blue")
    std_list = cmd_to_os(cmd=cmd)
    std_list = get_list_converted_from_byte_list_to_str_list(std_list)
    for std_str in std_list:
        pk_print(f'''[STD_OUT] {std_str}  {'%%%FOO%%%' if LTA else ''}''', print_color="blue")
    pk_print(f'''태스크 스케줄러에 깨우기 작업이 설정되었습니다.  {'%%%FOO%%%' if LTA else ''}''', print_color="blue")


def set_wake_up_next_HH_mm(HH, mm):
    from pkg_py.pk_core_constants import STAMP_DEBUG
    from pkg_py.pk_colorful_cli_util import pk_print
    """
    다음으로 오는 HH:mm 시각에 컴퓨터를 깨우도록 스케줄링합니다.
    - 이미 HH:mm이 지났다면 자동으로 다음 날 같은 시각으로 설정합니다.
    """
    from datetime import datetime, timedelta
    now = datetime.now()

    # 오늘 날짜의 HH:mm 만들기 (초는 0으로 설정)
    target_time = datetime(now.year, now.month, now.day, HH, mm, 0)

    # 이미 HH:mm이 지났다면, 다음 날로 +1일
    if target_time <= now:
        target_time += timedelta(days=1)

    # schtasks에서 "HH:MM" 포맷으로 쓰기 위해 시분만 추출
    wake_time_str = target_time.strftime("%H:%M")

    # schtasks 명령어 구성
    # /sc once 로 한 번만 exec
    # /st HH:MM 으로 exec  시각 지정
    # /f : 덮어쓰기
    # /it : 인터랙티브 모드
    task_name = "WakeComputer"
    cmd = f'schtasks /create /tn "{task_name}" /tr "cmd.exe /c exit" /sc once /st {wake_time_str} /f /it'

    # 실제 os 명령 exec  함수(sample: os.system) 대신 아래처럼 가정
    pk_print(f'{STAMP_DEBUG} CMD: {cmd}', print_color="blue")
    # sample: os.system(cmd)

    # 현재 시각과 예약 시각 출력
    current_time_str = now.strftime("%Y-%m-%d %H:%M:%S")
    readable_target_str = target_time.strftime("%Y-%m-%d %H:%M:%S")
    pk_print(f'현재 시간: {current_time_str}, 컴퓨터 깨우기 예약 시각: {readable_target_str} {'%%%FOO%%%' if LTA else ''}', print_color="blue")


def get_seconds_from_HH_mm(HH, mm):
    import datetime
    now = datetime.datetime.now()
    target_time = datetime.datetime(now.year, now.month, now.day, HH, mm)
    if now > target_time:
        target_time += datetime.timedelta(days=1)
    return (target_time - now).seconds


def print_holidays(year, task_name="휴일"):
    from datetime import datetime, timedelta
    # 법정공휴일을 예외처리로 넣을 수 있도록
    # year년의 첫날과 마지막 날
    start_date = datetime(year, 1, 1)
    end_date = datetime(year, 12, 31)

    # 요일 딕셔너리
    weekday_dict = {0: "월", 1: "화", 2: "수", 3: "목", 4: "금", 5: "토", 6: "일"}

    # 현재 날짜를 시작 날짜로 설정
    current_date = start_date

    while current_date <= end_date:
        # 요일 계산
        weekday = weekday_dict[current_date.weekday()]

        # 토요일(5)과 일요일(6)만 출력
        if current_date.weekday() >= 5:  # 토요일(5) 또는 일요일(6)
            print(rf'mkr_{current_date.strftime("%Y-%m-%d")} ({weekday}) __:__ "{task_name}"')

        # 다음 날로 이동
        current_date += timedelta(days=1)


def print_working_days(task_name, year):
    from pkg_py.pk_core_constants import UNDERLINE
    from datetime import datetime, timedelta
    import calendar
    # year년의 첫날과 마지막 날
    start_date = datetime(year, 1, 1)
    end_date = datetime(year, 12, 31)

    # 요일 딕셔너리
    weekday_dict = {0: "월", 1: "화", 2: "수", 3: "목", 4: "금", 5: "토", 6: "일"}

    # 현재 날짜를 시작 날짜로 설정
    current_date = start_date

    while current_date <= end_date:
        # 요일 계산
        weekday = weekday_dict[current_date.weekday()]

        # 월요일 ~ 금요일(근무일)만 출력
        if current_date.weekday() < 5:  # 월(0) ~ 금(4)
            print(rf'mkr_{current_date.strftime("%Y-%m-%d")} ({weekday}) __:__ "{task_name}"')

        # 말일 구분선 출력
        last_day_of_month = calendar.monthrange(current_date.year, current_date.month)[1]
        if current_date.day == last_day_of_month:
            print(rf"{UNDERLINE}")

        # 다음 날로 이동
        current_date += timedelta(days=1)


# def print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(stamp_custom, todo_task_name_str, start_date, end_date, f_txt, period="daily", specific_day=None, specific_weekday=None, specific_week=None, specific_month=None):
#     from datetime import timedelta
#     import calendar
#
#     str_list = []
#     # 요일 딕셔너리
#     weekday_dict = {0: "월", 1: "화", 2: "수", 3: "목", 4: "금", 5: "토", 6: "일"}
#
#     # 시작과 끝 구분선 추가
#     str_list.append(UNDERLINE)
#     section_str = rf"# [{period} cycle]"
#     str_list.append(section_str)
#
#     # 태스크 이름에 주기 정보 추가
#     # todo_task_name_str = rf"{todo_task_name_str:50s}[{period} cycle]"
#     todo_task_name_str = rf"{todo_task_name_str:50s}{stamp_custom}"
#
#     # 시작 날짜를 특정 요일으로 조정 (weekly와 biweekly에만 해당)
#     if period in ["weekly", "biweekly"] and specific_weekday is not None:
#         while start_date.weekday() != specific_weekday:
#             start_date += timedelta(days=1)
#
#     current_date = start_date
#
#     # yearly 주기일 때, 첫 번째 매칭 날짜로 current_date 설정
#     if period == "yearly" and specific_month is not None and specific_day is not None:
#         if (current_date.month > specific_month) or (current_date.month == specific_month and current_date.day > specific_day):
#             # 다음 해로 이동
#             try:
#                 current_date = current_date.replace(year=current_date.year + 1, month=specific_month, day=specific_day)
#             except ValueError:
#                 # sample: 2월 29일과 같이 존재하지 않는 날짜
#                 current_date = current_date.replace(year=current_date.year + 1, month=specific_month, day=28)
#         else:
#             # 올해에 해당 날짜가 있는지 확인
#             try:
#                 current_date = current_date.replace(month=specific_month, day=specific_day)
#             except ValueError:
#                 # sample: 2월 29일과 같이 존재하지 않는 날짜
#                 current_date = current_date.replace(month=specific_month, day=28)
#
#     while current_date <= end_date:
#         task_name = todo_task_name_str
#         weekday = weekday_dict[current_date.weekday()]
#
#         # 스케줄 조건 확인
#         add_schedule = False
#         if period == "daily":
#             add_schedule = True
#         elif period == "weekly" and specific_weekday is not None and current_date.weekday() == specific_weekday:
#             add_schedule = True
#         elif period == "biweekly" and specific_weekday is not None and current_date.weekday() == specific_weekday and (current_date - start_date).days % 14 == 0:
#             add_schedule = True
#         elif period == "monthly":
#             if specific_week is not None and specific_weekday is not None:
#                 # 특정 주와 특정 요일을 기준으로 스케줄 추가
#                 week_of_month = (current_date.day - 1) // 7 + 1
#                 if week_of_month == specific_week and current_date.weekday() == specific_weekday:
#                     add_schedule = True
#             elif specific_day is not None:
#                 if current_date.day == specific_day:
#                     add_schedule = True
#         elif period == "yearly":
#             if specific_month is not None and specific_day is not None:
#                 if current_date.month == specific_month and current_date.day == specific_day:
#                     add_schedule = True
#             elif specific_day is not None:
#                 # 기존 로직 유지 (specific_day을 월로 사용하는 경우)
#                 if current_date.month == specific_day:
#                     add_schedule = True
#         elif period == "last_day_of_month":
#             last_day_of_month = calendar.monthrange(current_date.year, current_date.month)[1]
#             if current_date.day == last_day_of_month:
#                 add_schedule = True
#
#         # 조건에 맞는 경우 태스크 추가
#         if add_schedule:
#             if current_date.weekday() < 5:  # 근무일 (월 ~ 금)
#                 task_name = rf"{task_name}[근무일]"
#             else:  # 휴일 (토, 일)
#                 task_name = rf"{task_name}[휴일]"
#
#             if period == "last_day_of_month":  # 말일 처리
#                 task_name = rf"{task_name}[말일]"
#             elif period == "yearly" and specific_month is not None and specific_day is not None:
#                 task_name = rf"{task_name}[연간]"
#
#             str_list.append(rf'mkr_{current_date.strftime("%Y-%m-%d")} ({weekday}) __:__ "{task_name}"')
#
#         # 다음 날짜로 이동
#         if period == "daily":
#             current_date += timedelta(days=1)
#         elif period == "weekly":
#             current_date += timedelta(days=7)
#         elif period == "biweekly":
#             current_date += timedelta(days=14)
#         elif period == "monthly":
#             if specific_week is not None and specific_weekday is not None:
#                 # 특정 주와 특정 요일을 처리하기 위해 다음 달의 첫 날로 이동
#                 next_month = current_date.month + 1 if current_date.month < 12 else 1
#                 next_year = current_date.year + 1 if next_month == 1 else current_date.year
#                 current_date = current_date.replace(year=next_year, month=next_month, day=1)
#                 # 해당 월의 특정 주의 특정 요일을 찾기
#                 days_in_month = calendar.monthrange(current_date.year, current_date.month)[1]
#                 found = False
#                 for day in range(1, days_in_month + 1):
#                     temp_date = current_date.replace(day=day)
#                     if temp_date.weekday() == specific_weekday:
#                         week_num = (temp_date.day - 1) // 7 + 1
#                         if week_num == specific_week:
#                             current_date = temp_date
#                             found = True
#                             break
#                 if not found:
#                     # 해당 주가 없는 경우(sample: 5주차)
#                     current_date = current_date.replace(day=days_in_month)
#             else:
#                 # 일반적인 월 단위 처리
#                 next_month = current_date.month + 1 if current_date.month < 12 else 1
#                 next_year = current_date.year + 1 if next_month == 1 else current_date.year
#                 current_date = current_date.replace(year=next_year, month=next_month, day=1)
#         elif period == "yearly":
#             if specific_month is not None and specific_day is not None:
#                 try:
#                     current_date = current_date.replace(year=current_date.year + 1)
#                 except ValueError:
#                     # 예를 들어 2월 29일과 같이 윤년이 아닌 해에는 처리
#                     current_date = current_date.replace(year=current_date.year + 1, day=28)
#             else:
#                 current_date = current_date.replace(year=current_date.year + 1)
#         elif period == "last_day_of_month":
#             next_month = current_date.month + 1 if current_date.month < 12 else 1
#             next_year = current_date.year + 1 if next_month == 1 else current_date.year
#             current_date = current_date.replace(year=next_year, month=next_month, day=1)
#             last_day = calendar.monthrange(current_date.year, current_date.month)[1]
#             current_date = current_date.replace(day=last_day)
#
#     str_list.append(UNDERLINE)
#
#     # 디버깅 출력
#     pk_print(str_working="\n".join(str_list))

#     pk_print("f에 저장을 원하면 enter를 눌러주세요",print_color='blue')
#     input(":")

#     # f에 저장
#     write_list_to_f_txt(working_list=str_list, f_txt=f_txt)
#
#
#     return 1

# done : chore : bimonthly
def print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(
        stamp_custom, todo_task_name_str, start_date, end_date, f_txt,
        period="daily", specific_day=None, specific_weekday=None, specific_week=None, specific_month=None
):
    from pkg_py.pk_colorful_cli_util import pk_print

    from pkg_py.pk_core_constants import UNDERLINE

    from datetime import timedelta
    import calendar

    str_list = []
    # 요일 딕셔너리
    weekday_dict = {0: "월", 1: "화", 2: "수", 3: "목", 4: "금", 5: "토", 6: "일"}

    # 시작과 끝 구분선 추가
    str_list.append(UNDERLINE)
    section_str = rf"# [{period} cycle]"
    str_list.append(section_str)

    # 태스크 이름에 주기 정보 추가
    todo_task_name_str = rf"{todo_task_name_str:50s}{stamp_custom}"

    # 시작 날짜를 특정 요일로 조정 (weekly와 biweekly에만 해당)
    if period in ["weekly", "biweekly"] and specific_weekday is not None:
        while start_date.weekday() != specific_weekday:
            start_date += timedelta(days=1)

    current_date = start_date

    # yearly 주기일 때, 첫 번째 매칭 날짜로 current_date 설정
    if period == "yearly" and specific_month is not None and specific_day is not None:
        if (current_date.month > specific_month) or (current_date.month == specific_month and current_date.day > specific_day):
            try:
                current_date = current_date.replace(year=current_date.year + 1, month=specific_month, day=specific_day)
            except ValueError:
                current_date = current_date.replace(year=current_date.year + 1, month=specific_month, day=28)
        else:
            try:
                current_date = current_date.replace(month=specific_month, day=specific_day)
            except ValueError:
                current_date = current_date.replace(month=specific_month, day=28)

    while current_date <= end_date:
        task_name = todo_task_name_str
        weekday = weekday_dict[current_date.weekday()]

        # 스케줄 조건 확인
        add_schedule = False
        if period == "daily":
            add_schedule = True
        elif period == "weekly" and specific_weekday is not None and current_date.weekday() == specific_weekday:
            add_schedule = True
        elif period == "biweekly" and specific_weekday is not None and current_date.weekday() == specific_weekday and (current_date - start_date).days % 14 == 0:
            add_schedule = True
        elif period == "monthly":
            if specific_week is not None and specific_weekday is not None:
                week_of_month = (current_date.day - 1) // 7 + 1
                if week_of_month == specific_week and current_date.weekday() == specific_weekday:
                    add_schedule = True
            elif specific_day is not None:
                if current_date.day == specific_day:
                    add_schedule = True
        elif period == "yearly":
            if specific_month is not None and specific_day is not None:
                if current_date.month == specific_month and current_date.day == specific_day:
                    add_schedule = True
        elif period == "last_day_of_month":
            last_day_of_month = calendar.monthrange(current_date.year, current_date.month)[1]
            if current_date.day == last_day_of_month:
                add_schedule = True
        elif period == "bimonthly":
            print(f"Checking bimonthly: Current date: {current_date}, Specific day: {specific_day}")
            next_month = current_date.month + 2 if current_date.month <= 10 else (current_date.month + 2) % 12
            next_year = current_date.year + (1 if current_date.month >= 11 else 0)
            current_date = current_date.replace(year=next_year, month=next_month)
            days_in_month = calendar.monthrange(current_date.year, current_date.month)[1]
            current_date = current_date.replace(day=min(specific_day, days_in_month))

            if current_date.month % 2 == start_date.month % 2 and (specific_day is None or current_date.day == specific_day):
                add_schedule = True
                print(f"Adding schedule: {current_date}")
            else:
                print(f"Skipping: {current_date}")

        # 조건에 맞는 경우 태스크 추가
        if add_schedule:
            if current_date.weekday() < 5:  # 근무일 (월 ~ 금)
                task_name = rf"{task_name}[근무일]"
            else:  # 휴일 (토, 일)
                task_name = rf"{task_name}[휴일]"

            if period == "last_day_of_month":  # 말일 처리
                task_name = rf"{task_name}[말일]"
            elif period == "yearly" and specific_month is not None and specific_day is not None:
                task_name = rf"{task_name}[연간]"

            str_list.append(rf'mkr_{current_date.strftime("%Y-%m-%d")} ({weekday}) __:__ "{task_name}"')

        # 다음 날짜로 이동
        if period == "daily":
            current_date += timedelta(days=1)
        elif period == "weekly":
            current_date += timedelta(days=7)
        elif period == "biweekly":
            current_date += timedelta(days=14)
        elif period == "monthly":
            next_month = current_date.month + 1 if current_date.month < 12 else 1
            next_year = current_date.year + 1 if next_month == 1 else current_date.year
            current_date = current_date.replace(year=next_year, month=next_month, day=1)
        elif period == "yearly":
            current_date = current_date.replace(year=current_date.year + 1)
        elif period == "bimonthly":
            next_month = current_date.month + 2 if current_date.month <= 10 else (current_date.month + 2) % 12
            next_year = current_date.year + (1 if current_date.month >= 11 else 0)
            current_date = current_date.replace(year=next_year, month=next_month, day=1)
        elif period == "last_day_of_month":
            next_month = current_date.month + 1 if current_date.month < 12 else 1
            next_year = current_date.year + 1 if next_month == 1 else current_date.year
            current_date = current_date.replace(year=next_year, month=next_month, day=1)
            last_day = calendar.monthrange(current_date.year, current_date.month)[1]
            current_date = current_date.replace(day=last_day)

    str_list.append(UNDERLINE)

    # 디버깅 출력
    pk_print(working_str="\n".join(str_list))

    pk_print("f에 저장을 원하면 enter를 눌러주세요", print_color='blue')
    input(":")

    # f에 저장
    write_list_to_f(working_list=str_list, f=f_txt, mode='a')

    return 1


def get_next_date(period, current_date):
    from datetime import timedelta
    import calendar

    if period == "daily":
        return current_date + timedelta(days=1)
    elif period == "weekly":
        return current_date + timedelta(days=7)
    elif period == "biweekly":
        return current_date + timedelta(days=14)
    elif period == "monthly":
        # 다음 달의 1일로 이동
        next_month = current_date.month + 1 if current_date.month < 12 else 1
        next_year = current_date.year + 1 if next_month == 1 else current_date.year
        return current_date.replace(year=next_year, month=next_month, day=1)
    elif period == "yearly":
        return current_date.replace(year=current_date.year + 1)
    elif period == "last_day_of_month":
        # 다음 달의 마지막 날로 이동
        next_month = current_date.month + 1 if current_date.month < 12 else 1
        next_year = current_date.year + 1 if next_month == 1 else current_date.year
        next_first_day = current_date.replace(year=next_year, month=next_month, day=1)
        last_day = calendar.monthrange(next_first_day.year, next_first_day.month)[1]
        return next_first_day.replace(day=last_day)
    else:
        raise ValueError(f"Unsupported period: {period}")


def print_and_write_schedule_template_cyclic_non_to_f_memo_todo_txt(stamp_custom, todo_task_name_str, f_txt, specific_year=None, specific_day=None, specific_month=None):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import UNDERLINE
    str_list = []
    # 요일 딕셔너리
    weekday_dict = {0: "월", 1: "화", 2: "수", 3: "목", 4: "금", 5: "토", 6: "일"}

    # 시작과 끝 구분선 추가
    str_list.append(UNDERLINE)
    section_str = rf"# [non cycle]"
    str_list.append(section_str)

    # 태스크 이름에 주기 정보 추가
    todo_task_name_str = rf"{todo_task_name_str:50s}{stamp_custom}"

    from datetime import datetime
    start_date = datetime(specific_year, specific_month, specific_day)

    task_name = todo_task_name_str
    weekday = weekday_dict[start_date.weekday()]

    # 스케줄 조건 확인
    add_schedule = False
    period = "non"
    if period == "non":
        add_schedule = True

    # 조건에 맞는 경우 태스크 추가
    if add_schedule:
        if start_date.weekday() < 5:  # 근무일 (월 ~ 금)
            task_name = rf"{task_name}[근무일]"
        else:  # 휴일 (토, 일)
            task_name = rf"{task_name}[휴일]"

        if period == "last_day_of_month":  # 말일 처리
            task_name = rf"{task_name}[말일]"
        elif period == "yearly" and specific_month is not None and specific_day is not None:
            task_name = rf"{task_name}[연간]"

        str_list.append(rf'mkr_{start_date.strftime("%Y-%m-%d")} ({weekday}) __:__ "{task_name}"')

    str_list.append(UNDERLINE)

    # 디버깅 출력
    pk_print(working_str="\n".join(str_list))

    pk_print("f에 저장을 원하면 enter를 눌러주세요", print_color='blue')
    input(":")

    # f에 저장
    write_list_to_f(working_list=str_list, f=f_txt, mode='a')

    return 1


def move_memo_lines_containing_keywords_to_f(f_from, f_to, keyword):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import Encoding
    import os
    import inspect
    import tempfile
    try:
        with tempfile.NamedTemporaryFile('w', delete=False, encoding=Encoding.UTF8.value) as f_temp:
            f_temp_n = f_temp.name
            moved_count = 0
            with open(file=f_from, mode='r', encoding=Encoding.UTF8.value) as f_original:
                for line in f_original:
                    if keyword in line:
                        with open(file=f_to, mode='a', encoding=Encoding.UTF8.value) as f_hashed:
                            f_hashed.write(line)
                        moved_count += 1
                    else:
                        f_temp.write(line)

        # 원본 f을 임시 f로 교체합니다.
        os.replace(f_temp_n, f_from)
        func_n = inspect.currentframe().f_code.co_name
        pk_print(f"[{func_n}]{moved_count} 개의 줄 이동 fron '{f_from}' to '{f_to}'", print_color='green')

    except FileNotFoundError as e:
        pk_print(f"오류: f을 찾을 수 없습니다 - {e.filename}", print_color='red')
    except Exception as e:
        pk_print(f"예상치 못한 오류가 발생했습니다: {e}", print_color='red')


def transform_data(data, replacements):
    """
    주어진 데이터에서 주석(#)을 remove하고,
    "단어    [" 또는 "단어[" 패턴을 추출하여 지정된 매핑에 따라 개별적으로 치환합니다.
    닫는 인용부호(")는 그대로 유지합니다.

    Args:
        data (str): 변환할 원본 데이터 문자열.
        replacements (dict): 치환할 단어와 대체 문자열의 매핑 딕셔너리.
                             sample: {'음악틀기': ' {'%%%FOO%%%' if LTA else ''}', '물먹기': '%%%BAR%%%'}

    Returns:
        str: 변환된 데이터 문자열.
    """
    import re

    transformed_lines = []
    lines = data.split('\n')

    # 정규 표현식 패턴
    # 패턴 1: "단어    [ 또는 "단어[ 패턴을 매칭하여 치환
    pattern_start = r'"([^"\[]+?)\s*\['

    for line in lines:
        stripped_line = line.strip()
        if stripped_line.startswith("#"):
            # 주석인 줄은 무시하고 변환 결과에 포함시키지 않음
            continue
        else:
            # 패턴 1 적용: "단어    [ 또는 "단어[ ->> "단어["
            match = re.search(pattern_start, line)
            if match:
                original_word = match.group(1).strip()
                # 치환할 단어가 replacements 딕셔너리에 있는지 확인
                if original_word in replacements:
                    replacement_word = replacements[original_word]
                    # 치환 수행: 원래 단어를 대체 단어로 교체
                    # sample: "음악틀기    [ ->> " {'%%%FOO%%%' if LTA else ''}[
                    transformed_line = re.sub(
                        r'"' + re.escape(original_word) + r'\s*\[',
                        f'"{replacement_word}[',
                        line
                    )
                else:
                    # 치환할 단어가 없으면 원래 라인을 그대로 유지
                    transformed_line = line
                transformed_lines.append(transformed_line)
            else:
                # 패턴에 매칭되지 않으면 원래 라인을 그대로 유지
                transformed_lines.append(line)

    # 변환된 모든 줄을 다시 하나의 문자열로 결합
    transformed_data = '\n'.join(transformed_lines)

    return transformed_data


def extract_words(data):
    """
    주어진 데이터에서 주석(#)을 remove하고,
    각 줄에서 "단어    [" 또는 "단어[" 패턴에 있는 단어들을 추출합니다.

    Args:
        data (str): 변환할 원본 데이터 문자열.

    Returns:
        list: 추출된 단어들의 리스트.
    """
    import re

    extracted_words = []
    lines = data.split('\n')

    # 정규 표현식 패턴
    # 패턴 설명:
    # - ^[^#]*": 라인이 #으로 시작하지 않으며, "으로 시작하는 부분을 찾음
    # - ([^"\[]+?): "와 [ 사이의 단어를 캡처
    # - \s*\[: 공백이 있을 수도 없을 수도 있고, 그 뒤에 [가 오는 패턴
    pattern = r'^[^#]*"([^"\[]+?)\s*\['

    for line in lines:
        stripped_line = line.strip()
        if stripped_line.startswith("#"):
            # 주석인 줄은 무시
            continue
        # 정규 표현식 매칭 시도
        match = re.search(pattern, line)
        if match:
            word = match.group(1).strip()
            extracted_words.append(word)

    return extracted_words


def create_replacements(extracted_words, size):
    unique_words = set(extracted_words)
    replacements = {f'{word}': f'{word:{size}s}' for word in unique_words}
    return replacements


def get_tuple_from_set(working_set):
    return tuple(working_set)


def get_list_from_str(item_str, delimiter='\n'):
    if not isinstance(item_str, str):
        raise ValueError("입력은 문자열이어야 합니다.")

    return [item for item in item_str.split(delimiter)]


def get_list_aligned_words_gap(working_list, size):
    item_str = get_str_from_list(working_list=working_list, item_connector="%%%LF%%%")
    extracted_words = extract_words(item_str)
    replacements = create_replacements(extracted_words, size=size)
    transformed_data = transform_data(item_str, replacements)
    transformed_data_list = get_list_from_str(item_str=transformed_data, delimiter="%%%LF%%%")
    return transformed_data_list


def add_todo():
    from datetime import datetime

    import pkg_py.pk_core_constants as pk_core_constants

    now = datetime.now()
    weekday_dict = {0: "월", 1: "화", 2: "수", 3: "목", 4: "금", 5: "토", 6: "일"}
    weekday = weekday_dict[now.weekday()]
    yyyy = now.year
    MM = str(now.month).zfill(2)
    dd = str(now.day).zfill(2)
    HH = str(now.hour).zfill(2)
    mm = str(now.minute).zfill(2)
    # print(UNDERLINE)
    # print_schedule_template_lines(yyyy=yyyy, MM=MM, dd=dd, weekday=weekday, HH=HH, mm=mm, task_name=task_name)
    # print(UNDERLINE)
    # print_schedule_template_lines(yyyy=yyyy, MM=MM, dd="dd", weekday="weekday", HH="HH", mm="mm", task_name=task_name)
    # print(UNDERLINE)
    # print_schedule_template_lines(yyyy=yyyy, MM=MM, dd="__", weekday="_", HH="__", mm="__", task_name=task_name)
    # print(UNDERLINE)
    # print_schedule_template_lines(yyyy=yyyy, MM="__", dd="__", weekday="_", HH="__", mm="__", task_name=task_name)
    # print(UNDERLINE)
    # print_schedule_template_lines(yyyy=yyyy, MM="__", dd="__", weekday="_", HH="__", mm="__", task_name='_______')
    # print(UNDERLINE)
    # print_schedule_template_lines_as_simple(yyyy=yyyy, task_name=task_name)
    # print(UNDERLINE)
    # print_working_days_for_2025(task_name=task_name)
    # print(UNDERLINE)
    # print_holidays_for_2025(task_name=task_name)
    # print(UNDERLINE)

    memo_todo_txt = rf"{pk_core_constants.D_PKG_TXT}/memo_todo.txt"
    memo_todo_txt = get_pnx_os_style(memo_todo_txt)
    memo_trash_bin_txt = rf'{pk_core_constants.D_PKG_TXT}/memo_trash_bin.txt'
    memo_trash_bin_txt = get_pnx_os_style(memo_trash_bin_txt)
    memo_done_txt = rf'{pk_core_constants.D_PKG_TXT}/memo_done.txt'
    memo_done_txt = get_pnx_os_style(memo_done_txt)

    # make_pnx(pnx=memo_done_txt, mode='f')
    # make_pnx(pnx=memo_trash_bin_txt, mode='f')

    # start_date = datetime(2025, 1, 1)
    # end_date = datetime(2025, 12, 31)

    start_date = datetime(year=int(yyyy), month=int(MM), day=int(dd))
    end_date = datetime(year=int(yyyy), month=12, day=31)

    # 주기 # 매시간
    # 백업

    # 주기 # 매일
    # print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str='_________', start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="daily", stamp_custom='[매일]')
    # print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str='웃긴거보기', start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="daily", stamp_custom='[매일]')
    # print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str='기분리프레쉬 게임', start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="daily", stamp_custom='[매일]')
    # print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str='최대절전모드', start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="daily", stamp_custom='[매일]')
    # print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str='발씻기', start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="daily", stamp_custom='[매일]')
    # print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str='wake up', start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="daily", stamp_custom='[매일]')
    # print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str='powersave mode', start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="daily", stamp_custom='[매일]')
    # print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str='엄마 잔소리에 소리로 강하게 대응하지 않기', start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="daily", stamp_custom='[매일]')

    # 주기 # 매주
    # print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str='_________', start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="weekly", specific_weekday=0, stamp_custom='[매주 월요일]')
    # print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str='_________', start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="weekly", specific_weekday=1, stamp_custom='[매주 화요일]')
    # print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str='_________', start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="weekly", specific_weekday=2, stamp_custom='[매주 수요일]')
    # print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str='_________', start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="weekly", specific_weekday=3, stamp_custom='[매주 목요일]')
    print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str='치실', start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="weekly", specific_weekday=3, stamp_custom='[매주 목요일]')
    # print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str='_________', start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="weekly", specific_weekday=4, stamp_custom=rf'[매주 금요일]')
    # print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str='_________', start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="weekly", specific_weekday=5, stamp_custom=rf'[매주 토요일]')
    # print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str='_________', start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="weekly", specific_weekday=6, stamp_custom=rf'[매주 일요일]')

    # 주기 # 매월
    # print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str='_________', start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="biweekly", specific_weekday=4, stamp_custom=rf'[매월 2주 금요일]')
    # print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str='_________', start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="monthly", specific_week=3, specific_weekday=5, stamp_custom=rf'[매월 3주 토요일]')
    # print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str='_________', start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="last_day_of_month", stamp_custom=rf'[매월 말일]')

    # 주기 # 2개월 # success
    # print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str="헤어샾 예약 리프컷+일반펌 or 시스루댄디컷", start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="bimonthly", specific_day=11,stamp_custom="[매2개월 11일]")

    # 주기 # 매년
    # end_date = datetime(2045, 12, 31)
    # print_and_write_schedule_template_cyclic_to_f_memo_todo_txt(todo_task_name_str='_________', start_date=start_date, end_date=end_date, f_txt=memo_todo_txt, period="yearly", specific_month=1, specific_day=15, stamp_custom=rf'[매년 1월 15일]')

    # 주기 # 2년마다 #biyearly
    # mkr_2026-12-__(1-0) "2026 건강검진 [2년주기]"

    # 비주기
    # print_and_write_schedule_template_cyclic_non_to_f_memo_todo_txt(todo_task_name_str='________', specific_year=2025, f_txt=memo_todo_txt, specific_month=1, specific_day=13, stamp_custom=rf'[비주기]')
    # print_and_write_schedule_template_cyclic_non_to_f_memo_todo_txt(todo_task_name_str='모니터 악세서리확인', specific_year=2025, f_txt=memo_todo_txt, specific_month=1, specific_day=12, stamp_custom=rf'[비주기]')
    # print_and_write_schedule_template_cyclic_non_to_f_memo_todo_txt(todo_task_name_str='향수구매', specific_year=2025, f_txt=memo_todo_txt, specific_month=1, specific_day=14, stamp_custom=rf'[비주기]')
    # print_and_write_schedule_template_cyclic_non_to_f_memo_todo_txt(todo_task_name_str='점빼기', specific_year=2025, f_txt=memo_todo_txt, specific_month=12, specific_day=1, stamp_custom=rf'[비주기]')
    # print_and_write_schedule_template_cyclic_non_to_f_memo_todo_txt(todo_task_name_str='칫솔구매', specific_year=2025, f_txt=memo_todo_txt, specific_month=1, specific_day=13, stamp_custom=rf'[비주기]')
    # print_and_write_schedule_template_cyclic_non_to_f_memo_todo_txt(todo_task_name_str='신진영/신수영/강주형 연락 및 안부전화', specific_year=2025, f_txt=memo_todo_txt, specific_month=3, specific_day=5, stamp_custom=rf'[비주기]')

    # cmd_to_os(cmd=rf'explorer "{memo_done_txt}" ')
    cmd_to_os(cmd=rf'explorer "{memo_todo_txt}" ')


def is_url_open_via_selenium(url_to_check):
    """
    Selenium을 사용하여 특정 URL이 열려 있는지 확인하고, 열려 있지 않으면 새로 열기
    """
    from selenium.webdriver.chrome.options import Options

    # Chrome 옵션 설정
    chrome_options = Options()
    chrome_options.add_argument("--start-maximized")  # 브라우저 최대화
    chrome_options.add_argument("--disable-infobars")  # 브라우저 정보 표시 비활성화
    chrome_options.add_argument("--disable-extensions")  # 확장 프로그램 비활성화
    chrome_options.add_experimental_option("detach", True)  # 브라우저 종료 방지

    # ChromeDriver exec
    driver = get_driver_selenium(browser_debug_mode=True)

    # 열려 있는 모든 탭 가져오기
    handles = driver.window_handles
    url_found = False

    for handle in handles:
        driver.switch_to.window(handle)
        if url_to_check in driver.current_url:
            print(f"이미 열려 있는 URL: {driver.current_url}")
            url_found = True
            break

    # URL이 열려 있지 않으면 새로 열기
    if not url_found:
        print(f"URL 열려 있지 않음. 새 탭으로 열기: {url_to_check}")
        driver.execute_script(f"window.open('{url_to_check}', '_blank');")
        driver.switch_to.window(driver.window_handles[-1])  # 새로 연 탭으로 전환

    # 드라이버 유지 (필요 시)
    return driver


# def set_registry_value(root, path, name, reg_type, value):
#     import winreg
#     """레지스트리 키 값을 설정하는 함수"""
#     try:
#         with winreg.CreateKey(root, path) as key:
#             winreg.SetValueEx(key, name, 0, reg_type, value)
#             print(f"[OK] {path} ->> {name} = {value}")
#     except Exception as e:
#         print(f"{STAMP_ERROR} {path} ->> {name} : {e}")
#
# def customize_cmd(cmd_title_name):
#     import winreg
#     # 1. CMD 기본값 설정 (Autorun 키 추가)
#     cmd = rf"prompt $P$G & title {cmd_title_name}"
#     set_registry_value(
#         winreg.HKEY_CURRENT_USER,
#         r"Software\\Microsoft\\Command Processor",
#         "Autorun",
#         winreg.REG_SZ,
#         cmd,
#     )
#
#     # 2. CMD 창 위치 설정 (WindowPosition)
#     window_position = 0x00320032  # 왼쪽 50, 위쪽 50
#     set_registry_value(
#         winreg.HKEY_CURRENT_USER,
#         r"Console",
#         "WindowPosition",
#         winreg.REG_DWORD,
#         window_position,
#     )
#
#     # 3. CMD 글꼴 크기 설정 (FontSize)
#     font_size = 0x00100000  # 글꼴 크기 16
#     set_registry_value(
#         winreg.HKEY_CURRENT_USER,
#         r"Console",
#         "FontSize",
#         winreg.REG_DWORD,
#         font_size,
#     )
#
#     # 4. 명령 기록 버퍼 크기 설정 (HistoryBufferSize)
#     history_buffer_size = 200  # 버퍼 크기 200
#     set_registry_value(
#         winreg.HKEY_CURRENT_USER,
#         r"Console",
#         "HistoryBufferSize",
#         winreg.REG_DWORD,
#         history_buffer_size,
#     )
#
#     pk_print(str_working="\nCMD 커스터마이징이 완료되었습니다!")


def restart_up_pk_process_list():
    import asyncio
    from pkg_py.pk_core_constants import F_ALIAS_CMD, D_WORKING, D_HOME, D_PROJECT, F_MEMO_WORK_PK, F_MEMO_HOW_PK, D_PKG_PY

    if is_os_windows():
        cmd_to_os("chcp 65001")

    if not is_office_pc():
        cmd_list = [
            rf'explorer "{D_PROJECT}\.venv\Scripts\activate && python {D_PKG_PY}\pk_test.py && deactivate"',
        ]
        for cmd in cmd_list:
            cmd_to_os(cmd=cmd, mode='a')

        f_list = [
            rf"{D_PKG_PY}/pk_assist_to_control_wsl.py",
            rf"{D_PKG_PY}/pk_assist_to_kill_explorer_window_duplicated_list.py",
            rf"{D_PKG_PY}/pk_guide_todo.py",

            # 작업 손실 유의
            rf"{D_PKG_PY}/pk_assist_to_run_mini.py",
            rf"{D_PKG_PY}/pk_assist_to_load_video_at_losslesscut.py",
            rf"{D_PKG_PY}/pk_assist_to_upload_project.py",
            rf"{D_PKG_PY}/pk_assist_to_ensure_f_list_organized_by_nx_delimiter.py",
            # rf"{D_PKG_PY}/pk_assist_to_ensure_f_list_organized_by_ext.py",
            rf"{D_PKG_PY}/pk_ensure_f_list_organized_by_ngram.py",
            rf"{D_PKG_PY}/pk_ensure_f_list_organized_by_keyword_and_x.py",
            # mkr.
            rf"{D_PKG_PY}/pk_assist_to_lock_os.py",  # *
            rf"{D_PKG_PY}/pk_replace_old_str_in_f_nx.py",
            # rf"{D_PKG_PY}/pk_collect_and_download_magnets.py",
        ]
        for f in f_list:
            pk_kill_process_by_window_title_seg(window_title_seg=get_nx(f))
        for f in f_list:
            pk_run_process(pk_program_n_seg=get_nx(f))

        # with window : oneshot
        f_list = [
            rf"{D_PKG_PY}/pk_kill_us_keyboard.py",  # todo : [ATTEMPTED] while block in pk_kill_us_keyboard->> void block
        ]
        for f in f_list:
            asyncio.run(pk_kill_process_as_async(f=f))
        for f in f_list:
            asyncio.run(pk_run_process_as_async(f=f))
        for f in f_list:
            asyncio.run(pk_kill_process_as_async(f=f))


    elif is_office_pc():
        kakaowork_ink = rf"{D_HOME}\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\카카오워크\카카오워크.lnk"
        pycharm2024_2_4_64_exe = r"C:\Program Files\JetBrains\PyCharm Community Edition 2024.2.4\bin\pycharm64.exe"
        cmd_list = [
            # "cls",
            # 'start "" explorer "https://chatgpt.com/"',
            'explorer "https://chatgpt.com/"',
            rf'explorer "{D_PROJECT}\.venv\Scripts\activate && python C:\Users\Autonomousa2z\Downloads\pk_system\pkg_py\pk_test.py && deactivate"',
            f'explorer "{kakaowork_ink}"',
            f'explorer "https://mail.autoa2z.co.kr/#inbox"',
            f'explorer "https://bb.bbgw.kr/a/in.bb"',
            f'explorer "https://shiftee.io/app/companies/2050081/staff/scheduler#month"',
            f'explorer "https://www.notion.so/a2zaidev/PROD-0ff24ea4c8d14f05a2c70cf17db71851"',  # PROD
            f'explorer "https://www.notion.so/a2zaidev/VSTEST-ce7c24c68d6044aeb8eef8f43fa97632"',  # VSTEST
            f'explorer "https://www.notion.so/a2zaidev/1a797f1bfea08096baa4cf21dfd7ff62"',  # 이슈 트래커
            f'start cmd.exe /k "{pycharm2024_2_4_64_exe}"',
            # f'start cmd.exe /k',  # cmd.exe in venv
        ]
        for cmd in cmd_list:
            cmd_to_os(cmd=cmd, mode='a')

        # without window
        f_list = [
            # f'{D_PROJECT_RELEASE_SERVER}/pk_run_release_server.py',
            rf"{D_PKG_PY}/pk_kill_window_duplicated_list.py",
        ]
        for f in f_list:
            asyncio.run(pk_kill_process_as_async(f=f))
        for f in f_list:
            asyncio.run(pk_run_process_as_async(f=f, mode_with_window=0))

        # with window
        f_list = [
            rf"{D_PKG_PY}/pk_wsl.py",
        ]
        for f in f_list:
            # pk_kill_process(cmd_exe_title=rf"f_nx")
            asyncio.run(pk_kill_process_as_async(f=f))
        for f in f_list:
            asyncio.run(pk_run_process_as_async(f=f))

        # with window : oneshot
        f_list = [
            rf"{D_PKG_PY}/pk_kill_us_keyboard.py",  # todo : [ATTEMPTED] while block in pk_kill_us_keyboard->> void block
        ]
        for f in f_list:
            asyncio.run(pk_kill_process_as_async(f=f))
        for f in f_list:
            asyncio.run(pk_run_process_as_async(f=f))
        for f in f_list:
            asyncio.run(pk_kill_process_as_async(f=f))

        # f_cmd
        # pnx = rf"{D_PROJECT_RELEASE_SERVER}/run_release_server.cmd"
        # pnx = get_pnx_os_style(pnx=pnx)
        # pk_print(str_working=rf'''pnx="{pnx}"  {'%%%FOO%%%' if LTA else ''}''')
        # while is_f_locked(pnx):  # 배치f이 잠겨 있는지 확인 후 잠겨 있으면 기다림
        #     pk_print(f"File is locked, waiting for 1 second...")
        #     pk_sleep(seconds=1)
        # cmd_to_os(cmd=rf'start "" "{pnx}"', encoding=Encoding.UTF8, mode='a')

        # login_and_filter_and_export_addup()

        # taskkill
        #     tasklist | findstr tv_x64.exe
        # cmd_to_os("tasklist | findstr tv_x64.exe")
        kill_list = [
            # "PowerToys.exe",
            # "powertoys.exe",
            # "KMFtp.exe",
            "TeamViewer.exe",
            "TeamViewer_Service.exe",
            "Telegram.exe",
            # "tv_w32.exe",
            # "tv_x64.exe",
            # "tvnserver.exe",
            # "xlaunch.exe",
            # "vcxsrv.exe",
        ]
        for process_name in kill_list:
            cmd_to_os(f"taskkill /f /im {process_name}")

        # # 11) WSL / SSH 서버 exec
        # # "C:\Windows\System32\bash.exe" -c "sudo service ssh start"
        # cmd_to_os(r'"C:\Windows\System32\bash.exe" -c "sudo service ssh start"')

        # # (2) 콘솔 창 제목 설정
        # # title %~nx0
        # # Python에서 batch 스크립트처럼 %~nx0을 쓰기는 어려우므로, 간단히 문자열을 지정합니다.
        # cmd_to_os("title pk_system_shell_start_up.py")

    # pnx
    pnx_list = [
        D_PROJECT,
        D_WORKING,
        # MEMO_TRASH_BIN_TXT,
        F_MEMO_HOW_PK,
        F_MEMO_WORK_PK,
        F_ALIAS_CMD,
    ]
    for pnx in pnx_list:
        pnx = get_pnx_os_style(pnx)
        if does_pnx_exist(pnx=pnx):
            cmd_to_os(f'explorer "{pnx}"')


def get_line_list_to_include_search_keyword(f, search_keywords):
    lines_list = get_list_from_f(f=f)
    target_lines = []

    for line in lines_list:
        if any(keyword in line for keyword in search_keywords):
            target_lines.append(line)

    return target_lines


def print_memo_titles(f):
    # todo
    lines_list = get_line_list_to_include_search_keyword(f=f, search_keywords=["[todo]"])
    lines_list = get_list_removed_element_startswith_str(working_list=lines_list, string="#")
    liens_str = get_str_from_list(working_list=lines_list, item_connector='')

    highlight_config_dict = {
        "bright_red": [
            f'{' %%%FOO%%% ' if LTA else ''}'
        ],
        "white": [
            '[todo]'
        ],
    }
    print_highlighted(txt_whole=liens_str, highlight_config_dict=highlight_config_dict)


def add_data_to_f_toml(f_toml, data_new):
    from enum import Enum
    encoding: Enum
    from pkg_py.pk_core_constants import Encoding

    import toml
    # TOML f 읽기
    with open(file=f_toml, mode="r", encoding=Encoding.UTF8.value) as f:
        toml_data = toml.load(f)

    # 새로운 데이터 추가
    for key, value in data_new.items():
        if key in toml_data:
            # 기존 데이터와 병합
            toml_data[key].update(value)
        else:
            # 새로운 키 추가
            toml_data[key] = value

    # TOML f 다시 저장
    with open(file=f_toml, mode="w", encoding=Encoding.UTF8.value) as f:
        toml.dump(toml_data, f)


def get_list_removed_element_startswith_str(working_list, string):
    if not isinstance(working_list, list):
        raise ValueError("working_list는 리스트여야 합니다.")
    if not isinstance(string, str):
        raise ValueError("string은 문자열이어야 합니다.")

    # 특정 문자열로 시작하지 않는 요소 필터링
    return [item for item in working_list if not item.strip().startswith(string)]


# def kill_windows_duplicated_of_explorer():
#     """
#     중복된 Windows 탐색기 창을 닫습니다.
#     각 d당 하나의 창만 남깁니다.
#     """
#     from pkg_py.pk_colorful_cli_util import pk_print
#     try:
#         import win32com.client
#         import pythoncom
#         import traceback
#         import os
#     except ImportError as e:
#         pk_print(f"필요한 모듈을 임포트하는 중 오류 발생: {e}", print_color='red')
#         return
#
#     try:
#         # COM 초기화
#         pythoncom.CoInitialize()
#
#         # Shell.Application을 사용하여 열린 창들에 접근
#         shell = win32com.client.Dispatch("Shell.Application")
#         windows = shell.Windows()
#
#         path_to_windows = {}
#
#         # 탐색기 창 식별을 위한 다양한 이름 리스트 (언어별)
#         explorer_names = ["explorer", "windows 탐색기", "f 탐색기"]  # 필요한 언어 추가 가능
#
#         for window in windows:
#             try:
#                 # 탐색기 창인지 확인 (다양한 언어 지원)
#                 window_name = window.Name.lower()
#                 if not any(window_name.startswith(name) for name in explorer_names):
#                     # print(f"탐색기 창이 아닌 창 발견: {window.Name}")
#                     continue
#
#                 # 현재 창의 경로 가져오기
#                 try:
#                     current_path = window.Document.Folder.Self.Path
#                     # print(f"탐색기 창 경로: {current_path}")
#                 except Exception as path_e:
#                     pk_print(f"경로를 가져오는 중 오류 발생: {path_e}", print_color='red')
#                     continue
#
#                 if not current_path:
#                     pk_print("경로를 가져올 수 없는 창 발견.", print_color='red')
#                     continue
#
#                 # 경로 정규화 및 소문자 변환
#                 current_path_normalized = os.path.normpath(current_path).lower()
#                 # print(f"정규화된 경로: {current_path_normalized}")
#
#                 if current_path_normalized in path_to_windows:
#                     path_to_windows[current_path_normalized].append(window)
#                 else:
#                     path_to_windows[current_path_normalized] = [window]
#
#             except Exception as e:
#                 pk_print(f"창을 처리하는 중 오류 발생: {e}", print_color='red')
#                 continue
#
#         # 중복된 창 닫기
#         try:
#             for path, win_list in path_to_windows.items():
#                 if len(win_list) > 1:
#                     pk_print(f"d '{path}'에 대해 {len(win_list)}개의 창이 열려 있습니다. 중복된 창을 닫습니다.", print_color="blue")
#                     # 첫 번째 창을 제외한 나머지 창 닫기
#                     for window in win_list[1:]:
#                         window.Quit()
#                         pk_print(f"창을 성공적으로 닫았습니다: {path}", print_color="green")
#         except:
#             pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
#
#     except:
#         pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
#
#     finally:
#         # COM 언인초기화
#         pythoncom.CoUninitialize()

def kill_explorer_window_duplicated_list():
    """
    중복된 Windows 탐색기 창을 닫습니다. 각 디렉터리당 하나의 창만 남깁니다.
    """
    from pkg_py.pk_colorful_cli_util import pk_print
    try:
        import win32com.client
        import pythoncom
        import os
        import traceback
        import win32gui
        import win32con
    except ImportError as e:
        pk_print(f"모듈 임포트 오류: {e}", print_color='red')
        return

    try:
        # COM 초기화
        pythoncom.CoInitialize()
        shell = win32com.client.Dispatch("Shell.Application")
        windows = shell.Windows()
        path_to_windows = {}
        pk_print("Window explorer.exe 중복창 탐지 중...")
        for window in windows:
            try:
                hwnd = window.HWND  # 창의 핸들값 가져오기
                if not hwnd:
                    pk_print(f"HWND를 찾을 수 없는 창: {window.Name}", print_color='red')
                    continue
                current_path = window.Document.Folder.Self.Path
                if not current_path:
                    pk_print("경로를 확인할 수 없는 창이 발견됨", print_color='red')
                    continue

                # 경로 정규화
                normalized_path = os.path.normpath(current_path).lower()

                # 창 목록에 추가
                path_to_windows.setdefault(normalized_path, []).append((hwnd, window))

            except Exception as e:
                pk_print(f"창 처리 중 오류 발생: {e}", print_color='red')
                continue

        # 중복된 창 닫기
        for path, win_list in path_to_windows.items():
            if len(win_list) > 1:
                pk_print(f"[중복창 탐지] {len(win_list)}개 창 중복 path={path}")
                for hwnd, window in win_list[1:]:  # 첫 번째 창을 제외한 나머지 창 닫기
                    try:
                        window.Quit()  # pk_print(f"[중복창 닫기] hwnd={hwnd} path={path}")
                        win32gui.PostMessage(hwnd, win32con.WM_CLOSE, 0, 0)  # 추가적으로 윈도우 강제 닫기 시도

                        pk_print(f"[중복창 닫기] window={window} hwnd={hwnd} path={path}", print_color="green")
                    except:
                        pk_print(f"[중복창 닫기] window={window} hwnd={hwnd} path={path}", print_color='red')
    except Exception as e:
        pk_print(f"오류 발생: {traceback.format_exc()}", print_color='red')
    finally:
        pythoncom.CoUninitialize()  # COM 해제


def add_lazy_import_all_modules_to_outter_functions(f: str):
    from pkg_py.pk_core_constants import Encoding
    from enum import Enum
    encoding: Enum
    import os

    lazy_import_code = """
import pk_core_constants
import inspect
import json
import os
import platform
import random
import re
import shutil
import string
import subprocess
import sys
import threading
import time
import traceback
import urllib
import webbrowser
import zipfile
from collections import Counter
from functools import partial
from typing import TypeVar, List
from urllib.parse import quote, urlparse
from zipfile import BadZipFile
import keyboard
import numpy as np
import pyaudio
import pygetwindow
import pyglet
import speech_recognition as sr
import tqdm
import win32con # pywin32
import win32gui # pywin32
import win32process
from dirsync import sync
from pkg_py.pk_colorful_cli_util import pk_print, pk_print, pk_print, pk_print, pk_print, print_magenta, print_light_white, ColoramaUtil, print_ment_via_colorama, print_success, prijnt_as_log, print_yellow  
from pkg_py.pk_core_constants import USERPROFILE, HOSTNAME, UNDERLINE, BLANK, BIGGEST_PNXS, SMALLEST_PNXS, PLAYING_SOUNDS, COUNTS_FOR_GUIDE_TO_SLEEP, [], VIDEO_IDS_ALLOWED, AUDIO_IDS_ALLOWED, STORAGE_VIDEOES_MERGED, PROJECT_PARENTS_D, DESKTOP, DOWNLOADS, PKG_PNG, PKG_DPL, PKG_TXT, \\
    CLASSIFYING, RECYCLE_BIN, LOCAL_PKG_CACHE_FILE, SUCCESS_LOG, YT_DLP_CMD, JQ_WIN64_EXE, \\
    FFMPEG_EXE, DB_YAML, USELESS_FILE_NAMES_TXT, SILENT_MP3, PKG_SOUND_POTPLAYER64_DPL, PKG_VIDEO_POTPLAYER64_DPL, MERGED_EXCEL_FILE, YES, NO, NOT_PREPARED_YET, PROJECT_D, project_release_server
from pkg_py.pk_interface_graphic_user import GuiUtil, get_display_info, print_as_gui, should_i_do
"""

    with open(file=f, mode='r', encoding=Encoding.UTF8.value) as f_obj:
        lines = f_obj.readlines()

    updated_lines = []
    function_stack = []  # 함수의 들여쓰기 레벨을 추적하기 위한 스택

    for line in lines:
        stripped_line = line.strip()

        # 함수 정의를 찾음
        if stripped_line.startswith("def ") and stripped_line.endswith(":"):
            current_indent = len(line) - len(line.lstrip())
            while function_stack and function_stack[-1] >= current_indent:
                function_stack.pop()

            if not function_stack:  # 최상위 함수인 경우
                updated_lines.append(line)
                # 함수의 첫 번째 줄에 lazy import 추가
                lazy_import_with_indent = "".join(
                    [" " * (current_indent + 4) + lazy_line + "\n" for lazy_line in lazy_import_code.strip().split("\n")]
                )
                updated_lines.append(lazy_import_with_indent)
            else:  # 중첩 함수는 처리하지 않음
                updated_lines.append(line)

            function_stack.append(current_indent)
        else:
            # 함수 블록에서 들여쓰기 레벨 유지
            current_indent = len(line) - len(line.lstrip())
            while function_stack and function_stack[-1] >= current_indent:
                function_stack.pop()

            updated_lines.append(line)

    # 새로운 f명 생성
    base_name, ext = os.path.splitext(f)
    output_file_path = f"{base_name}_lazyed_imported{ext}"

    # 수정된 내용을 새로운 f에 저장
    with open(file=output_file_path, mode='w', encoding=Encoding.UTF8.value) as f:
        f.writelines(updated_lines)

    print(f"수정된 f이 '{output_file_path}'에 저장되었습니다.")


def add_lazy_import_to_outter_functions(f: str):
    from pkg_py.pk_core_constants import Encoding
    from enum import Enum
    encoding: Enum
    import os

    lazy_import_code = """
import pk_core_constants
import inspect
import json
import os
import platform
import random
import re
import shutil
import string
import subprocess
import sys
import threading
import time
import traceback
import urllib
import webbrowser
import zipfile
from collections import Counter
from functools import partial
from typing import TypeVar, List
from urllib.parse import quote, urlparse
from zipfile import BadZipFile
import keyboard
import numpy as np
import pyaudio
import pygetwindow
import pyglet
import speech_recognition as sr
import tqdm
import win32con # pywin32
import win32gui # pywin32
import win32process
from dirsync import sync
from pkg_py.pk_colorful_cli_util import pk_print, pk_print, pk_print, pk_print, pk_print, print_magenta, print_light_white, ColoramaUtil, print_ment_via_colorama, print_success, prijnt_as_log, print_yellow  
from pkg_py.pk_core_constants import USERPROFILE, HOSTNAME, UNDERLINE, BLANK, BIGGEST_PNXS, SMALLEST_PNXS, PLAYING_SOUNDS, COUNTS_FOR_GUIDE_TO_SLEEP, [], VIDEO_IDS_ALLOWED, AUDIO_IDS_ALLOWED, STORAGE_VIDEOES_MERGED, PROJECT_PARENTS_D, DESKTOP, DOWNLOADS, PKG_PNG, PKG_DPL, PKG_TXT, \\
    CLASSIFYING, RECYCLE_BIN, LOCAL_PKG_CACHE_FILE, SUCCESS_LOG, YT_DLP_CMD, JQ_WIN64_EXE, \\
    FFMPEG_EXE, DB_YAML, USELESS_FILE_NAMES_TXT, SILENT_MP3, PKG_SOUND_POTPLAYER64_DPL, PKG_VIDEO_POTPLAYER64_DPL, MERGED_EXCEL_FILE, YES, NO, NOT_PREPARED_YET, PROJECT_D, project_release_server
from pkg_py.pk_interface_graphic_user import GuiUtil, get_display_info, print_as_gui, should_i_do
"""
    with open(file=f, mode='r', encoding=Encoding.UTF8.value) as f_obj:
        lines = f_obj.readlines()

    updated_lines = []
    function_stack = []  # 함수의 들여쓰기 레벨을 추적하기 위한 스택
    inside_function = False
    function_body = []

    def is_function_used(body_lines):
        import re
        """최상위 함수에서 호출된 코드가 있는지 확인"""
        for line in body_lines:
            # 함수 호출을 나타내는 '()'를 탐지
            if re.search(r'\w+\s*\(', line.strip()):
                return 1
        return 0

    for index, line in enumerate(lines):
        stripped_line = line.strip()

        # 함수 정의를 찾음
        if stripped_line.startswith("def ") and stripped_line.endswith(":"):
            if inside_function:
                # 이전 함수의 본문이 호출되지 않았으면 lazy import 생략
                if not is_function_used(function_body):
                    updated_lines = updated_lines[:-1]  # lazy import remove
                function_body = []  # 초기화
                inside_function = False

            current_indent = len(line) - len(line.lstrip())
            while function_stack and function_stack[-1] >= current_indent:
                function_stack.pop()

            if not function_stack:  # 최상위 함수인 경우
                updated_lines.append(line)
                lazy_import_with_indent = "".join(
                    [" " * (current_indent + 4) + lazy_line + "\n" for lazy_line in lazy_import_code.strip().split("\n")]
                )
                updated_lines.append(lazy_import_with_indent)
                inside_function = True
            else:  # 중첩 함수는 처리하지 않음
                updated_lines.append(line)

            function_stack.append(current_indent)
        elif inside_function:
            function_body.append(line)
            current_indent = len(line) - len(line.lstrip())
            while function_stack and function_stack[-1] >= current_indent:
                function_stack.pop()
            updated_lines.append(line)
        else:
            # 함수 블록 밖
            current_indent = len(line) - len(line.lstrip())
            while function_stack and function_stack[-1] >= current_indent:
                function_stack.pop()
            updated_lines.append(line)

    # 마지막 함수 처리
    if inside_function and not is_function_used(function_body):
        updated_lines = updated_lines[:-1]  # lazy import remove

    # 새로운 f명 생성
    f_n, f_x = os.path.splitext(f)
    f_new = f"{f_n}_lazyed_imported{f_x}"

    # 수정된 내용을 새로운 f에 저장
    with open(file=f_new, mode='w', encoding=Encoding.UTF8.value) as f:
        f.writelines(updated_lines)

    print(f"수정된 f이 '{f_new}'에 저장되었습니다.")


def add_lazy_import_to_functions(f: str):
    from pkg_py.pk_core_constants import Encoding
    from enum import Enum
    encoding: Enum

    import re
    import os

    def move_import_to_function_start(body_lines, indent_level):
        """본문 중간에 있는 import 문을 함수 시작 부분으로 이동"""
        imports = []
        non_import_lines = []
        for line in body_lines:
            if re.match(r'^\s*(import|from\s+\w+\s+import)\b', line.strip()):
                imports.append(line.strip())
            else:
                non_import_lines.append(line)
        # 적절한 들여쓰기를 적용한 import 문 생성
        formatted_imports = [f"{' ' * indent_level}{imp}\n" for imp in imports]
        return formatted_imports + non_import_lines

    with open(file=f, mode='r', encoding=Encoding.UTF8.value) as f_obj:
        lines = f_obj.readlines()

    updated_lines = []
    inside_function = False
    function_body = []
    function_indent = 0

    for line in lines:
        stripped_line = line.strip()
        indent_level = len(line) - len(stripped_line)

        if stripped_line.startswith("def ") and stripped_line.endswith(":"):
            if inside_function:
                # 함수 종료 시점 처리: import 정리
                cleaned_body = move_import_to_function_start(function_body, function_indent + 4)
                updated_lines.extend(cleaned_body)
                function_body = []

            # 새로운 함수 시작
            inside_function = True
            function_indent = indent_level
            updated_lines.append(line)
        elif inside_function:
            if indent_level <= function_indent and stripped_line:
                # 함수 종료 시점 처리
                cleaned_body = move_import_to_function_start(function_body, function_indent + 4)
                updated_lines.extend(cleaned_body)
                function_body = []

                # 새로운 블록이 시작된 경우
                inside_function = False
                updated_lines.append(line)
            else:
                function_body.append(line)
        else:
            updated_lines.append(line)

    # 마지막 함수 처리
    if inside_function:
        cleaned_body = move_import_to_function_start(function_body, function_indent + 4)
        updated_lines.extend(cleaned_body)

    # 결과 저장
    base_name, ext = os.path.splitext(f)
    output_f = f"{base_name}_lazyed_imported{ext}"

    with open(file=output_f, mode='w', encoding=Encoding.UTF8.value) as f:
        f.writelines(updated_lines)

    print(f"수정된 f이 '{output_f}'에 저장되었습니다.")


def run_f_n_as_script():  # todo : chore : add parameter
    from pkg_py.pk_core_constants import Encoding

    from pkg_py.pk_core_constants import D_PROJECT
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PKG_PY
    from pkg_py.pk_core_constants import D_PKG_CMD
    f_p = rf'{D_PKG_PY}'
    f_n = 'pk_save_chrome_youtube_cookies_to_f'
    f_pn_py = get_pnx_os_style(pnx=rf"{f_p}/{f_n}.py")
    f_pn_cmd = rf"{D_PKG_CMD}\{f_n}.cmd"
    activate_bat = rf'{D_PROJECT}\.venv\Scripts\activate.cmd'
    python_exe = rf'{D_PROJECT}\.venv\Scripts\python.exe'
    CRLF = '%%%CRLF%%%'
    script_str = rf'''
       :: @echo off{CRLF}
       chcp 65001 >nul{CRLF}
       title %~nx0{CRLF}   
       cls{CRLF}

       :: 관리자 권한 요청{CRLF}
       :: net session >nul 2>&1{CRLF}
       :: if %errorLevel% neq 0 ({CRLF}
       ::     powershell -Command "Start-Process python -ArgumentList '\"%~dp0myscript.py\"' -Verb RunAs"{CRLF}
       ::     exit /b{CRLF}
       :: ){CRLF}
       :: cls{CRLF}

       call "{activate_bat}"{CRLF}
       set PYTHONPATH={D_PROJECT}{CRLF}
       "{python_exe}" "{f_pn_py}"{CRLF}
     '''
    script_list = script_str.split(CRLF)
    script_list = get_list_replaced_element_from_str_to_str(working_list=script_list, from_str='    ', to_str='')
    ensure_pnx_made(pnx=f_pn_cmd, mode='f', script_list=script_list)
    pk_print(rf"set PYTHONPATH={D_PROJECT}", print_color='blue')
    # cmd_to_os(cmd=rf'notepad "{activate_bat}"')
    # cmd_to_os(cmd=rf'notepad "{f_pn_cmd}"')
    cmd_to_os(cmd=rf'start call "{f_pn_cmd}" ', encoding=Encoding.UTF8, mode='a')


def run_venv_in_cmd_exe():
    from pkg_py.pk_core_constants import Encoding
    from pkg_py.pk_core_constants import D_PROJECT
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PKG_PY
    from pkg_py.pk_core_constants import D_PKG_CMD
    f_p = rf'{D_PKG_PY}'
    f_n = 'pk_save_chrome_youtube_cookies_to_f'
    f_pn_py = get_pnx_os_style(pnx=rf"{f_p}/{f_n}.py")
    f_cmd = rf"{D_PKG_CMD}\{f_n}.cmd"
    activate_bat = rf'{D_PROJECT}\.venv\Scripts\activate.cmd'
    python_exe = rf'{D_PROJECT}\.venv\Scripts\python.exe'
    CRLF = '%%%CRLF%%%'
    script_str = rf'''
       :: @echo off{CRLF}
       chcp 65001 >nul{CRLF}
       title %~nx0{CRLF}   
       cls{CRLF}

       :: 관리자 권한 요청{CRLF}
       :: net session >nul 2>&1{CRLF}
       :: if %errorLevel% neq 0 ({CRLF}
       ::     powershell -Command "Start-Process python -ArgumentList '\"%~dp0myscript.py\"' -Verb RunAs"{CRLF}
       ::     exit /b{CRLF}
       :: ){CRLF}               
       :: cls{CRLF}

       call "{activate_bat}"{CRLF}
     '''
    script_list = script_str.split(CRLF)
    script_list = get_list_replaced_element_from_str_to_str(working_list=script_list, from_str='    ', to_str='')
    ensure_pnx_made(pnx=f_cmd, mode='f', script_list=script_list)
    pk_print(rf"set PYTHONPATH={D_PROJECT}", print_color='blue')
    # cmd_to_os(cmd=rf'notepad "{activate_bat}"')
    # cmd_to_os(cmd=rf'notepad "{f_pn_bat}"')
    cmd_to_os(cmd=rf'start call "{f_cmd}" ', encoding=Encoding.UTF8, mode='a')


def organize_d_list_by_stamp(d: str):
    """
    d 내에서 특정 stamp를 포함하는 _d_를 해당 stamp 이름의 _d_로 이동하는 함수.

    :param d: 탐색할 d 경로
    :param PROJECT_D: 프로젝트 d 경로 (stamp 목록을 불러올 f이 위치한 곳)
    """
    import os
    import re
    from pkg_py.pk_core_constants import D_PROJECT
    from pkg_py.pk_colorful_cli_util import pk_print
    working_list = get_list_from_f(f=rf'{D_PROJECT}\pkg_txt\collect_magnets_from_nyaa_si.txt')

    # 불필요한 항목 remove
    working_list = get_list_removed_element_contain_prompt(working_list=working_list, prompt="#")
    working_list = get_list_deduplicated(working_list=working_list)
    working_list = get_list_removed_element_empty(working_list=working_list)
    working_list = get_list_striped_element(working_list=working_list)

    # 정규식을 사용하여 stamp 리스트 추출
    pattern = re.compile(r"(\[.*?\])\s*(.*)")
    stamp_list = []

    for item in working_list:
        match = pattern.match(item)
        if match:
            stamp = match.group(1).strip()
            stamp_list.append(stamp)

    # 중복 remove
    stamp_list = get_list_deduplicated(working_list=stamp_list)

    # d 탐색 및 이동
    for root, d_nx_list, _ in os.walk(d):
        for d_nx in d_nx_list:
            for stamp in stamp_list:
                if d_nx != stamp and stamp in d_nx:  # _d_명이 stamp를 포함하는지 확인
                    d_stamp = os.path.join(root, stamp)  # stamp 이름의 d 경로 생성
                    os.makedirs(d_stamp, exist_ok=True)

                    d_src = os.path.join(root, d_nx)
                    d_dst = os.path.join(d_stamp, d_nx)
                    pk_print(f'''d_dst={d_dst} d_src={d_src}  {'%%%FOO%%%' if LTA else ''}''')
                    try:
                        os.rename(d_src, d_dst)
                    except:
                        pk_print(f'''d_dst does exists already. 아마도 이동 안할것 d_dst={d_dst}  {'%%%FOO%%%' if LTA else ''}''')  # todo : 동작 모니터링 필요


def get_f_changed_list_from_d_interested_list(d_interested_list, monitoring_interval=0.2, time_limit=None, change_cnt_limit=None):
    import time
    from pkg_py.pk_core_constants import D_DOWNLOADS

    import importlib

    # 모듈 자체를 먼저 import
    watchdog_observers = importlib.import_module("watchdog.observers")
    watchdog_events = importlib.import_module("watchdog.events")
    pkg_cli = importlib.import_module("pkg_py.interface_cmd_line")
    pkg_constants = importlib.import_module("pkg_py.constants")

    # 필요한 속성만 참조
    Observer = watchdog_observers.Observer
    FileSystemEventHandler = watchdog_events.FileSystemEventHandler
    pk_print = pkg_cli.pk_print
    DOWNLOADS = D_DOWNLOADS

    d_interested_list = [get_pnx_os_style(d) for d in d_interested_list]

    class FileChangeHandler(FileSystemEventHandler):
        def __init__(self, observer, change_cnt_limit=None):
            super().__init__()
            self.observer = observer  # Observer 인스턴스를 받아 저장
            self.f_changed_list = []
            self.f_change_level = 0
            self.change_cnt_limit = change_cnt_limit

        def on_created(self, event):
            pk_print(f"f_created={event.src_path}")
            self.f_changed_list.append(event.src_path)
            self.f_change_level += 1
            self.check_limit()

        def on_deleted(self, event):
            pk_print(f"f_deleted={event.src_path}")
            self.f_changed_list.append(event.src_path)
            self.f_change_level += 1
            self.check_limit()

        def on_modified(self, event):
            pk_print(f"f_modified={event.src_path}")
            self.f_changed_list.append(event.src_path)
            self.f_change_level += 1
            self.check_limit()

        def check_limit(self):
            if self.change_cnt_limit is not None and self.f_change_level >= self.change_cnt_limit:
                pk_print("Change limit reached. Stopping observer.")
                self.observer.stop()  # Stop the observer instead of raising an exception

    event_handler = FileChangeHandler(change_cnt_limit)
    observer = Observer()

    for d in d_interested_list:
        observer.schedule(event_handler, d, recursive=True)

    pk_print(rf"[DETECT F_CHANGED LOOP STARTED] monitoring_interval={monitoring_interval}, len(d_interested_list)={len(d_interested_list)}", print_color='blue')

    observer.start()
    start_time = time.time()

    try:
        while 1:
            if time_limit is not None and (time.time() - start_time > time_limit):
                break
            pk_sleep(seconds=monitoring_interval)
    except StopIteration:
        pass
    except KeyboardInterrupt:
        pk_print("Monitoring stopped by user.")

    observer.stop()
    observer.join()

    return event_handler.f_changed_list


# [def is]
def is_d(pnx):  # item_pnx
    if not is_f(pnx):
        return 1
    else:
        return 0


def is_f(pnx):
    import os
    if os.path.isfile(pnx):
        return 1
    else:
        return 0


def is_empty_d(d_src, debug_mode=True):
    import os
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    try:
        if len(os.listdir(d_src)) == 0:
            return 1
        else:
            return 0
    except:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        return None


def is_pattern_in_prompt(prompt: str, pattern: any, with_case_ignored=True):
    import inspect
    import re
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import UNDERLINE
    # pk_print(string = rf'''string="{string}"  {'%%%FOO%%%' if LTA else ''}''')
    # pk_print(string = rf'''regex="{regex}"  {'%%%FOO%%%' if LTA else ''}''')
    func_n = inspect.currentframe().f_code.co_name
    pk_print(working_str=rf'''{UNDERLINE}{func_n}()  {'%%%FOO%%%' if LTA else ''}''')
    if with_case_ignored == True:
        pattern = re.compile(pattern, re.IGNORECASE)
    else:
        pattern = re.compile(pattern)
    m = pattern.search(prompt)
    if m:
        # pk_print("function name   here here here")
        # pk_print(rf"contents: {contents}")
        # pk_print(rf"regex: {regex}")
        # pk_print(rf"True")
        return 1
    else:
        # pk_print(rf"contents: {contents}")
        # pk_print(rf"regex: {regex}")
        # pk_print(rf"False")
        return 0


def is_os_wsl_linux():
    # todo : detect wsl.exe
    from pkg_py.pk_colorful_cli_util import pk_print
    if does_pnx_exist(pnx='/mnt/c/Users'):
        if LTA:
            pk_print(f'''wsl os is detected {'%%%FOO%%%' if LTA else ''}''')
        return 1
    else:
        return 0


def is_os_windows():
    from pkg_py.pk_colorful_cli_util import pk_print_once
    import platform
    if platform.system() == 'Windows':
        if LTA:
            pk_print_once(f'''windows is detected {'%%%FOO%%%' if LTA else ''}''')
        return 1
    else:
        if LTA:
            pk_print_once(f'''windows is not detected {'%%%FOO%%%' if LTA else ''}''')
        return 0


def is_number_v2(prompt: str):
    try:
        float(prompt)  # 숫자 형태로 변환을 시도
        return 1
    except ValueError:
        return 0


def is_current_hostname(hostname):
    from pkg_py.pk_colorful_cli_util import pk_print

    current_hostname = get_hostname()
    pk_print(working_str=rf'''hostname="{hostname}"  {'%%%FOO%%%' if LTA else ''}''')
    pk_print(working_str=rf'''current_hostname="{current_hostname}"  {'%%%FOO%%%' if LTA else ''}''')
    if current_hostname == hostname:
        return 1
    else:
        return 0


def is_prompt_on_screen(prompt):
    # OCR을 통해 텍스트 추출
    screenshot = get_screenshot()
    extreact_texts = get_extreact_texts_from_image_via_easyocr(screenshot)
    text_extracted = " ".join([r[1] for r in extreact_texts])

    if is_prompt_in_text(prompt=prompt, text=text_extracted):
        return 1
    else:
        return 0


def is_wsl_distro_started(wsl_distro_n):
    from pkg_py.pk_colorful_cli_util import pk_print
    cmd = rf'wsl -l -v'
    std_list = cmd_to_os(cmd=cmd, encoding='utf-16')
    std_list = get_list_removed_by_removing_runtine(working_list=std_list)
    signiture = wsl_distro_n
    signiture2 = 'Running'
    for line in std_list:
        if signiture in line:
            if signiture2 in line:
                if LTA:
                    pk_print(f'''{wsl_distro_n} is started in wsl {'%%%FOO%%%' if LTA else ''}''', print_color='green')
                return 1
    return 0


def is_wsl_distro_installed(wsl_distro_n):
    from pkg_py.pk_colorful_cli_util import pk_print
    cmd = rf'wsl -l -v'
    std_list = cmd_to_os(cmd=cmd, encoding='utf-16')
    std_list = get_list_removed_by_removing_runtine(working_list=std_list)
    pk_print(rf'''type(lines) = "{type(std_list)}"''')
    pk_print(f'''lines = {std_list}''')
    pk_print(rf'''len(lines) = "{len(std_list)}"''')
    for line in std_list:
        if wsl_distro_n in line:
            pk_print(f'''"{wsl_distro_n} is installed"''', print_color="green")
            return 1
    pk_print(f'''"{wsl_distro_n} is not installed"''', print_color='red')
    return 0


def is_newyear():
    yyyy = get_time_as_('%Y')
    state_yearly = None
    if is_month(mm=1) and is_day(dd=1):
        return 1
    else:
        return 0


def is_christmas():
    yyyy = get_time_as_('%Y')
    if is_month(mm=12) and is_day(dd=25):
        return 1
    else:
        return 0


def is_same_time(time1, time2):
    time2.strftime(rf'%Y-%m-%d %H:%M:%S')
    if LTA:
        print(rf'time1 : {time1} , time2 : {time2}')
    if time1 == time2:
        return 1
    else:
        return 0


def is_midnight():
    from datetime import datetime
    now = datetime.now()
    if now.hour == 0 and now.minute == 0 and now.second == 0:
        return 1
    else:
        return 0


def is_void_function(func):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    """
        함수가 void 함수인지 아닌지 판단하는 함수입니다.

        Args:
          function: 함수

        Returns:
          함수가 void 함수이면 True, 아니면 False
    """
    function_code = func.__code__
    return function_code.co_argcount == 0 and function_code.co_flags & 0x20 == 0


# def is_f_changed(f):
#     key=DbTomlUtil.get_db_toml_key(f)
#
#     # 기존에 측정된 f의 줄 수 : 없으면 새로 측정된 f의 줄 수로 대신함.
#     line_cnt_from_db=DbTomlUtil.select_db_toml(key=key)
#     if line_cnt_from_db is None:
#         DbTomlUtil.insert_db_toml(key=key, value=get_line_cnt_of_file(f))  # 50000 줄의 str 다루는 것보다 50000 개의 list 다루는 것이 속도성능에 대하여 효율적이다.
#         line_cnt_from_db=DbTomlUtil.select_db_toml(key=key)
#     pk_print(f"line_cnt_from_db : {line_cnt_from_db}", print_color='blue)
#
#     line_cnt_measured=get_line_cnt_of_file(f)
#     pk_print(f"line_cnt_measured : {line_cnt_measured}", print_color='blue)
#
#     if is_file_edited(f) is None:
#         pk_print("데이터베이스 타겟에 대한 key가 없어 key를 생성합니다")
#     elif is_file_edited(f):
#         ment=f'모니터링 중 편집을 감지하였습니다.\n{os.path.basename(f)}\n 타겟백업을 시도합니다.\n 타겟에 대한 key를 toml 데이터베이스에 업데이트합니다.'
#         GuiUtil.pop_up_as_complete(title_="모니터링감지보고", ment=ment, auto_click_positive_btn_after_seconds=3)
#
#     # db crud 관련된 로직 분리
#     if is_file_edited(f):
#         DbTomlUtil.update_db_toml(key=key, value=get_line_cnt_of_file(f))
#     elif is_file_edited(f) is None:
#         DbTomlUtil.insert_db_toml(key=key, value=get_line_cnt_of_file(f))
#     if is_file_edited(f):
#         return 1


# def is_file_edited(pnx_todo: str):
#     func_n=inspect.currentframe().f_code.co_name
#     try:
#         key=DbTomlUtil.get_db_toml_key(pnx_todo)
#         db=DbTomlUtil.read_db_toml()
#         line_cnt_measured=get_line_cnt_of_file(pnx_todo)
#         if line_cnt_measured != db[key]:
#             pk_print("f편집 감지되었습니다")
#         else:
#             pk_print("f편집 감지되지 않았습니다")
#             pass
#         if line_cnt_measured != db[key]:
#             return 1
#         else:
#             return 0
#     except KeyError:
#         DbTomlUtil.insert_db_toml(key=DbTomlUtil.get_db_toml_key(pnx_todo), value=get_line_cnt_of_file(pnx_todo))
#         pk_print("f편집 확인 중 key 에러가 발생하였습니다")
#     except Exception:  # except Exception:으로 작성하면 KeyError 를 뺀 나머지 에러처리 설정 , except: 를 작성하면 모든 에러처리 설정
#         pk_print("데이터베이스 확인 중 예상되지 않은 에러가 감지되었습니다")
#         pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')

# def is_empty_tree(d, debug_mode):
#     import traceback
#     import os
#     from pkg_py.pk_colorful_cli_util import pk_print, pk_print
#     pk_print(f'''d={d}  {'%%%FOO%%%' if LTA else ''}''')
#     try:
#         contents = os.listdir(d)
#         for content in contents:
#             # [print(rf'content : {content}') for content in contents]
#             content_path = os.path.join(d, content)
#             if is_f(content_path):
#                 pk_print("is not empty d")
#                 return 0
#         pk_print("is not empty d 있니다.")
#         return 1
#     except:
#         pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')

def is_empty_tree(d):
    import os
    from pkg_py.pk_colorful_cli_util import pk_print

    pk_print(f"d={d}  {'%%%FOO%%%' if LTA else ''}")

    try:
        with os.scandir(d) as entries:
            for entry in entries:
                if entry.is_file():
                    pk_print(rf"is not empty d {d}")
                    return 0
        pk_print(rf"is not empty d 있습니다.{d}")
        return 1
    except:
        # pk_print(f"{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}", print_color='red')
        return 0


def is_leaf_d(d):
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    import os
    pk_print(f'''d={d}  {'%%%FOO%%%' if LTA else ''}''')
    try:
        contents = os.listdir(d)
        if len(contents) > 0:
            return 0
        for content in contents:
            pnx = os.path.join(d, content)
            if is_d(pnx):
                return 0
        return 1
    except:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')


def is_letters_cnt_zero(f):
    import traceback
    from pkg_py.pk_core_constants import Encoding
    from pkg_py.pk_colorful_cli_util import pk_print
    try:
        with open(file=f, mode='r') as file:
            contents = file.read().strip()
            # print(rf'len(contents) : {len(contents)}')
            if len(contents) == 0:
                return 1
    except FileNotFoundError:
        pk_print(working_str="f을 찾을 수 없습니다.")
        return 0
    except UnicodeDecodeError:

        with open(file=f, mode='r', encoding=Encoding.UTF8.value) as file:
            contents = file.read().strip()
            # print(rf'len(contents) : {len(contents)}')
            if len(contents) == 0:
                return 1
        return 0
    except:
        pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        pk_print(working_str="오류가 발생했습니다.")
        return 0


def is_validated(target: any):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    if target is None:
        return 0
    if target == "":
        return 0
    if is_pattern_in_prompt(prompt=target, pattern=r'[^a-zA-Z0-9가-힣\s]', with_case_ignored=False):  # 특수문자 패턴 정의( 알파벳, 숫자, 한글, 공백을 제외한 모든 문자)
        return 0
    else:
        return 1


# def guide_user_input_intended_by_developer(user_input: str):
def is_user_input_required(user_input: str):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    # 수정 필요.
    user_input = user_input.strip()
    pk_print(working_str=rf'''user_input="{user_input}"  {'%%%FOO%%%' if LTA else ''}''')
    if is_only_no(user_input):
        user_input = int(user_input)
    else:
        pk_speak_v2("you can input only number, please input only number again", comma_delay=0.98)
        return None
    return user_input


def is_keyboard_pressed_within_time_limit(key_plus_key: str, time_limit):
    import inspect
    import time
    import keyboard
    from pkg_py.pk_colorful_cli_util import pk_print
    # time_limit 이 아니라 트리거로 ESC 눌렸을 때 종료되도록 하는 함수가 더 유용하겠다.
    func_n = inspect.currentframe().f_code.co_name
    time_s = time.time()
    keys = key_plus_key.split("+")
    waiting_limit = 30
    while 1:
        if all(keyboard.is_pressed(key) for key in keys):
            # 단축키 조합이 모두 눌렸을 때 exec 할 코드
            pk_print(f"{keys[0]}+{keys[1]}", print_color='blue')
            return 1
        else:
            pk_print(f"{key_plus_key} 눌릴때까지 기다리고 있습니다")
            time_e = time.time()
            time_diff = time_e - time_s
            if time_diff == time_limit:
                return 0
            pk_sleep(milliseconds=waiting_limit)


def is_mouse_button_click_within_time_limit(key="left", time_limit=10):
    from pynput import mouse
    if key == "left":
        listener = mouse.Listener(on_click=on_left_click)
    elif key == "right":
        listener = mouse.Listener(on_click=on_right_click)
        # listener=mouse.Listener(on_click=on_right_click())
    listener.start()  # Listener 시작
    listener.join(time_limit)  # 주어진 시간 동안 대기
    listener.stop()  # Listener 종료

    return click_detected  # 클릭 감지 여부 반환


def is_containing_special_characters(text: str, ignore_list: [str] = None):
    import re
    pattern = "[~!@#$%^&*()_+|<>?:{}]"  # , 는 제외인가?
    if ignore_list is not None:
        for exception in ignore_list:
            pattern = pattern.replace(exception, "")
    if re.search(pattern, text):
        return 1


def is_losslesscut_playing(threshold=5.0, check_duration=3, second_interval=1):
    from pkg_py.pk_colorful_cli_util import pk_print
    import time
    cpu_usages = []

    for _ in range(check_duration):
        cpu_usage = get_cpu_usage(interval=1.0, process_n="LosslessCut")
        if cpu_usage is None:
            pk_print(f'''cpu_usage is None''', print_color='red')
            return 0  # exec  중이 아니면 False

        cpu_usages.append(cpu_usage)
        print(f"📊 CPU 사용량 측정: {cpu_usage}%")
        time.sleep(second_interval)  # 1초 간격으로 CPU 측정

    avg_cpu = sum(cpu_usages) / len(cpu_usages)  # 평균 CPU 사용량 계산
    print(f"📈 평균 CPU 사용량: {avg_cpu}%")

    return avg_cpu > threshold  # 설정한 임계값보다 높으면 "Playing" 상태로 판단


def is_f_locked(f):
    try:
        with open(f, 'r+'):
            return 0
    except IOError:
        return 1


# [def rename]
def rename_pnx(src, pnx_new):
    import os
    import time
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    # 이름을 변경하는 경우에 재귀적으로 바뀌어야 하는 것으로 생각되어 os.renames 를 테스트 후 적용하였다.
    # os.rename 사용 중에 d  인 경우는 재귀적으로 변경이 안된다
    try:
        if not does_pnx_exist(pnx=src):
            pk_print(f'''rename 할 f이 없습니다 {src}''', print_color='red')
            return

        if src == pnx_new:
            pk_print(f'''현재f명 과 바꾸려는f명 이 같아 rename 하지 않았습니다 src={src} pnx_new={pnx_new}''')
            return

        if does_pnx_exist(pnx=pnx_new):
            pk_print(f'''dst에 중복된 f이 있습니다. {pnx_new}" ''', print_color='red')
            return

        if is_f(src):
            type_name = "f"
        else:
            type_name = "d"

        os.renames(src, pnx_new)
        time_limit = 3
        waiting_limit = 20
        time_s = time.time()
        while 1:
            if does_pnx_exist(pnx=pnx_new):
                pk_print(f'''rename {type_name} from {src} to {pnx_new}''', print_color='green')
                break
            else:
                time_e = time.time()
                time_diff = time_e - time_s
                if time_diff == time_limit:
                    return 0
                pk_sleep(milliseconds=waiting_limit)
    except:
        pk_print(working_str=rf'''traceback.format_exc()="{traceback.format_exc()}" rename 확인필요 src={src} pnx_new={pnx_new}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')


def rename_pnx_list_at_d(d_working, mode, with_walking, debug_mode=False):
    from pkg_py.pk_colorful_cli_util import pk_print
    pk_print(working_str=rf'''d="{d_working}" mode="{mode}"  {'%%%FOO%%%' if LTA else ''}''')

    rename_pnxs_from_keywords_to_keyword_new_at_d(d=d_working, mode=mode, with_walking=with_walking)
    rename_pnxs_from_pattern_to_pattern_new_via_routines_at_d(d=d_working, mode=mode, with_walking=with_walking)
    rename_pnxs_from_keywords_to_keyword_new_at_d(d=d_working, mode=mode, with_walking=with_walking)


# def install
def install_chrome_remote_desktop_server_to_remote_os(users, ip, remote_os_distro_n, wsl_window_title_seg, pw, exit_mode):
    # ssh_in_wsl(users=users, ip=ip, remote_os_distro_n=remote_os_distro_n, wsl_window_title_seg=wsl_window_title_seg, pw=pw, exit_mode=exit_mode)
    #
    # # Update package list
    # cmd_to_wsl_os_like_person('sudo apt update')
    #
    # # Install wget
    # cmd_to_wsl_os_like_person('sudo apt install wget')
    #
    # # Download Google Chrome .deb package
    # cmd_to_wsl_os_like_person('wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb')
    #
    # # Install Google Chrome
    # cmd_to_wsl_os_like_person('sudo apt install ./google-chrome-stable_current_amd64.deb')
    pass


def install_wsl_distro(wsl_distro_n):
    std_list = cmd_to_os(cmd=f'wsl --install -d {wsl_distro_n}')


def ensure_wsl_distro_installed(wsl_distro_n):
    from pkg_py.pk_colorful_cli_util import pk_print
    if is_os_windows():
        if not is_os_wsl_linux():
            if not is_wsl_distro_installed(wsl_distro_n=wsl_distro_n):
                install_wsl_distro(wsl_distro_n=wsl_distro_n)
                if not is_wsl_distro_installed(wsl_distro_n=wsl_distro_n):
                    pk_print(rf"{wsl_distro_n} install  {'%%%FOO%%%' if LTA else ''}", print_color='red')
                    raise


def move_pnx_list_to_trash_bin(pnx_list):
    for pnx in pnx_list:
        if does_pnx_exist(pnx):
            move_pnx_to_pk_recycle_bin(pnx=pnx)


def check_min_non_null_or_warn(*args, func_n="UNKNOWN", arg_none_required=1):
    from pkg_py.pk_colorful_cli_util import pk_print
    non_null_count = sum(arg is not None for arg in args)
    if non_null_count < arg_none_required:
        pk_print(
            rf"{func_n}() 동작 조건 불충족 (요구 조건: 최소 {arg_none_required}개, 현재 {non_null_count}개)  {'%%%FOO%%%' if LTA else ''}",
            print_color='red'
        )
        return False
    return True


def move_window_to_front_via_pid(pid):
    import inspect
    import win32gui
    import win32process
    import win32con
    import psutil
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    if not str(pid).isdigit():
        pk_print(f"[{func_n}()] PID가 숫자가 아닙니다: {pid}", print_color='red')
        return
    pid = int(pid)
    try:
        process = psutil.Process(pid)
        if not (process.is_running() and process.status() != psutil.STATUS_ZOMBIE):
            pk_print(f"[{func_n}()] 프로세스가 실행 중이 아니거나 좀비 상태입니다", print_color='red')
            return

        def enum_handler(hwnd, result):
            try:
                _, hwnd_pid = win32process.GetWindowThreadProcessId(hwnd)
                if hwnd_pid == pid and win32gui.IsWindowVisible(hwnd):
                    result.append(hwnd)
            except Exception:
                pass

        hwnd_list = []
        win32gui.EnumWindows(enum_handler, hwnd_list)
        if not hwnd_list:
            pk_print(f"[{func_n}()] PID {pid}에 연결된 창이 없습니다", print_color='red')
            return
        hwnd = hwnd_list[0]
        if win32gui.IsIconic(hwnd):
            win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)
        # 포그라운드로 이동
        win32gui.SetForegroundWindow(hwnd)
        win32gui.BringWindowToTop(hwnd)
        pk_print(f"[{func_n}()] PID {pid}의 창을 앞으로 가져왔습니다", print_color='green')
    except psutil.NoSuchProcess:
        pk_print(f"[{func_n}()] 유효하지 않은 PID입니다: {pid}", print_color='red')
    except Exception as e:
        pk_print(f"[{func_n}()] 알 수 없는 오류: {e}", print_color='red')


def ensure_window_to_front_v1(window_title_seg=None, pid=None):
    import inspect
    import win32gui  # pywin32
    import win32process
    from pkg_py.pk_colorful_cli_util import pk_print
    import psutil
    func_n = inspect.currentframe().f_code.co_name
    pk_print(f'''func_n={func_n} {'%%%FOO%%%' if LTA else ''}''')
    if window_title_seg is not None:
        pk_print(rf'''window_title_seg="{window_title_seg}"{'%%%FOO%%%' if LTA else ''}''')
        while 1:
            move_window_to_front_via_window_title_seg_based(window_title_seg)
            if is_front_window_title(window_title_seg=window_title_seg):
                pk_print(f'''move window (window_title_seg={window_title_seg}) to front via {func_n}()''', print_color='green')
                break
    if pid is not None:
        pk_print(rf'''pid="{pid}"{'%%%FOO%%%' if LTA else ''}''')
        if not str(pid).isdigit():
            # pk_print(f"PID 분석 결과 숫자가 아닌 것으로 판단: {pid}  {'%%%FOO%%%' if LTA else ''}", print_color='red')
            return
        pid = int(pid)
        try:
            # PID에 해당하는 프로세스 객체 가져오기
            process = psutil.Process(pid)

            if process.is_running() and process.status() != psutil.STATUS_ZOMBIE:
                hwnd = win32gui.FindWindow(None, None)  # 첫 번째 창 핸들을 가져옴

                # PID와 연결된 창 핸들을 검색
                while hwnd:
                    _, found_pid = win32process.GetWindowThreadProcessId(hwnd)

                    # 검색된 창의 PID가 입력 PID와 일치하면 창 활성화
                    if found_pid == pid:
                        try:
                            win32gui.SetForegroundWindow(hwnd)  # 창 활성화
                            # pk_print(f"PID {pid}의 창을 활성화했습니다.", print_color='blue')
                            break
                        except Exception as e:
                            # pk_print(f"창 활성화 실패: {e}", print_color='red')
                            pass
                    # 다음 창 핸들 검색
                    hwnd = win32gui.FindWindowEx(None, hwnd, None, None)
                else:
                    # pk_print(f"PID {pid}에 해당하는 창 핸들을 찾을 수 없습니다.", print_color='red')
                    pass
            else:
                # pk_print(f"{UNDERLINE}프로세스가 exec  중이지 않거나 좀비 상태입니다.", print_color='red')
                pass
        except psutil.NoSuchProcess:
            # pk_print(f"{UNDERLINE}유효하지 않은 PID입니다.", print_color='red')
            pass
        except Exception as e:
            pk_print(f"알 수 없는 {e}", print_color='red')
            pass


def ensure_window_to_front_v2(window_title_seg=None, pid=None):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    pk_print(f'''func_n={func_n} {'%%%FOO%%%' if LTA else ''}''')
    # window_title_seg 기반 제어
    if window_title_seg:
        move_window_to_front_via_window_title_seg_based(window_title_seg)
    # PID 기반 제어
    if pid is not None:
        move_window_to_front_via_pid(pid)


def ensure_window_to_front(window_title_seg=None, pid=None):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    pk_print(f'''func_n={func_n} {'%%%FOO%%%' if LTA else ''}''')
    if not check_min_non_null_or_warn(window_title_seg, pid, func_n=func_n, arg_none_required=1):
        # raise
        return
    # ensure_window_to_front_v0(window_title_seg=window_title_seg, pid=pid)
    # ensure_window_to_front_v1(window_title_seg=window_title_seg, pid=pid)
    ensure_window_to_front_v2(window_title_seg=window_title_seg, pid=pid)


def ensure_window_to_front_v0(window_title_seg=None, pid=None):
    import inspect
    import traceback
    import win32con  # pywin32
    import win32gui  # pywin32
    import win32process
    from pkg_py.pk_colorful_cli_util import pk_print
    import psutil
    func_n = inspect.currentframe().f_code.co_name
    if window_title_seg is not None:
        while 1:
            window_title = get_window_title(window_title_seg=window_title_seg)
            if is_window_title_opened(window_title=window_title):
                if not is_window_title_front(window_title=window_title):
                    import pywintypes
                    try:
                        def enum_windows_callback(hwnd, lparam):
                            if win32gui.IsWindowVisible(hwnd):
                                current_window_title = win32gui.GetWindowText(hwnd)
                                if window_title.lower() in current_window_title.lower():
                                    win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)
                                    pk_sleep(seconds=0.2)
                                    try:
                                        win32gui.SetForegroundWindow(hwnd)  # 창을 제일 앞으로 가져옴
                                    except Exception as e:
                                        pk_sleep(seconds=0.2)
                                        pk_print(f''' can not move window ({window_title}) to front.''', print_color='red')
                                        win32gui.SetForegroundWindow(hwnd)
                                    return 0  # 더 이상 검색하지 않음
                            return 1  # 계속 검색

                        try:
                            win32gui.EnumWindows(enum_windows_callback, None)
                        except pywintypes.error:
                            # pk_print(f"{traceback.format_exc()}", print_color='red')
                            pass
                    except Exception as e:
                        pk_print(f"{traceback.format_exc()}", print_color='red')
                if is_window_title_front(window_title=window_title):
                    pk_print(f'''move window ({window_title}) to front via {func_n}()''', print_color='blue')
                    break
            else:
                return
    if pid is not None:
        if not str(pid).isdigit():
            # pk_print(f"PID 분석 결과 숫자가 아닌 것으로 판단: {pid}  {'%%%FOO%%%' if LTA else ''}", print_color='red')
            return
        pid = int(pid)
        try:
            # PID에 해당하는 프로세스 객체 가져오기
            process = psutil.Process(pid)
            if process.is_running() and process.status() != psutil.STATUS_ZOMBIE:
                hwnd = win32gui.FindWindow(None, None)  # 첫 번째 창 핸들을 가져옴
                while hwnd:
                    _, found_pid = win32process.GetWindowThreadProcessId(hwnd)
                    if found_pid == pid:
                        try:
                            win32gui.SetForegroundWindow(hwnd)  # 창 활성화
                            break
                        except Exception as e:
                            # pk_print(f"창 활성화 실패: {e}", print_color='red')
                            pass
                    # 다음 창 핸들 검색
                    hwnd = win32gui.FindWindowEx(None, hwnd, None, None)
                else:
                    # pk_print(f"PID {pid}에 해당하는 창 핸들을 찾을 수 없습니다.", print_color='red')
                    pass
            else:
                # pk_print(f"{UNDERLINE}프로세스가 exec  중이지 않거나 좀비 상태입니다.", print_color='red')
                pass
        except psutil.NoSuchProcess:
            # pk_print(f"{UNDERLINE}유효하지 않은 PID입니다.", print_color='red')
            pass
        except Exception as e:
            pk_print(f"알 수 없는 {e}", print_color='red')
            pass


def move_window_to_front_of_pycharm():
    from pkg_py.pk_colorful_cli_util import pk_print
    # pycharm64.exe 에 열린 탭으로 이동해야하는데
    try:
        pids = get_pids(process_img_n="pycharm64.exe")
        for pid in pids:
            ensure_window_to_front(pid=pid)
    except:
        pk_print(working_str=rf'''{'%%%FOO%%%' if LTA else ''}''', print_color='red')
    # move_and_ensure_window_to_front(window_title_seg='pk_system_ – test.py')


def move_window_to_front_via_window_title_seg_based(window_title_seg):
    import traceback
    import win32con  # pywin32
    import pywintypes
    import inspect
    import win32gui  # pywin32
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    pk_print(f'''func_n={func_n} {'%%%FOO%%%' if LTA else ''}''')
    try:
        def enum_windows_callback(hwnd, lparam):
            if win32gui.IsWindowVisible(hwnd):
                current_window_title = win32gui.GetWindowText(hwnd)
                if window_title_seg.lower() in current_window_title.lower():
                    # 창을 전면에 표시하려면 먼저 ShowWindow 호출 후 SetForegroundWindow 호출
                    win32gui.ShowWindow(hwnd, win32con.SW_RESTORE)  # 최소화된 창 복원
                    pk_sleep(seconds=0.2)  # 창 복원 후 잠시 대기
                    # SetForegroundWindow를 재시도
                    try:
                        win32gui.SetForegroundWindow(hwnd)  # 창을 제일 앞으로 가져옴
                    except Exception as e:
                        # pk_print(f'''f"SetForegroundWindow 호출 재시도 Error: {str(e)}""''')
                        pk_sleep(seconds=0.2)  # 잠시 대기 후 재시도
                        # pk_print(f'''f"win32gui.SetForegroundWindow(hwnd) 호출 재시도{str(e)}"" ''', print_color='red')
                        win32gui.SetForegroundWindow(hwnd)  # 재시도
                    return 0  # 더 이상 검색하지 않음
            return 1  # 계속 검색

        try:
            win32gui.EnumWindows(enum_windows_callback, None)
        except pywintypes.error:
            # pk_print(f"{traceback.format_exc()}", print_color='red')
            pass
    except Exception as e:
        pk_print(f"{traceback.format_exc()}", print_color='red')


# [def get]
def get_hostname_v1():
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    lines = cmd_to_os_like_person_as_admin('hostname')
    for line in lines:
        line = line.strip()
        return line


def get_os_sys_environment_variable(environment_variable_n: str):
    import inspect
    import os
    func_n = inspect.currentframe().f_code.co_name
    return os.environ.get(environment_variable_n)


def get_list_reversed(working_list):
    working_list.reverse()
    return working_list


def get_name_space():  # name space # namespace # 파이썬 네임스페이스
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    dir()
    return dir()


def get_two_list_splited_pattern_and_patternless(items, pattern):
    import inspect
    import re
    func_n = inspect.currentframe().f_code.co_name
    pnx_list_required_pattern = []
    pnx_list_required_patternless = []

    for item in items:
        match = re.match(pattern, item)  # 정규식에 맞는 부분 찾기
        if match:
            pnx_list_required_pattern.append(match.group(1))  # magnet 부분
            pnx_list_required_patternless.append(match.group(2))  # f명 부분

    return pnx_list_required_pattern, pnx_list_required_patternless


def get_df_from_issues_list_csv_deprecated():
    from pkg_py.pk_core_constants import D_HOME
    # 경로
    Downloads = rf"{D_HOME}/Downloads"
    issues_list_csv = rf"{D_HOME}/Downloads/Issues_list.csv"
    issues_list_csv_alternative = rf"{D_HOME}/Downloads/deprecated/Issues_list.csv"

    import pandas as pd
    df = None
    pnx = issues_list_csv
    if does_pnx_exist(pnx):
        df = pd.read_csv(filepath_or_buffer=pnx)
    else:
        pnx = issues_list_csv_alternative
        if does_pnx_exist(pnx):
            df = pd.read_csv(filepath_or_buffer=pnx)
    move_pnx(pnx=pnx, d_dst=Downloads, with_overwrite=1)
    return df


def get_df_from_issues_list_csv(issues_list_csv):
    import pandas as pd
    from pkg_py.pk_core_constants import D_DOWNLOADS

    alternative_csv_pnx = get_pnx_os_style(rf"{D_DOWNLOADS}/deprecated/Issues_list.csv")
    issues_list_csv = get_pnx_os_style(issues_list_csv)
    # CSV f 로드
    for pnx in [issues_list_csv, alternative_csv_pnx]:
        pnx_unix = get_pnx_unix_style(pnx)
        if does_pnx_exist(pnx_unix):
            df = pd.read_csv(filepath_or_buffer=pnx_unix)
            if does_pnx_exist(pnx_unix):
                move_pnx(pnx=pnx_unix, d_dst=alternative_csv_pnx, with_overwrite=1)
            return df
    return None


def get_nth_row(df, n):
    from pkg_py.pk_colorful_cli_util import pk_print
    # n번째 줄만 가져오기
    if n >= 0 and n <= len(df):
        return df.iloc[n]  # n번째 행
    else:
        pk_print(working_str="유효하지 않은 행 번호입니다.")
        return None


def get_dict_removed_element_duplicated(item_dict):
    seen_values = set()
    unique_dict = {}
    for key, value in item_dict.items():
        if value not in seen_values:
            unique_dict[key] = value
            seen_values.add(value)
    return unique_dict


def get_url_list_encoded_element(working_list):
    import urllib.parse
    from pkg_py.pk_colorful_cli_util import pk_print
    pk_print(f'''working_list={working_list}  {'%%%FOO%%%' if LTA else ''}''', print_color="blue")
    return [urllib.parse.quote(item) for item in working_list]


def get_set_from_list(working_list):
    return set(working_list)


def get_webdriver_options_customed(browser_debug_mode=True, proxy=None):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    from selenium.webdriver.chrome.options import Options
    func_n = inspect.currentframe().f_code.co_name

    # options=webdriver.ChromeOptions()
    options = Options()

    if proxy is not None:
        options.add_argument(f'--proxy-server={proxy}')

    # 브라우저 최대화
    # options.add_argument("--start-maximized")

    # 셀레니움 브라우저 show 설정
    if browser_debug_mode == True:
        # options.add_argument('--headless')
        pass
    elif browser_debug_mode == False:
        options.add_argument('--headless')
    # options.add_argument('--window-size=3440x1440')
    # options.add_argument('--window-size=1920x1080')
    # options.add_argument("window-size=1200x600")
    # options.add_argument("window-size=1210x630")
    # options.add_argument('--window-size=800x800')
    # size 하드코딩 되어 있는 부분을 pyautogui 에서 size() 로 대체하는 것이 좋겠다.

    # 셀레니움 브라우저 언어
    options.add_argument("lang=ko_KR")

    # init my_chrome_version
    # https://www.whatismybrowser.com/detect/what-is-my-user-agent/ # IP 차단됨
    # https://detectmybrowser.com/ # 대안
    my_chrome_version = "131"

    # init UserAgent
    user_agent = rf"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/{my_chrome_version}.0.0.0 Safari/537.36"

    # init UserAgent , as random
    # 쓸려면 구체적으로 설정
    # ua = UserAgent()
    # user_agent = ua.chrome.replace("en-US", "ko-KR")  # 랜덤 최신 크롬 User-Agent, 생성된 User-Agent에서 언어를 한국어로 변경
    options.add_argument(f"user-agent={user_agent}")
    pk_print(f'''user_agent={user_agent}''')

    # 자동화 감지 비활성화
    options.add_argument("--disable-blink-features=AutomationControlled")

    # 자동화 스위치 비활성화
    options.add_experimental_option("excludeSwitches", ["enable-automation"])

    # 자동화 확장 비활성화
    options.add_experimental_option("useAutomationExtension", False)

    # Chrome 기본 프로필
    # profile_path=rf'{USERPROFILE}\AppData\Local\Google\Chrome\User Data'
    # options.add_argument(f"user-data-dir={profile_path}")
    # options.add_argument("profile-directory=Default")

    options.set_capability("goog:loggingPrefs", {"performance": "ALL"})
    options.set_capability("acceptInsecureCerts", True)
    options.set_capability("browserName", "chrome")

    # proxy
    # options.add_argument(f"--proxy-server={proxy}")

    return options


@pk_measure_seconds
def get_driver_selenium(browser_debug_mode):
    import inspect
    func_n = inspect.currentframe().f_code.co_name

    import selenium.webdriver as webdriver

    # 드라이버 옵션
    options = get_webdriver_options_customed(browser_debug_mode=browser_debug_mode)

    # 드라이버 as 크롬브라우저
    driver = webdriver.Chrome(options=options)
    # service = Service('path/to/chromedriver')  # 크롬 드라이버 경로
    # driver = webdriver.Chrome(service=service, options=options)

    # 브라우저 exec
    driver.get('about:blank')
    # driver.get('http://www.naver.com')

    # driver.execute_script("Object.defineProperty(navigator, 'plugins', {get: function() {return[1, 2, 3, 4, 5]}})")  # hide plugin 0EA
    # driver.execute_script("Object.defineProperty(navigator, 'languages', {get: function() {return ['ko-KR', 'ko']}})")  # hide own lanuages
    # driver.execute_script("const getParameter = WebGLRenderingContext.getParameter;WebGLRenderingContext.prototype.getParameter = function(parameter) {if (parameter === 37445) {return 'NVIDIA Corporation'} if (parameter === 37446) {return 'NVIDIA GeForce GTX 980 Ti OpenGL Engine';}return getParameter(parameter);};")  # hide own gpu # WebGL렌더러를 Nvidia회사와 GTX980Ti엔진인 ‘척’ 하는 방법입니다.

    # 플러그인 언어 소유GPU 숨기기
    driver.execute_script("Object.defineProperty(navigator, 'plugins', {get: function() {return[1, 2, 3, 4, 5]}});")
    # driver.execute_script("Object.defineProperty(navigator, 'languages', {get: function() {return ['ko-KR', 'ko']}});")
    driver.execute_script(
        "const getParameter = WebGLRenderingContext.getParameter; WebGLRenderingContext.prototype.getParameter = function(parameter) { if (parameter === 37445) { return 'NVIDIA Corporation'; } if (parameter === 37446) { return 'NVIDIA GeForce GTX 980 Ti OpenGL Engine'; } return getParameter(parameter); };")
    return driver


def get_driver_selenium(browser_debug_mode, proxy=None):
    import inspect
    import selenium.webdriver as webdriver
    func_n = inspect.currentframe().f_code.co_name

    # 드라이버 옵션
    # options=get_webdriver_options_customed(browser_show=browser_debug_mode)
    options = get_webdriver_options_customed(browser_debug_mode=browser_debug_mode, proxy=proxy)

    # 드라이버 as 크롬브라우저
    # service=Service('path/to/chromedriver')  # 크롬 드라이버 경로
    # driver=webdriver.Chrome(service=service, options=options)
    driver = webdriver.Chrome(options=options)

    # 브라우저 exec
    driver.get('about:blank')
    # driver.get('http://www.naver.com')

    # cookies (가짜)
    # cookies=[
    #     {"name": "cf_clearance", "value": "쿠키값", "domain": "yadongplay1.net"},
    # ]
    # for cookie in cookies:
    #     driver.add_cookie(cookie)

    # 플러그인 언어 소유GPU 숨기기
    # driver.execute_script(        "const getParameter=WebGLRenderingContext.getParameter; WebGLRenderingContext.prototype.getParameter=function(parameter) { if (parameter === 37445) { return 'NVIDIA Corporation'; } if (parameter === 37446) { return 'NVIDIA GeForce GTX 980 Ti OpenGL Engine'; } return getParameter(parameter); };")
    # driver.execute_script("Object.defineProperty(navigator, 'plugins', {get: function() {return[1, 2, 3, 4, 5]}});")# hide plugin 0EA
    # driver.execute_script("Object.defineProperty(navigator, 'languages', {get: function() {return ['ko-KR', 'ko']}});")  # hide own lanuages
    # driver.execute_script("const getParameter=WebGLRenderingContext.getParameter;WebGLRenderingContext.prototype.getParameter=function(parameter) {if (parameter === 37445) {return 'NVIDIA Corporation'} if (parameter === 37446) {return 'NVIDIA GeForce GTX 980 Ti OpenGL Engine';}return getParameter(parameter);};")  # hide own gpu # WebGL렌더러를 Nvidia회사와 GTX980Ti엔진인 ‘척’ 하는 방법입니다.

    return driver


def get_f_loading_nx_by_pattern(pattern):
    import re
    from pkg_py.pk_colorful_cli_util import pk_print
    window_opened_list = get_window_opened_list()
    for window_opened in window_opened_list:
        match = re.search(pattern, window_opened)
        if match:
            # pk_print(f'''pattern={pattern}  {'%%%FOO%%%' if LTA else ''}''')
            # print_iterable_as_vertical(item_iterable=window_opened_list, item_iterable_n="window_opened_list")
            # pk_print(f'''match={match}  {'%%%FOO%%%' if LTA else ''}''')
            f_loading_nx_matched = match.group(1)
            pk_print(f'''f_loading_nx_matched={f_loading_nx_matched}  {'%%%FOO%%%' if LTA else ''}''')
            return f_loading_nx_matched
        # else:
        #     pk_print(f'''not matched  {'%%%FOO%%%' if LTA else ''}''')


def ensure_and_get_wsl_port(wsl_distro_n):
    return ensure_and_get_port_wsl_via_sshd_config(wsl_distro_n=wsl_distro_n)


def guide_to_manual_remedy(prompt_remedy):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import UNDERLINE, STAMP_TRY_GUIDE
    print(f'\n')
    pk_copy(working_str=prompt_remedy)
    pk_print(f'{UNDERLINE}')
    pk_print(f'{STAMP_TRY_GUIDE} {prompt_remedy}')
    pk_print(f'{UNDERLINE}')


def ensure_and_get_port_wsl_via_sshd_config(wsl_distro_n):
    from pkg_py.pk_colorful_cli_util import pk_print
    std_out_list = None
    f_sshd_config = '/etc/ssh/sshd_config'
    if is_os_windows():
        std_out_list = cmd_to_os(rf'wsl -d {wsl_distro_n} sudo cat {f_sshd_config}')
    else:
        if is_os_wsl_linux():
            if does_pnx_exist(f_sshd_config):
                std_out_list = cmd_to_os(rf'sudo cat {f_sshd_config}')
            else:
                pk_print(f'''f_sshd_config 가 없습니다. {'%%%FOO%%%' if LTA else ''}''')
                cmd_to_os(rf'echo y | sudo apt install --reinstall openssh-server')
                std_out_list = cmd_to_os(rf'sudo cat {f_sshd_config}')
        else:
            pass
    filtered_list = []
    signiture = "#Port 22"
    signiture2 = "Port "
    for std_str in std_out_list:
        if signiture in std_str:
            pk_print(working_str=rf'''The port configuration is commented out in WSL ENVIRONMENT.  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
            if is_os_wsl_linux():
                cmd_to_os(rf'code {f_sshd_config}')  # todo port 변경 자동화
                guide_to_manual_remedy(prompt_remedy=f'sudo code {f_sshd_config}')
            raise
        if signiture2 in std_str:
            filtered_list.append(std_str)
    port_wsl = None
    if len(filtered_list[0]) != 0:
        port_wsl = filtered_list[0].replace(signiture2, "")
        if LTA:
            pk_print(f'''port_wsl={port_wsl} {'%%%FOO%%%' if LTA else ''}''')
    return port_wsl


def get_user_n_wsl_via_whoami(wsl_disto_n):
    from pkg_py.pk_colorful_cli_util import pk_print
    std_out_list = None
    if is_os_windows():
        std_out_list = cmd_to_os(f'wsl -d {wsl_disto_n} whoami')
    else:
        std_out_list = cmd_to_os(rf'whoami', encoding='utf-8')
    std_out_list = get_list_without_none_and_duplicates(std_out_list)
    user_n_list = std_out_list
    if len(std_out_list) == 1:
        pk_print(rf'''users_wsl[0]="{user_n_list[0]}"  {'%%%FOO%%%' if LTA else ''}''')
        return user_n_list[0]
    else:
        pk_print(f"현재 wsl에 로그인된 사용자가 한명이 아닙니다 user_n_list=[{user_n_list}]", print_color='red')
        raise


def get_wsl_user_n(wsl_distro_n):
    return get_user_n_wsl_via_whoami(wsl_disto_n=wsl_distro_n)


def get_wsl_pw(wsl_distro_n):
    from pkg_py.pk_core_constants import D_PKG_TOML
    # return get_token_from_f_txt(f_token=rf'{D_PKG_TXT}\token_pw_wsl.txt', initial_str="")
    wsl_distro_number = wsl_distro_n.split('-')[1].split('.')[0]
    return get_pk_token(f_token=rf'{D_PKG_TOML}/pk_token_pw_wsl_{wsl_distro_number}.toml', initial_str="")


def get_wsl_ip(wsl_distro_n):
    from pkg_py.pk_colorful_cli_util import pk_print

    if is_os_windows():
        std_out_list = cmd_to_os(rf'wsl -d {wsl_distro_n} hostname -I', encoding='utf-8')
    else:
        if is_os_wsl_linux():
            std_out_list = cmd_to_os(rf'hostname -I', encoding='utf-8')
        else:
            pass
    ip_wsl = std_out_list[0].split(" ")[0]
    if ip_wsl:
        if not ping(ip=ip_wsl):
            pk_print(working_str=rf'''ping {ip_wsl}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
            raise
    return ip_wsl


def get_list_from_integer_range(int_s, int_e):
    if int_s <= int_e:
        return list(range(int_s, int_e + 1))
    else:
        return list(range(int_s, int_e - 1, -1))  # get_list_from_integer_range(10,-10) 인 경우 처리


def get_stock_n(ticker):
    from project_database.test_project_database import MySqlUtil
    df = MySqlUtil.execute(f"""select * from finance_stock_ticker where ticker="{ticker}" """)
    return df


def get_pw_hashed(pw_plain: str):
    from passlib.context import CryptContext
    pw_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
    pw_hashed = pw_context.hash(pw_plain)
    return pw_hashed


# [def get_pnx]
def get_pnx_unix_style(pnx):
    pnx = pnx.replace(f"\\", rf"/")
    pnx = pnx.strip()
    return pnx


def get_pnx_wsl_unix_style_v1(pnx):
    pnx = pnx.replace(f"\\", rf"/")
    pnx = pnx.replace(f"C:/", rf"/mnt/c/")
    return pnx


def get_pnx_wsl_unix_style(pnx: str) -> str:
    import re
    # 1) 백슬래시 → 슬래시
    normalized = pnx.replace("\\", "/")

    # 2) 드라이브 레터 변환 (sample: C:/foo → /mnt/c/foo)
    normalized = re.sub(
        r"^([A-Za-z]):/",
        lambda m: f"/mnt/{m.group(1).lower()}/",
        normalized
    )

    return normalized


def get_pnx_windows_style_v1(pnx):
    pnx = pnx.replace(rf"//", f"/")
    pnx = pnx.replace(rf"/", f"\\")
    pnx = pnx.replace(rf"/mnt/c/", f"C:/")
    pnx = pnx.replace(rf"/mnt/d/", f"D:/")
    pnx = pnx.replace(rf"/mnt/e/", f"E:/")
    pnx = pnx.replace(rf"/mnt/f/", f"F:/")
    return pnx


def get_pnx_windows_style(pnx: str) -> str:
    import re
    path = pnx.replace('//', '/')
    path = re.sub(
        r'^/mnt/([A-Za-z])/',
        lambda m: f"{m.group(1).upper()}:/",
        path
    )
    return path.replace('/', '\\')


def get_pnx_list_interested_from_file_system(pnx_interested_list=None, string_exclude=None):
    from pkg_py.pk_core_constants import D_PKG_TXT

    f_func_n_txt = rf"{D_PKG_TXT}\make_pnx_interested_list_to_text_file.txt"

    if pnx_interested_list is None:
        # todo make_pnx_interested_list_to_text_file_x f이 없으면 만들도록
        make_pnx_interested_list_to_f_txt_x(d_working_list=pnx_interested_list, exclusion_list=string_exclude)

        # PKG_TXT = rf"{D_PKG_TXT}"
        # window_title_seg = get_nx(PKG_TXT)
        # if not is_window_open(window_title_seg=window_title_seg):
        #     open_pnx(pnx=PKG_TXT)
    else:
        make_pnx_interested_list_to_f_txt(pnx_interested_list=pnx_interested_list, string_exclude=string_exclude)

        # window_title_seg = get_nx (f_func_n_txt)
        # if not is_window_open(window_title_seg=window_title_seg):
        #     open_pnx(pnx=f_func_n_txt)

    return get_list_from_f(f=f_func_n_txt)


# [def get_list]
def get_list_url_decoded_element(working_list):
    import urllib.parse
    return [urllib.parse.unquote(item) for item in working_list]


def get_list_sorted(working_list, mode_asc=1):
    if mode_asc == 1:
        return sorted(working_list)  # 오름차순 정렬
    elif mode_asc == 0:
        return sorted(working_list, reverse=True)  # 내림차순 정렬
    else:
        raise ValueError("Invalid order. Use 'asc' or 'desc'.")


def get_list_replaced_element_from_pattern_to_patternless(working_list, pattern):
    import re
    return [re.sub(pattern, "", item) for item in working_list]


def get_list_replaced_element_from_str_to_upper_case(working_list):
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    if not isinstance(working_list, list):
        raise ValueError("Input must be a list.")
    return [item.upper() if isinstance(item, str) else item for item in working_list]


def get_list_via_user_input(ment, func_n):
    positivie = "Positive"
    negative = "Negative"
    from pkg_py.pk_interface_graphic_user import should_i_do
    txt_clicked, function, txt_written = should_i_do(
        prompt=ment,
        btn_list=[positivie, negative],
        function=None,
        auto_click_negative_btn_after_seconds=30,
        title=f"{func_n}()",
        input_box_mode=True,
    )
    if txt_clicked != positivie:
        return
    user_input = txt_written.strip()
    working_list = user_input.split("\n")
    return working_list


# [def get_str]
def get_str_replaced_from_pattern_to_patternless(str_working, pattern):
    import re
    return re.sub(pattern, "", str_working)


def get_str_from_list(working_list, item_connector=", ", prefix="", suffix=""):
    # item_connector means delimiter
    if not isinstance(working_list, list):
        raise ValueError("Input must be a list.")

    if not all(isinstance(item, str) for item in working_list):
        raise ValueError("All elements in the list must be strings.")

    return f"{prefix}{item_connector.join(working_list)}{suffix}"


# [def get_pid]

def get_pid_by_window_title_via_tasklist(window_title_seg):
    try:
        cmd = rf'tasklist'
        lines = cmd_to_os(cmd=cmd)
        matching_lines = None
        for line in lines:
            if window_title_seg in line:
                matching_lines = line

        pids = []
        parts = matching_lines.split()
        if len(parts) > 1 and window_title_seg in parts[0]:
            pids.append(parts[1])

        if len(pids) == 1:
            return pids[0]
        else:
            return pids
    except Exception as e:
        return str(e)


def get_pid_by_window_title(window_title_seg):  # 테스트필요
    import psutil
    from pkg_py.pk_colorful_cli_util import pk_print
    import inspect
    import pygetwindow
    func_n = inspect.currentframe().f_code.co_name
    # window_titles=pygetwindow.getAllTitles()
    window_titles = get_window_title_list()
    matching_window = [w for w in window_titles if window_title_seg.lower() in w.lower()]

    if not matching_window:
        return f"No window found with title containing: '{window_title_seg}'"

    # Assuming the first match
    window_title_match = matching_window[0]
    print(f"Found window: {window_title_match}")

    for process in psutil.process_iter(['pid', 'name']):
        try:
            process_name = process.info['name']
            process_id = process.info['pid']
            process_window_titles = pygetwindow.getWindowsWithTitle(window_title_match)

            pk_print(f'process_name="{process_name}"  {'%%%FOO%%%' if LTA else ''}')
            pk_print(f'process_id="{process_id}"  {'%%%FOO%%%' if LTA else ''}')
            pk_print(f'process_window_titles="{process_window_titles}"  {'%%%FOO%%%' if LTA else ''}')

            if process_window_titles:
                return process_id
        except (psutil.NoSuchProcess, psutil.AccessDenied) as e:

            pk_print(f"Error processing {process.info['pid']}: {e}")
            continue
    return f"No PID found for window title: '{window_title_match}'"


def get_cpu_usage(interval, process_n):
    """LosslessCut 프로세스의 CPU 사용량을 측정"""
    import psutil
    print("🔍 현재 exec  중인 프로세스 목록:")
    process_n_list = []
    process_pid_list = []
    for process in psutil.process_iter(attrs=["pid", "name"]):
        # process_pid_list.append(process.info['pid'])
        process_n_list.append(process.info['name'])
    # print_iterable_as_vertical(item_iterable=process_n_list, item_iterable_n='process_n_list')
    for process in psutil.process_iter(attrs=["name", "cpu_percent"]):
        if process_n in process.info["name"]:
            return process.cpu_percent(interval=interval)  # CPU 사용량 리턴
    return None  # 프로세스가 없으면 None 반환


def get_cpu_usage(interval, process_n):
    import psutil
    import time
    """LosslessCut 프로세스의 CPU 사용량을 측정"""
    for process in psutil.process_iter(attrs=["name", "pid"]):
        if process_n in process.info["name"]:
            proc = psutil.Process(process.info["pid"])
            proc.cpu_percent(interval=None)  # 첫 번째 호출 (무시)
            time.sleep(interval)  # interval 동안 기다리기
            return proc.cpu_percent(interval=None)  # 두 번째 호출 값 반환
    return None  # 프로세스가 없으면 None 반환


# [def cmd]
def cmd_to_os_like_person(cmd, admin_mode=False, mode_exit=True):
    import time
    from pkg_py.pk_colorful_cli_util import pk_print
    # todo : chore : return 에 대해서 개선필요
    '''
    return 재대로 안됨
    '''
    window_title_seg = rf'cmd.exe'
    # | clip 을 하여도 값을 읽어오기 어려운 경우가 있음
    pk_print(working_str=rf'''cmd="{cmd}"  {'%%%FOO%%%' if LTA else ''}''')
    if not is_window_opened(window_title_seg=window_title_seg):
        if admin_mode == False:
            run_cmd_exe()
        else:
            run_cmd_exe_as_admin()

    std_str = ""
    time_limit = 10
    time_s = time.time()
    while 1:
        if LTA:
            print(1)
        if is_front_window_title(window_title_seg=window_title_seg):
            # cmd=rf"{cmd} | clip"
            copy_and_paste_with_keeping_clipboard(prompt=cmd)
            # pk_sleep(milliseconds=1000)
            pk_sleep(milliseconds=500)
            if is_front_window_title(window_title_seg=window_title_seg):
                pk_press("enter")
            std_str = get_str_from_clipboard()
            return std_str
        ensure_window_to_front(window_title_seg=window_title_seg)
        # # pk_print(str_working=time.time() - time_s)
        if time.time() - time_s > time_limit:
            pk_print(working_str=rf'''rf"{time_limit} seconds passed. Exiting loop."  {'%%%FOO%%%' if LTA else ''}''')
            break
        pk_sleep(seconds=0.5)  # CPU 점유율을 낮추기 위해 약간의 대기

    time_limit = 5
    time_s = time.time()
    while 1:
        print(2)
        if is_front_window_title(window_title_seg=window_title_seg):
            if mode_exit == True:
                copy_and_paste_with_keeping_clipboard(prompt="exit")
                pk_press("enter")
        # pk_print(str_working=time.time() - time_s)
        if time.time() - time_s > time_limit:
            pk_print(working_str="5 seconds passed. Exiting loop.")
            break
        pk_sleep(seconds=0.5)  # CPU 점유율을 낮추기 위해 약간의 대기
    return std_str


def cmd_to_os_via_powershell_exe(cmd, console_keep_mode=False, admin_mode=False):
    import time
    from pkg_py.pk_colorful_cli_util import pk_print
    # | clip 을 하여도 값을 읽어오기 어려운 경우가 있음
    window_title_seg = rf'PowerShell'
    pk_print(working_str=rf'''cmd="{cmd}"  {'%%%FOO%%%' if LTA else ''}''')
    if not is_window_opened(window_title_seg=window_title_seg):
        # run_cmd_exe()
        if admin_mode == False:
            window_title_seg = rf'powershell'
            run_powershell_exe()
        else:
            window_title_seg = rf'PowerShell'
            run_powershell_exe_as_admin()
    ensure_window_to_front(window_title_seg=window_title_seg)

    std_output_stream = ""
    time_limit = 5
    time_s = time.time()
    while 1:
        if is_front_window_title(window_title_seg=window_title_seg):
            # copy_and_paste_with_keeping_clipboard(string=rf"cd {wsl_pnx} | xclip -sel clip", mode="wsl") # fail: cd는 xclip 으로 pipe 할 수 없음
            copy_and_paste_with_keeping_clipboard(prompt=cmd)
            pk_press("enter")
            std_output_stream = get_str_from_clipboard()
            break
        # 5초가 지났는지 확인
        # pk_print(str_working=time.time() - time_s)
        if time.time() - time_s > time_limit:
            pk_print(working_str="5 seconds passed. Exiting loop.")
            break
        pk_sleep(seconds=0.5)  # CPU 점유율을 낮추기 위해 약간의 대기

    if console_keep_mode == False:
        time_limit = 5
        time_s = time.time()
        while 1:
            if is_front_window_title(window_title_seg=window_title_seg):
                copy_and_paste_with_keeping_clipboard(prompt="exit")
                pk_press("enter")
                if admin_mode == False:
                    copy_and_paste_with_keeping_clipboard(prompt="exit")
                    pk_press("enter")
                break
            # pk_print(str_working=time.time() - time_s)
            if time.time() - time_s > time_limit:
                pk_print(working_str="5 seconds passed. Exiting loop.")
                break
            pk_sleep(seconds=0.5)  # CPU 점유율을 낮추기 위해 약간의 대기
    return std_output_stream


def cmd_to_wsl_os_like_person_deprecated(cmd, remote_os_distro_n, wsl_window_title_seg, exit_mode=False):
    from pkg_py.pk_colorful_cli_util import pk_print

    import time
    import inspect
    func_n = inspect.currentframe().f_code.co_name

    timeout = 20
    start_time = time.time()
    while 1:
        if is_window_opened(window_title_seg=wsl_window_title_seg):
            break
        open_and_move_wsl_console_to_front(remote_os_distro_n=remote_os_distro_n, window_title_seg=wsl_window_title_seg)
        pk_print(working_str=time.time() - start_time)
        if time.time() - start_time > timeout:
            break
        pk_sleep(seconds=0.5)

    std_output_stream = ""
    timeout = 5
    start_time = time.time()
    while 1:
        if is_front_window_title(window_title_seg=wsl_window_title_seg):
            copy_and_paste_with_keeping_clipboard(prompt=cmd, wsl_mode=True)
            pk_press("enter")
            break
        ensure_window_to_front(window_title_seg=wsl_window_title_seg)

        # 5초가 지났는지 확인
        pk_print(working_str=time.time() - start_time)
        if time.time() - start_time > timeout:
            pk_print(working_str="5 seconds passed. Exiting loop.")
            break
        pk_sleep(seconds=0.5)  # CPU 점유율을 낮추기 위해 약간의 대기

    if exit_mode == True:
        timeout = 5
        start_time = time.time()
        while 1:
            if is_front_window_title(window_title_seg=wsl_window_title_seg):
                copy_and_paste_with_keeping_clipboard(prompt="exit", wsl_mode=True)
                pk_press("enter")
                copy_and_paste_with_keeping_clipboard(prompt="exit", wsl_mode=True)
                pk_press("enter")
                break
            else:
                ensure_window_to_front(window_title_seg=wsl_window_title_seg)
            pk_print(working_str=time.time() - start_time)
            if time.time() - start_time > timeout:
                pk_print(working_str="5 seconds passed. Exiting loop.")
                break
            pk_sleep(seconds=0.5)  # CPU 점유율을 낮추기 위해 약간의 대기

    # return std_output_stream


def cmd_to_wsl_os_like_person(cmd, remote_os_distro_n, wsl_window_title_seg, sleep_time=500):
    run_wsl(remote_os_distro_n=remote_os_distro_n, wsl_window_title_seg=wsl_window_title_seg)
    write_like_person(cmd)
    pk_sleep(milliseconds=sleep_time)
    pk_press('enter')


# def cmd_to_remote_os_with_pw(port, user, ip, pw, cmd):  # fail
#     import subprocess
#     from pkg_py.pk_colorful_cli_util import pk_print
#     """
#     원격 OS에서 명령을 exec 하고 완료될 때까지 대기하는 메서드.
#
#     :param port: SSH 포트 번호
#     :param user: 원격 사용자명
#     :param ip: 원격 서버 IP 주소
#     :param pw: 원격 서버 비밀번호 (비밀번호 인증 방식에서만 필요)
#     :param cmd: exec 할 원격 명령어
#     """
#     try:
#         # Construct the SSH cmd
#         ssh_cmd = f'ssh -p {port} {user}@{ip} "{cmd}"'
#
#         # Start the process
#         process = subprocess.Popen(ssh_cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
#
#         # Simulate typing the password when prompted
#         stdout, stderr = process.communicate(input=f"{pw}\n")
#
#         # Print cmd output
#         if stdout:
#             pk_print(str_working="STDOUT:")
#             print(stdout.strip())
#
#         if stderr:
#             pk_print(str_working="STDERR:")
#             print(stderr.strip())
#
#         # Check the return code
#         if process.returncode == 0:
#             pk_print(str_working="successfully, cmd executed")
#         else:
#             pk_print(f"cmd failed with return code {process.returncode}.", print_color='red')
#     except Exception as e:
#         print(f"An error occurred: {str(e)}")


def cmd_to_remote_os(cmd, **config_remote_os):
    return cmd_to_remote_os_with_pubkey(cmd=cmd, **config_remote_os)


def cmd_to_remote_os_without_pw(port, users, ip, pw, cmd):
    from pkg_py.pk_colorful_cli_util import pk_print
    import time

    cmd = f'ssh {users}@{ip} -p {port} "{cmd}"'
    pk_print(rf'''cmd="{cmd}"  {'%%%FOO%%%' if LTA else ''}''')
    # cmd_to_os(cmd=cmd) # fail : pw 물은 채로 정지
    cmd_to_os_like_person(cmd=cmd)
    window_title_seg = r"C:\Windows\system32\cmd"
    if LTA:
        print_window_opened_list()
    pk_print(rf'''window_title_seg="{window_title_seg}"{'%%%FOO%%%' if LTA else ''}''')
    time_limit = 10
    time_s = time.time()
    while 1:
        # pk_sleep(milliseconds=2000) # success : 느림
        # pk_sleep(milliseconds=1500)
        if is_window_opened(window_title_seg=window_title_seg):
            ensure_window_to_front(window_title_seg=window_title_seg)
            # pk_sleep(milliseconds=500)  # success : 느림
            pk_sleep(milliseconds=100)
            break
        if time.time() - time_s > time_limit:
            return 0
    pk_sleep(milliseconds=500)


def cmd_to_os_as_admin(cmd):
    """Windows에서 관리자 권한으로 명령 프롬프트 exec  (배치 f 사용)"""
    # todo : fix
    import platform
    import importlib
    from pkg_py.pk_core_constants import Encoding, D_PKG_CMD

    import os
    if platform.system() == 'Windows':
        subprocess = importlib.import_module("subprocess")

        os.system(rf'chcp 65001')

        f_cmd = rf"{D_PKG_CMD}\elevate_cmd.cmd"
        CRLF = '%%%CRLF%%%'
        script_str = rf'''
                        @echo off{CRLF}
                        echo Set UAC = CreateObject^("Shell.Application"^) > "%temp%\ElevateScript.vbs"{CRLF}
                        echo UAC.ShellExecute "cmd.exe", "/c ""%~1""", "", "runas", 1 >> "%temp%\ElevateScript.vbs"{CRLF}
                        cscript //nologo "%temp%\ElevateScript.vbs"{CRLF}
                        del "%temp%\ElevateScript.vbs"{CRLF}
                        '''
        script_list = script_str.split(CRLF)
        script_list = get_list_replaced_element_from_str_to_str(working_list=script_list, from_str='    ', to_str='')
        ensure_pnx_made(pnx=f_cmd, mode='f', script_list=script_list)
        # cmd_to_os(cmd=rf"notepad {bat_f}")

        # 관리자 권한 exec 
        admin_cmd = f'cmd.exe /c {f_cmd} "{cmd}"'

        result = subprocess.run(admin_cmd, shell=True, encoding=Encoding.UTF8, errors="replace",
                                stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        return result.returncode, result.stdout, result.stderr


def cmd_to_os_like_person_as_admin(cmd):
    import platform
    import subprocess
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    # todo : refactor : need refactorying
    # 검증도 필요하다. like_pserson 으로 동작 하지 않는다.
    if not platform.system() == 'Windows':
        cmd = cmd.replace("\\", "/")
    try:
        if platform.system() == 'Windows':
            # lines=subprocess.check_output('chcp 65001 >nul', shell=True).decode('utf-8').split('\n')
            # lines=subprocess.check_output(cmd, shell=True).decode('euc-kr').split('\n')
            lines = subprocess.check_output(cmd, shell=True).decode('utf-8').split('\n')
        return lines
    except:
        pk_print(working_str=rf'''traceback.format_exc()="{traceback.format_exc()}"  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        # os.system(cmd)
    return None


def cmd_to_os(cmd: str, mode="", encoding=None, mode_with_window=1, LTA=LTA):
    # std_list = cmd_to_os_v_1_0_1(cmd=cmd, mode=mode, encoding=encoding)
    # std_list = cmd_to_os_v_1_0_2(cmd=cmd, mode=mode, encoding=encoding)
    # std_list = cmd_to_os_v_1_0_3(cmd=cmd, mode=mode, encoding=encoding)
    # std_list = cmd_to_os_v_1_0_5(cmd=cmd, mode=mode, encoding=encoding)
    std_list = cmd_to_os_v6(cmd=cmd, mode=mode, encoding=encoding, mode_with_window=mode_with_window, LTA=LTA)
    return std_list


def cmd_to_os_v_1_0_1(cmd: str, mode="", encoding=None):
    import subprocess
    import traceback
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import Encoding
    from enum import Enum
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    encoding: Enum

    std_list = []
    if mode == "a":
        pk_print(working_str=rf'''cmd="{cmd}" mode="async"  {'%%%FOO%%%' if LTA else ''}''')
    else:
        pk_print(working_str=rf'''cmd="{cmd}" mode="동기"  {'%%%FOO%%%' if LTA else ''}''')
    if encoding != Encoding.UTF8:
        encoding = Encoding.CP949  # UTF8 가 아니면 CP949 로 강제
    if mode == "a":  # async
        subprocess.Popen(args=cmd, shell=True, encoding=encoding.value)
        return
    else:
        try:
            process = subprocess.Popen(
                args=cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding=encoding.value,
                # text=True,  # 텍스트 모드 활성화
            )
        except UnicodeDecodeError:
            # 실패하면 UTF-8로 변경하여 시도
            encoding = Encoding.UTF8
            process = subprocess.Popen(args=cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding=encoding.value)

        try:
            stdout, stderr = process.communicate()
            if stdout:
                for std_str in stdout.splitlines():
                    std_list.append(std_str.strip())
                    # pk_print(f"STD_OUT: {std_str.strip()}", print_color='green')
                    pk_print(f"STD_OUT: {std_str.strip()}")
            if stderr:
                for std_str in stderr.splitlines():
                    std_list.append(std_str.strip())
                    pk_print(f"STD_ERR: {std_str.strip()}", print_color='red')
        except:
            pk_print(f'''[{func_n}()] {traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')

        finally:
            try:
                if process and process.poll() is None:
                    process.terminate()
            except:
                pk_print(f'''[{func_n}()] {traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        return std_list


# def cmd_to_os_v_1_0_2(cmd: str, mode="", encoding=None):
#     import subprocess
#     import traceback
#     from pkg_py.pk_colorful_cli_util import pk_print
#     from pkg_py.pk_core_constants import Encoding
#     from enum import Enum
#     import inspect
#     func_n = inspect.currentframe().f_code.co_name
#
#     encoding: Enum
#     if encoding is None:
#         encoding = Encoding.UTF8  # 기본적으로 UTF-8 사용
#
#     std_list = []
#     if mode == "a":
#         pk_print(working_str=rf'''encoding={encoding:5s} mode=async  {'%%%FOO%%%' if LTA else ''}''')
#         pk_print(working_str=rf'''cmd={cmd}''')
#     else:
#         pk_print(working_str=rf'''encoding={encoding:5s} mode=Sync  {'%%%FOO%%%' if LTA else ''}''')
#         pk_print(working_str=rf'''cmd={cmd}''')
#
#     if mode == "a":  # async
#         subprocess.Popen(args=cmd, shell=True, encoding=encoding.value)
#         return
#     else:  # 동기처리
#         # 프로세스를 바이너리 모드로 exec 하여 출력과 에러를 바이너리로 받음
#         process = subprocess.Popen(args=cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
#         try:
#             stdout, stderr = process.communicate()  # 표준 출력과 표준 에러를 바이너리로 받음
#
#             if stdout:
#                 stdout = stdout.decode(encoding.value, errors='replace')  # 에러가 발생할 경우 대체 문자로 처리
#                 for std_str in stdout.splitlines():
#                     std_str = std_str.strip()
#                     std_list.append(std_str)
#
#             if stderr:
#                 stderr = stderr.decode(encoding.value, errors='replace')  # 에러가 발생할 경우 대체 문자로 처리
#                 for std_str in stderr.splitlines():
#                     std_list.append(std_str.strip())
#
#         except:
#             pk_print(f'''[{func_n}()] {traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
#
#         finally:
#             # 프로세스 종료 (이미 종료된 경우 예외 처리)
#             try:
#                 if process and process.poll() is None:
#                     process.terminate()
#             except:
#                 pk_print(f'''[{func_n}()] {traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
#         print_iterable_as_vertical(item_iterable=std_list, item_iterable_n='std_list')
#         return std_list


# def cmd_to_os_v_1_0_3(cmd: str, mode="", encoding=None):
#     import subprocess
#     import traceback
#     import inspect
#     from pkg_py.pk_core_constants import STAMP_ATTEMPTED, Encoding
#     from pkg_py.pk_colorful_cli_util import pk_print
#
#     func_n = inspect.currentframe().f_code.co_name
#
#     # encoding: Enum
#     # 기본 인코딩 UTF-8 설정
#     if encoding is None:
#         encoding = Encoding.UTF8  # 기본적으로 UTF-8 사용
#
#     pk_print(working_str=rf'''{STAMP_ATTEMPTED} {cmd}''')
#
#     std_list = []
#     if mode == "a":  # async
#         pk_print(working_str=rf'''encoding={encoding:5s} mode=async  {'%%%FOO%%%' if LTA else ''}''')
#         subprocess.Popen(args=cmd, shell=True, encoding=encoding.value)
#         return
#     else:  # 동기처리
#         pk_print(working_str=rf'''encoding={encoding:5s} mode=Sync  {'%%%FOO%%%' if LTA else ''}''')
#         # 텍스트 모드로 프로세스를 exec 하여 출력과 에러를 텍스트로 받음
#         process = subprocess.Popen(args=cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding=encoding.value)
#         # process = subprocess.Popen(args=cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding=str(encoding))
#         try:
#             stdout, stderr = process.communicate()  # 표준 출력과 표준 에러를 텍스트로 받음
#             # 출력 스트림이 있으면 처리
#             if stdout:
#                 for std_str in stdout.splitlines():
#                     std_list.append(std_str.strip())
#                     # pk_print(f"STD_OUT: {std_str}")
#             # 에러 스트림이 있으면 처리
#             if stderr:
#                 for std_str in stderr.splitlines():
#                     std_list.append(std_str.strip())
#                     # pk_print(f"STD_ERR: {std_str.strip()}", print_color='red')
#         except:
#             pk_print(f'''[{func_n}()] {traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
#
#         finally:
#             # 프로세스 종료 (이미 종료된 경우 예외 처리)
#             try:
#                 if process and process.poll() is None:
#                     process.terminate()
#
#                 # print_iterable_as_vertical(item_iterable=std_list, item_iterable_n=rf'{cmd}')
#                 # useless_list = get_list_from_f(f=F_ALIAS_CMD) + [" {'%%%FOO%%%' if LTA else ''}", ""]
#                 # std_list = [x for x in std_list if x not in useless_list]
#                 print_iterable_as_vertical(item_iterable=std_list, item_iterable_n=rf'{cmd}')
#
#             except:
#                 pk_print(f'''[{func_n}()] {traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
#
#         return std_list


# def cmd_to_os_v_1_0_5(cmd: str, mode="", encoding=None):
#     import subprocess
#     import traceback
#     import inspect
#     from pkg_py.pk_core_constants import STAMP_ATTEMPTED, Encoding
#     from pkg_py.pk_colorful_cli_util import pk_print
#
#     # fallback 디코딩 함수 정의
#     def decode_with_fallback(byte_data, primary_encoding):
#         try:
#             return byte_data.decode(primary_encoding)
#         except UnicodeDecodeError:
#             return byte_data.decode('cp949', errors='replace')
#
#     func_n = inspect.currentframe().f_code.co_name
#
#     if encoding is None:
#         encoding = Encoding.UTF8
#
#     # LTA 미정의 시 False 처리
#     try:
#         lta_flag = LTA
#     except NameError:
#         lta_flag = False
#
#     pk_print(working_str=rf'''{STAMP_ATTEMPTED} {cmd}''')
#
#     std_list = []
#
#     if mode == "a":
#         pk_print(working_str=rf'''encoding={encoding:5s} mode=async  {'%%%FOO%%%' if lta_flag else ''}''')
#         subprocess.Popen(args=cmd, shell=True)
#         return
#
#     else:
#         pk_print(working_str=rf'''encoding={encoding:5s} mode=Sync  {'%%%FOO%%%' if lta_flag else ''}''')
#
#         try:
#             process = subprocess.Popen(args=cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
#             stdout_bytes, stderr_bytes = process.communicate()
#
#             stdout = decode_with_fallback(stdout_bytes, encoding.value)
#             stderr = decode_with_fallback(stderr_bytes, encoding.value)
#
#             if stdout:
#                 std_list.extend(line.strip() for line in stdout.splitlines())
#
#             if stderr:
#                 std_list.extend(line.strip() for line in stderr.splitlines())
#
#         except Exception:
#             pk_print(f'''[{func_n}()] {traceback.format_exc()}  {'%%%FOO%%%' if lta_flag else ''}''', print_color='red')
#
#         finally:
#             try:
#                 if process and process.poll() is None:
#                     process.terminate()
#
#                 # 필터링
#                 # useless_list = get_list_from_f(f=F_ALIAS_CMD) + [" {'%%%FOO%%%' if LTA else ''}", ""]
#                 # std_list = [x for x in std_list if x not in useless_list]
#
#                 print_iterable_as_vertical(item_iterable=std_list, item_iterable_n=rf'{cmd}')
#
#             except Exception:
#                 pk_print(f'''[{func_n}()] {traceback.format_exc()}  {'%%%FOO%%%' if lta_flag else ''}''', print_color='red')
#
#         return std_list


def cmd_to_os_v6(cmd: str, mode="", encoding=None, mode_with_window=1, LTA=None):
    from pkg_py.pk_core_constants import STAMP_ATTEMPTED, Encoding
    from pkg_py.pk_colorful_cli_util import pk_print
    def decode_with_fallback(byte_data, primary_encoding):
        try:
            return byte_data.decode(primary_encoding)
        except UnicodeDecodeError:
            return byte_data.decode('cp949', errors='replace')

    if encoding is None:
        encoding = Encoding.UTF8
    if mode == "":
        mode = 'sync'
    if mode == "a":
        mode = 'async'
    if LTA:
        pk_print(working_str=rf'''{STAMP_ATTEMPTED} {cmd} encoding={encoding:5s} mode={mode}''')
    std_list = []
    if mode == "async":
        if mode_with_window:
            import subprocess
            subprocess.Popen(args=cmd, shell=True)
            return
        else:
            import subprocess
            subprocess.Popen(args=cmd, shell=True, creationflags=subprocess.CREATE_NO_WINDOW)
            return
    else:
        try:
            process = None
            if mode_with_window:
                import subprocess
                process = subprocess.Popen(args=cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            else:
                import subprocess
                process = subprocess.Popen(args=cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, creationflags=subprocess.CREATE_NO_WINDOW)
            stdout_bytes, stderr_bytes = process.communicate()
            stdout = None
            stderr = None
            try:
                stdout = decode_with_fallback(stdout_bytes, encoding.value)
                stderr = decode_with_fallback(stderr_bytes, encoding.value)
            except AttributeError:
                stdout = decode_with_fallback(stdout_bytes, encoding)
                stderr = decode_with_fallback(stderr_bytes, encoding)

            if stdout:
                std_list.extend(line.strip() for line in stdout.splitlines())
            if stderr:
                std_list.extend(line.strip() for line in stderr.splitlines())

            print_iterable_as_vertical(item_iterable=std_list, item_iterable_n=rf'{cmd}')

        except Exception:
            import traceback
            pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')

        finally:
            try:
                if process and process.poll() is None:
                    process.terminate()

                # 필터링
                # useless_list = get_list_from_f(f=F_ALIAS_CMD) + [" {'%%%FOO%%%' if LTA else ''}", ""]
                # std_list = [x for x in std_list if x not in useless_list]

            except Exception:
                import traceback
                pk_print(f'''{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''}''', print_color='red')

        return std_list


def cmd_to_remote_os_with_pubkey(cmd, **config_remote_os):
    try:
        import paramiko
        from pkg_py.pk_core_constants import STAMP_REMOTE_DEBUG, STAMP_REMOTE_ERROR
        from pkg_py.pk_colorful_cli_util import pk_print

        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())  # 호스트 키 자동 수락

        if not does_pnx_exist(pnx=config_remote_os['local_ssh_private_key']):  # todo local_ssh_private_key 가 path 라면 f_ prefix 추가.
            pk_print(f'''config_remote_os['local_ssh_private_key']={config_remote_os['local_ssh_private_key']} {'%%%FOO%%%' if LTA else ''}''')
            state = is_os_windows()
            pk_print_state(state=state, pk_id="%%%FOO%%%")
            if state:
                cmd_to_os(f'ssh-keygen -t ed25519 -b 4096 -C "pk_ssh_key"')
            else:
                cmd_to_os(f'ssh-keygen -t ed25519 -C "pk_ssh_key"')
        key_private = paramiko.Ed25519Key(filename=config_remote_os['local_ssh_private_key'])

        pk_print(f'''config_remote_os['user_n']={config_remote_os['user_n']} {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''config_remote_os['ip']={config_remote_os['ip']} {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''config_remote_os['port']={config_remote_os['port']} {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''key_private={key_private} {'%%%FOO%%%' if LTA else ''}''')

        if not config_remote_os['ip']:
            pk_print(f'''config_remote_os['ip'] is None {'%%%FOO%%%' if LTA else ''}''')
            return None, None

        ssh.connect(hostname=config_remote_os['ip'], port=config_remote_os['port'], username=config_remote_os['user_n'], pkey=key_private)

        # The authenticity of host 'todo' can't be established.
        # ED25519 key fingerprint is SHA256:kO5qGJ92luOdRTm1Ye4pycNnXbNV4sl8gSoB9dAp9Uc.
        # This key is not known by any other names.

        std_out_list = []
        std_err_list = []

        # cmd_with_sudo_s = f"sudo -S {cmd}"
        cmd_with_sudo_s = f"{cmd}"
        pk_print(f'''{STAMP_REMOTE_DEBUG} cmd={cmd}  {'%%%FOO%%%' if LTA else ''}''')
        stdin, stdout, stderr = ssh.exec_command(cmd_with_sudo_s)

        stdout_str = stdout.read().decode()
        stderr_str = stderr.read().decode()

        if stdout_str:
            std_out_list = stdout_str.split("\n")
        if stderr_str:
            std_err_list = stderr_str.split("\n")

        for std_out_str in std_out_list:
            pk_print(f'''{STAMP_REMOTE_DEBUG} {std_out_str} {'%%%FOO%%%' if LTA else ''}''', print_color='green')

        if len(std_out_list) > 0 and len(std_err_list) > 0:
            # std_out_list 가 std_err_list 모두 있는 경우는 성공했지만 warning 을 띄우는 경우이다. 이 경우는 std_err_list 는 [] 로 초기화 처리했다
            for std_err_str in std_err_list:
                pk_print(f'''{STAMP_REMOTE_ERROR} {std_err_str} {'%%%FOO%%%' if LTA else ''}''', print_color='yellow')
            std_err_list = []
            if LTA:
                pk_print(f'''std_out_list={std_out_list} {'%%%FOO%%%' if LTA else ''}''')
                pk_print(f'''std_err_list={std_err_list} {'%%%FOO%%%' if LTA else ''}''')

            return std_out_list, std_err_list
        else:
            for std_err_str in std_err_list:
                pk_print(f'''{STAMP_REMOTE_ERROR} {std_err_str} {'%%%FOO%%%' if LTA else ''}''', print_color='red')
            if LTA:
                pk_print(f'''std_out_list={std_out_list} {'%%%FOO%%%' if LTA else ''}''')
                pk_print(f'''std_err_list={std_err_list} {'%%%FOO%%%' if LTA else ''}''')
            return std_out_list, std_err_list

    except Exception as e:
        import traceback
        pk_print(working_str=rf"{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''} ", print_color='red')


def ensure_remote_os_ip_usb_connection(config_remote_os, remote_os_distro_n=None):
    # ensure_wsl_usb_ip_connection_attached() 의 차선책
    import re
    from pkg_py.pk_colorful_cli_util import pk_print
    import time
    from pkg_py.pk_core_constants import Encoding

    ensure_usbipd_installed(config_remote_os)

    cmd_to_os(cmd="wsl --shutdown", encoding=Encoding.UTF8)

    std_list = cmd_to_os(cmd="usbipd list", encoding=Encoding.UTF8)
    bus_id = None
    # signiture_list = ["APX", "Attached" or "Shared"]
    signiture_list = ["APX"]
    pattern = re.compile(r"\d+-\d")  # "2-3 패턴" # 2-12 는 안될듯 업데이트 필요
    for signiture_to_search in std_list:
        if all(signiture_ in signiture_to_search for signiture_ in signiture_list):
            match = pattern.search(signiture_to_search)
            if not match:
                pk_print(f'''{signiture_to_search} is not matched in command({cmd}) {'%%%FOO%%%' if LTA else ''}''', print_color='red')
                pk_print(f'''리커버리 모드 진입을 재시도하세요.  {'%%%FOO%%%' if LTA else ''}"''', print_color='red')
                raise
            pk_print(working_str=rf'''match="{match}"  {'%%%FOO%%%' if LTA else ''}''')
            bus_id = match.group()
    if bus_id is None:
        pk_print(f'''"bus_id 가 None 입니다.  {'%%%FOO%%%' if LTA else ''} "''', print_color='red')
        raise
    pk_print(working_str=rf'''bus id found, bus_id={bus_id}  {'%%%FOO%%%' if LTA else ''}''', print_color="green")

    # signiture = "제공된 이름의 배포가 없습니다" or 'xxxx'
    std_list = cmd_to_os(cmd=rf"wsl -d {remote_os_distro_n} -- exit")
    if check_signiture_in_loop(time_limit=10, working_list=std_list, signiture="제공된 이름의 배포가 없습니다", signiture_found_ment=rf"'{cmd}' 할수없었습니다"):
        raise

    cmd = "wsl -l -v"
    std_list = cmd_to_os(cmd=cmd, encoding='utf-16')
    import ipdb
    ipdb.set_trace()

    cmd = rf"usbipd unbind -b {bus_id}"
    cmd_to_os(cmd=cmd, encoding=Encoding.UTF8)

    cmd = rf"usbipd bind -b {bus_id}"
    cmd_to_os(cmd=cmd, encoding=Encoding.UTF8)

    # usbipd: warning: A firewall appears to be blocking the connection; ensure TCP port 3240 is allowed.
    # powershell as admin
    # New-NetFirewallRule -DisplayName "Allow USBIP Port 3240" -Direction Inbound -Action Allow -Protocol TCP -LocalPort 3240

    # 위 내용에 대해서 원복
    # Remove-NetFirewallRule -DisplayName "Allow USBIP Port 3240"

    # cmd = rf"usbipd attach --wsl --busid {bus_id} --auto-attach"
    cmd = rf'start "" usbipd attach --wsl --busid {bus_id} --auto-attach'
    cmd_with_window_title = rf'title "{cmd}" && {cmd}'
    cmd_to_os_like_person(cmd=cmd_with_window_title)
    timeout = 15
    start_time = time.time()
    while 1:
        if is_window_opened(window_title_seg=cmd):
            pk_print(working_str=rf'''[ATTEMPTED] "wsl attach"  {'%%%FOO%%%' if LTA else ''}''')
            break
        if time.time() - start_time > timeout:
            return 0
        pk_sleep(seconds=0.2)

    cmd = rf"wsl lsusb"
    time_limit = 10
    time_s = time.time()
    signiture_list = "NVidia Corp."
    ment_positive = "wsl 에 attach 되었습니다"
    while 1:
        std_list = cmd_to_os(cmd=cmd, encoding=Encoding.CP949)
        for signiture_to_search in std_list:
            if signiture_list in signiture_to_search:
                pk_print(f'''{ment_positive}''', print_color="green")
                return 1
        if time.time() - time_s > time_limit:
            return 0
        pk_sleep(seconds=0.2)


def is_usbipd_installed():
    pass


def ensure_usbipd_installed(config_remote_os):
    if is_os_windows():
        if not is_usbipd_installed():
            # explorer https://github.com/dorssel/usbipd-win/releases
            # install usbipd-win_5.0.0_x64.msi
            # usbipd list # APX -> Attached or Shared -> BUSID
            # usbipd bind -b $BUSID
            # usbipd attach --wsl --busid $BUSID --auto-attach
            # wsl -d wsl_ubuntu_24_04_no_flash lsusb # NVIDIA Corp. APX
            cmd_to_remote_os(cmd='sudo apt install -y usbutils', **config_remote_os)  # wsl/wsl_ubuntu_24_04_no_flash/usbutils/lsusb


def ensure_wsl_usb_ip_connection_established(wsl_distro_n, config_remote_os):
    # todo : attach_remote_os_usb_connection() 를 ensure_wsl_usb_connection_attach() 에 병합
    import re
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import Encoding

    ensure_usbipd_installed(config_remote_os)

    cmd = "usbipd list"  # watch -n 1 usbipd.exe list
    std_list = cmd_to_os(cmd=cmd, encoding=Encoding.UTF8)
    bus_id = None
    # signiture_list=["APX", "Attached" or "Shared"]
    signiture_list = ["APX"]
    pattern = re.compile(r"\d+-\d")  # "2-3 패턴" # 2-12 는 안될듯 업데이트 필요
    print_iterable_as_vertical(item_iterable=std_list, item_iterable_n='lines')
    for std_str in std_list:
        if all(str_positive in std_str for str_positive in signiture_list):
            match = pattern.search(std_str)
            if not match:
                pk_print(f'''{signiture_list}가 없습니다.  {'%%%FOO%%%' if LTA else ''}" ''', print_color='red')
                raise
            pk_print(working_str=rf'''match="{match}"  {'%%%FOO%%%' if LTA else ''}''')
            bus_id = match.group()
    if bus_id is None:
        pk_print(f'''bus_id=None  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        raise
    pk_print(working_str=rf'''bus_id={bus_id}  {'%%%FOO%%%' if LTA else ''}''', print_color="green")

    cmd_to_os(cmd="wsl --shutdown", encoding='utf-16')

    std_list = cmd_to_os(cmd=rf"wsl -d {wsl_distro_n} -- exit", encoding='utf-16')
    if check_signiture_in_loop(time_limit=10, working_list=std_list, signiture="제공된 이름의 배포가 없습니다", signiture_found_ment=rf"'{cmd}' 할수없었습니다"):
        raise

    std_list = cmd_to_os(cmd="wsl -l -v", encoding='utf-16')
    cmd_to_os(cmd=rf"usbipd unbind -b {bus_id}", encoding='utf-16')
    cmd_to_os(cmd=rf"usbipd bind -b {bus_id}", encoding='utf-16')
    # cmd_to_os_like_person(cmd=rf"usbipd attach --wsl --busid {bus_id} --auto-attach")
    cmd_to_os(cmd=rf'start "" usbipd attach --wsl --busid {bus_id} --auto-attach')

    # usb/ip attached to wsl
    # signiture="제공된 이름의 배포가 없습니다" or 'xxxx'
    std_list = cmd_to_os(cmd=rf"wsl -d {wsl_distro_n} lsusb", encoding='utf-16')  # watch -n 1 lsusb
    if check_signiture_in_loop(time_limit=10, working_list=std_list, signiture="제공된 이름의 배포가 없습니다", signiture_found_ment="wsl 에 attach 할수없었습니다"):
        raise
    if check_signiture_in_loop(time_limit=10, working_list=std_list, signiture="NVidia Corp.", signiture_found_ment="wsl 에 attach 되었습니다"):
        return


def get_vpc_core_cnt_via_scp(vpc_data_raw):
    config_remote_os = {}
    config_remote_os['ip'] = vpc_data_raw.vpc_ip
    config_remote_os['port'] = vpc_data_raw.vpc_port
    config_remote_os['user_n'] = vpc_data_raw.vpc_user_n
    config_remote_os['local_ssh_private_key'] = vpc_data_raw.vpc_local_ssh_private_key
    config_remote_os['local_ssh_public_key'] = vpc_data_raw.vpc_local_ssh_public_key
    std_out_list, std_err_list = cmd_to_remote_os(cmd='ifconfig', **config_remote_os)


def get_vpc_processer_name_via_scp(vpc_data_raw):
    config_remote_os = {}
    config_remote_os['ip'] = vpc_data_raw.vpc_ip
    config_remote_os['port'] = vpc_data_raw.vpc_port
    config_remote_os['user_n'] = vpc_data_raw.vpc_user_n
    config_remote_os['local_ssh_private_key'] = vpc_data_raw.vpc_local_ssh_private_key
    config_remote_os['local_ssh_public_key'] = vpc_data_raw.vpc_local_ssh_public_key
    std_out_list, std_err_list = cmd_to_remote_os(cmd='ifconfig', **config_remote_os)


def get_vpc_data_raw_from_vpc_request():
    from pkg_py.pk_core_constants import D_PKG_TOML
    import os
    from pkg_py.pk_core_class import A2zCarDataStructure
    from pkg_py.pk_core_constants import D_HOME
    vpc_data_raw = A2zCarDataStructure.RemoteDeviceDataStructure()

    # no
    # request_template = {}
    # request_template['vpc_type'] = 'no'
    # request_template['vpc_purpose'] = 'a2z_vehicle(undefined purpose)'  # 'a2z_vehicle(undefined purpose)', 'a2z_vehicle(For Internal A2Z Development)'
    # request_template['vpc_aifw_version'] = '2.2.4.0'
    # request_template['vpc_jetpack_version'] = '5.1.2'
    # request_template['vpc_jetson_setup_ver'] = '2.0.1'
    # request_template['vpc_side'] = 'a'
    # request_template['vpc_aifw_packing_mode'] = 1  # 1 : a2z 납품차량용   , 0 : a2z 내부테스트용
    # request_template['vpc_flash_image_version'] = '1.0.0'
    # if request_template['vpc_flash_image_version'] == '':
    #     request_template['vpc_with_flash_image'] = 0  # 0 : flash image 없음
    # else:
    #     request_template['vpc_with_flash_image'] = 1  # 1 : flash image 있음
    # request_template['vpc_identifier_number'] = f'00'
    # request_template['vpc_identifier'] = f'{request_template['vpc_type']} #{request_template['vpc_identifier_number']}'

    # nx
    # request_template = {}
    # request_template['vpc_type'] = 'nx'
    # request_template['vpc_purpose'] = 'a2z_vehicle(undefined purpose)'  # 'a2z_vehicle(undefined purpose)', 'a2z_vehicle(For Internal A2Z Development)'
    # request_template['vpc_aifw_version'] = '2.2.4.0'
    # request_template['vpc_jetpack_version'] = '5.0.2'
    # request_template['vpc_jetson_setup_ver'] = '2.0.1'
    # request_template['vpc_side'] = 'a'
    # request_template['vpc_aifw_packing_mode'] = 1  # 1 : a2z 납품차량용   , 0 : a2z 내부테스트용
    # request_template['vpc_flash_image_version'] = '1.3.0'
    # if request_template['vpc_flash_image_version'] == '':
    #     request_template['vpc_with_flash_image'] = 0  # 0 : flash image 없음
    # else:
    #     request_template['vpc_with_flash_image'] = 1  # 1 : flash image 있음
    # request_template['vpc_identifier_number'] = f'00'
    # request_template['vpc_identifier'] = f'{request_template['vpc_type']} #{request_template['vpc_identifier_number']}'

    # xc
    # request_template = {}
    # request_template['vpc_type'] = 'xc'
    # request_template['vpc_purpose'] = 'a2z_vehicle(undefined purpose)'  # 'a2z_vehicle(undefined purpose)', 'a2z_vehicle(For Internal A2Z Development)'
    # request_template['vpc_aifw_version'] = '1.2.1'
    # request_template['vpc_jetpack_version'] = '4.6.5'
    # request_template['vpc_jetson_setup_ver'] = ''
    # request_template['vpc_side'] = 'a'
    # request_template['vpc_aifw_packing_mode'] = 1  # 1 : a2z 납품차량용   , 0 : a2z 내부테스트용
    # request_template['vpc_flash_image_version'] = '1.0.0'
    # if request_template['vpc_flash_image_version'] == '':
    #     request_template['vpc_with_flash_image'] = 0  # 0 : flash image 없음
    # else:
    #     request_template['vpc_with_flash_image'] = 1  # 1 : flash image 있음
    # request_template['vpc_identifier_number'] = f'00'
    # request_template['vpc_identifier'] = f'{request_template['vpc_type']} #{request_template['vpc_identifier_number']}'

    # tab version
    request_template = {}
    request_template['vpc_type'] = get_pk_input(message="request_template['vpc_type']=", answer_options=['xc', 'nx', 'no'])
    request_template['vpc_purpose'] = get_pk_input(message="request_template['vpc_purpose']=", answer_options=['a2z_vehicle(undefined purpose)', 'a2z_vehicle(undefined purpose)', 'a2z_vehicle(For Internal A2Z Development)'])
    request_template['vpc_aifw_version'] = get_pk_input(message="request_template['vpc_aifw_version']=", answer_options=['1.2.1', '2.2.4.1', '2.2.4.1'])
    request_template['vpc_jetpack_version'] = get_pk_input(message="request_template['vpc_jetpack_version']=", answer_options=['4.6.5', '5.0.2', '5.1.2'])
    request_template['vpc_jetson_setup_ver'] = get_pk_input(message="request_template['vpc_jetson_setup_ver']=", answer_options=['', '2.0.1', '2.0.1'])
    request_template['vpc_side'] = get_pk_input(message="request_template['vpc_side']=", answer_options=['a', 'b'])
    request_template['vpc_aifw_packing_mode'] = get_pk_input(message="request_template['vpc_aifw_packing_mode']=", answer_options=['1: a2z 납품차량용 ', '0: a2z 내부테스트용'])
    request_template['vpc_flash_image_version'] = get_pk_input(message="request_template['vpc_flash_image_version']=", answer_options=['1.0.0', '1.3.0', '1.0.0'])
    if request_template['vpc_flash_image_version'] == '':
        request_template['vpc_with_flash_image'] = '0'  # 0 : flash image 없음
    else:
        request_template['vpc_with_flash_image'] = '1'  # 1 : flash image 있음
    request_template['vpc_identifier_number'] = get_pk_input(message="request_template['vpc_identifier_number']=", answer_options=['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20'])
    request_template['vpc_identifier'] = f'{request_template['vpc_type']} #{request_template['vpc_identifier_number']}'

    vpc_data_raw.vpc_local_ssh_public_key = os.path.join(D_HOME, ".ssh", "id_ed25519.pub")
    vpc_data_raw.vpc_local_ssh_private_key = os.path.expanduser("~/.ssh/id_ed25519")
    # vpc_ip_ = get_pk_token(f_token=rf'{D_PKG_TOML}/pk_token_ip_vpc_side_{vpc_data_raw.vpc_side}.toml', initial_str="")
    # vpc_data_raw.vpc_ip = get_ip_available_by_user_input()
    # if request_template['vpc_side'] == 'a':
    #     vpc_data_raw.vpc_ip = get_pk_token(f_token=rf'{D_PKG_TOML}/pk_token_ip_vpc_a_side.toml', initial_str="")
    # elif request_template['vpc_side'] == 'b':
    #     vpc_data_raw.vpc_ip = get_pk_token(f_token=rf'{D_PKG_TOML}/pk_token_ip_vpc_b_side.toml', initial_str="")
    # else:
    #     raise
    vpc_data_raw.vpc_ip = None
    vpc_data_raw.vpc_port = get_pk_token(f_token=rf'{D_PKG_TOML}/pk_token_ssh_port_vpc.toml', initial_str="")
    vpc_data_raw.vpc_user_n = get_pk_token(f_token=rf'{D_PKG_TOML}/pk_token_user_n_vpc.toml', initial_str="")
    vpc_data_raw.vpc_pw = get_pk_token(f_token=rf'{D_PKG_TOML}/pk_token_pw_vpc.toml', initial_str="")
    vpc_data_raw.vpc_purpose = request_template['vpc_purpose']
    vpc_data_raw.vpc_available_test_ip_set = ('192.168.2.114', '192.168.2.124', '192.168.10.114', vpc_data_raw.vpc_ip)  # ensure ip 할때, vpc_dev_available_ip_list 에서 연결 가능한 것을 우선순위를 두고 자동선택하도록, pickle 써보자.
    vpc_data_raw.vpc_side = request_template['vpc_side']
    vpc_data_raw.vpc_aifw_packing_mode = request_template['vpc_aifw_packing_mode']
    vpc_data_raw.vpc_with_flash_image = request_template['vpc_with_flash_image']
    vpc_data_raw.vpc_flash_image_version = request_template['vpc_flash_image_version']
    # vpc_data_raw.vpc_aifw_version = check_latest_aifw_version_and_get_version_seleted(vpc_data_raw.vpc_identifier, aifw_version=request_template['vpc_aifw_version'])
    vpc_data_raw.vpc_aifw_version = request_template['vpc_aifw_version']
    vpc_data_raw.vpc_type = request_template['vpc_type']
    vpc_data_raw.vpc_identifier_number = request_template['vpc_identifier_number']
    vpc_data_raw.vpc_jetpack_version = check_latest_jetpack_version_and_get_version_seleted(vpc_data_raw.vpc_identifier, jetpack_version=request_template['vpc_jetpack_version'])
    vpc_data_raw.vpc_wired_connection_reset = {'wired_connection_no': '(not defined)', "address": rf"", "method": "auto", "gateway": "", "dns": ""}
    vpc_data_raw.vpc_wired_connection_1_new = {'wired_connection_no': 1, "address": rf"{vpc_data_raw.vpc_ip}/24", "method": "manual", "gateway": "", "dns": ""}
    vpc_data_raw.vpc_wired_connection_3_new = {'wired_connection_no': 3, "address": rf"{vpc_data_raw.vpc_ip}/24", "method": "manual", "gateway": "", "dns": ""}
    vpc_data_raw.vpc_core_cnt = get_vpc_core_cnt_via_scp(vpc_data_raw)
    vpc_data_raw.vpc_proceser_name = get_vpc_processer_name_via_scp(vpc_data_raw)
    vpc_data_raw.vpc_nvidia_serial = get_vpc_nvidia_serial_via_scp(vpc_data_raw)
    # vpc_data_raw.vpc_type = get_vpc_type_conected_via_scp(vpc_data_raw)
    # vpc_data_raw.vpc_identifier = get_vpc_identifier_matched_from_vpc_db(vpc_data_raw.vpc_nvidia_serial, vpc_data_raw.vpc_side)
    vpc_data_raw.vpc_identifier = request_template['vpc_identifier']
    return vpc_data_raw


def get_vpc_identifier_and_vpc_nvidia_serial_map():
    # todo from vpc_db.sqlite     
    return {
        'nvidia_serail_example1': 'NO #1 a side',
        'nvidia_serail_example2': 'NO #1 b side',
        'nvidia_serail_example3': 'NX #1 a side',
        'nvidia_serail_example4': 'NX #1 b side',
        'nvidia_serail_example5': 'XC #1',
        'nvidia_serail_example6': 'EVM #1',
    }


def save_vpc_tracking_map_with_nvidia_serial_to_vpc_mamnagement_map_toml(vpc_data):
    from pkg_py.pk_core_constants import F_VPC_MAMNAGEMENT_MAP_TOML

    f = F_VPC_MAMNAGEMENT_MAP_TOML

    config_remote_os = vpc_data.config_remote_os
    nvidia_serial = vpc_data.vpc_nvidia_serial

    answer_about_vpc_type = None
    answer_about_side = None
    answer_about_vpc_number = None
    state_to_save = 0
    while 1:
        if state_to_save == 1:
            # todo save
            if answer_about_vpc_number:
                pass
            if answer_about_vpc_type:
                pass
            if answer_about_side:
                pass
            data_to_save_to_toml = {
                f'{nvidia_serial}': f'{answer_about_vpc_type} #{answer_about_vpc_number} {answer_about_side} side',
            }
            # add_data_to_f_toml()
            break
        answer_about_vpc_type = input('no or nx or xc or evm')
        answer_about_vpc_type = answer_about_vpc_type.strip()
        answer_about_vpc_type = answer_about_vpc_type.lower()
        vpc_type = get_vpc_type_conected_via_scp(**config_remote_os)
        if not vpc_type:
            if answer_about_vpc_type == 'no' or answer_about_vpc_type == 'nx':
                answer_about_side = input('a or b?')
                if answer_about_side == 'a' or answer_about_side == 'b':
                    state_to_save = 1
                else:
                    continue
            elif answer_about_vpc_type == 'xc' or answer_about_vpc_type == 'evm':
                state_to_save = 1
                continue
            else:
                # todo red
                continue


def get_vpc_nvidia_serial_via_scp(vpc_data):
    config_remote_os = {}
    config_remote_os['ip'] = vpc_data.vpc_ip
    config_remote_os['port'] = vpc_data.vpc_port
    config_remote_os['user_n'] = vpc_data.vpc_user_n
    config_remote_os['local_ssh_private_key'] = vpc_data.vpc_local_ssh_private_key
    cmd_to_remote_os(cmd='todo', **config_remote_os)
    nvidia_serial = vpc_data.vpc_nvidia_serial
    return nvidia_serial


def get_vpc_identifier(**config_remote_os):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import PK_BLANK
    vpc_nvidia_serial = get_vpc_nvidia_serial_via_scp(**config_remote_os)
    vpc_identifier_dict = get_vpc_identifier_and_vpc_nvidia_serial_map()
    for nvidia_serial, nick_name in vpc_identifier_dict.items():
        if vpc_nvidia_serial not in nick_name:
            continue
        elif vpc_nvidia_serial in nick_name:
            nvidia_serial = nvidia_serial.replace(PK_BLANK, "_")
            return nvidia_serial
    pk_print(working_str=rf'''vpc_identifier not found in {get_vpc_identifier_and_vpc_nvidia_serial_map()} ).  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
    raise


def get_vpc_type_conected_via_scp(vpc_data_raw):
    # todo : jetson_setup identify.py 참고
    # todo : processer name    core cnt    로 vpc 특징을 판단

    return 'no'

    config_remote_os = {}
    config_remote_os['ip'] = vpc_data_raw.vpc_ip
    config_remote_os['port'] = vpc_data_raw.vpc_port
    config_remote_os['user_n'] = vpc_data_raw.vpc_user_n
    config_remote_os['local_ssh_private_key'] = vpc_data_raw.vpc_local_ssh_private_key

    vpc_type = None
    vpc_ip = config_remote_os['ip']

    vpc_core_cnt_of_evm = 8
    vpc_core_cnt_of_xc = 8
    vpc_core_cnt_of_nx = 8
    vpc_core_cnt_of_no = 8
    vpc_processser_name_of_evm = 'todo'
    vpc_processser_name_of_xc = 'todo'
    vpc_processser_name_of_nx = 'todo'
    vpc_processser_name_of_no = 'todo'
    # vpc_current_upper_limit =
    # vpc_power_upper_limit =    
    # vpc_cpu_clock_upper_limit =

    vpc_identifier_and_vpc_nvidia_serial_map_dict = get_vpc_identifier_and_vpc_nvidia_serial_map()
    for vpc_nvidia_serial, vpc_identifier in vpc_identifier_and_vpc_nvidia_serial_map_dict.items():
        if vpc_nvidia_serial != vpc_data_raw.vpc_nvidia_serial:
            continue
        elif vpc_nvidia_serial == vpc_data_raw.vpc_nvidia_serial:
            vpc_type = vpc_nvidia_serial.split(f"{PK_BLANK}#")[0]
            return vpc_type
        else:
            pk_print(working_str=rf'''unkown exception.  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
            raise

    vpc_core_cnt = vpc_data_raw.vpc_core_cnt
    processer_name_of_remote_os = vpc_data_raw.vpc_proceser_name
    if vpc_core_cnt == vpc_core_cnt_of_no and processer_name_of_remote_os == vpc_processser_name_of_no:
        vpc_type = 'no'
    elif vpc_core_cnt == vpc_core_cnt_of_nx and processer_name_of_remote_os == vpc_processser_name_of_nx:
        vpc_type = 'nx'
    elif vpc_core_cnt == vpc_core_cnt_of_xc and processer_name_of_remote_os == vpc_processser_name_of_xc:
        vpc_type = 'xc'
    elif vpc_core_cnt == vpc_core_cnt_of_evm and processer_name_of_remote_os == vpc_processser_name_of_evm:
        vpc_type = 'evm'
    else:
        pk_print(working_str=rf'''unkown vpc_type (vpc_ip={vpc_ip}, vpc_core_cnt={vpc_core_cnt}, processer_name_of_remote_os={processer_name_of_remote_os} ).  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        raise
    return vpc_type.lower()


def is_vpc_recovery_mode(vpc_data):
    # todo :
    pass


def ensure_vpc_recovery_mode_entered(vpc_data, wsl_data, config_remote_os):
    from pkg_py.pk_colorful_cli_util import pk_print
    if 'no' in vpc_data.vpc_identifier:
        #  vpc 전원연결
        #  REC + PWR 버튼으로 recovery mode 부팅
        #  플래시 하려는 Side와 PC USB 연결
        pass
    elif 'nx' in vpc_data.vpc_identifier:
        pass
    elif 'xc' in vpc_data.vpc_identifier:
        pass
    elif 'evm' in vpc_data.vpc_identifier:
        # connect power
        # remove auto power mode selector pin
        # 전원 진입버튼 # EVM 의 왼쪽 버튼
        # Recovery mode 진입버튼 # EVM 의 가운데 버튼
        # recovery mode 버튼을 3초간 누르고 홀드
        # 전원버튼 3초간 누르고 홀드
        # 두 버튼을 모두 release
        # reinstall auto power mode selector pin
        pass
    else:
        pk_print(f'''unknown vpc_identifier ({vpc_data.vpc_identifier}) {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        raise
    if not is_vpc_recovery_mode(vpc_data):
        # [ATEMPED] 네트워크 케이블 remove 후 재시도
        # [DIAGNOSED] [HUMAN ERROR] 플래시 케이블 연결안함
        pass


def ensure_location_about_system_img_and_system_img_raw(config_remote_os):
    from pkg_py.pk_colorful_cli_util import pk_print
    # ~/Downloads/flash/xc_flash/Linux_for_Tegra/bootloader/ 안에 system.img* 이 있으면 정상.
    dst = '~/Downloads/flash/xc_flash/Linux_for_Tegra/bootloader/'
    cmd = rf'sudo find {dst} -type f -name "system.img*"'
    std_out, std_err = cmd_to_remote_os(cmd=cmd, **config_remote_os)
    std_list = std_out.split('\n')
    if not check_signiture_in_loop(time_limit=10, working_list=std_list, signiture="/bootloader/system.img", signiture_found_ment=rf'system.img found in {dst}'):
        pk_print(working_str=rf'''system.img* not found in the expected path ({dst}).  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        raise  # todo raise 보다는 ipdb 로 대체하여 에러가 난 위치에서 수동으로 재시도 해볼 수 있도록 하는게 나을것 같다. ipdb 가 함수 호출부에서 이루어져도록 수정필요할 수도 있다.


def print_d_working():
    from pkg_py.pk_colorful_cli_util import pk_print
    pk_print(get_d_working())


# @measure_time
# def print_iterable_as_vertical(item_iterable, item_iterable_n='Undefined'):
#     from pkg_py.pk_colorful_cli_util import pk_print
#     from pkg_py.pk_core_constants import STAMP_LIST
#     pk_print(f'''{STAMP} {item_iterable_n}=[''')
#     for index, item in enumerate(item_iterable):
#         if '\n' not in item:
#             pk_print(f'''{STAMP}     {item_iterable_n}[{index}]={item.replace("\n", "")}  {'%%%FOO%%%' if LTA else ''}''')
#         else:
#             pk_print(f'''{STAMP}     {item_iterable_n}[{index}]={item}  {'%%%FOO%%%' if LTA else ''}''')
#     pk_print(f'''{STAMP} ]''')

def print_iterable_as_vertical(item_iterable, item_iterable_n=None, mode_verbose=1):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import STAMP_LIST, STAMP_SET, STAMP_DICT, STAMP_TUPLE
    import inspect

    if mode_verbose == 1:
        # 변수 이름 자동 추출 시도
        if item_iterable_n is None:
            frame = inspect.currentframe()
            outer_frames = inspect.getouterframes(frame)
            try:
                call_line = outer_frames[1].code_context[0]
                var_n = call_line.split('(')[1].split(',')[0].strip()
                item_iterable_n = var_n.replace(')', '')
            except Exception:
                item_iterable_n = 'Undefined'  # 실패 시 기본값
            finally:
                del frame

        if isinstance(item_iterable, list):
            STAMP_DATA_TYPE = STAMP_LIST
            open_bracket, kill_bracket = '[', ']'
        elif isinstance(item_iterable, set):
            STAMP_DATA_TYPE = STAMP_SET
            open_bracket, kill_bracket = '{', '}'
        elif isinstance(item_iterable, dict):
            STAMP_DATA_TYPE = STAMP_DICT
            open_bracket, kill_bracket = '{', '}'
        elif isinstance(item_iterable, tuple):
            STAMP_DATA_TYPE = STAMP_TUPLE
            open_bracket, kill_bracket = '(', ')'
        else:
            STAMP_DATA_TYPE = STAMP_LIST  # 기본값 설정
            open_bracket, kill_bracket = '[', ']'

        # todo : dict 일때 key 는 나오는데 value 안나옴. value 나오도록 업그레이드
        # pk_print(f'''{STAMP_DATA_TYPE} {item_iterable_n}={open_bracket}''')
        pk_print(f'''{STAMP_DATA_TYPE} {open_bracket}''')
        for idx, item in enumerate(item_iterable):
            item_str = str(item).replace("\n", "")
            pk_print(f'''{STAMP_DATA_TYPE}     {item_iterable_n[:5]}...[{idx}]={item_str}  {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''{STAMP_DATA_TYPE} {kill_bracket}''')

    elif mode_verbose == 0:
        for idx, item in enumerate(item_iterable):
            print(f'''{idx} {item}  {'%%%FOO%%%' if LTA else ''}''')


def print_window_opened_list():
    from pkg_py.pk_colorful_cli_util import pk_print
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    window_opened_list = get_window_opened_list()
    for window_opened in window_opened_list:
        pk_print(working_str=rf'[window_opened] {window_opened}')


def print_parents_process_pid():
    import inspect
    import os
    func_n = inspect.currentframe().f_code.co_name
    os.system(rf'powershell (Get-WmiObject Win32_Process -Filter ProcessId=$PID).ParentProcessId')


def print_and_get_text_converted(text: str, convert_mode=0):
    import inspect
    from pkg_py.pk_colorful_cli_util import print_magenta
    """
    # str to str

    param str
    return str
    """
    func_n = inspect.currentframe().f_code.co_name

    def convert_mode_1(text):
        text_converted = text
        while (True):
            if "  " in text:
                text_converted = text.replace("  ", " ")
            else:
                break
        text_converted = text_converted.replace(" ", "\",\"")
        text_converted = f"\"{text_converted}\""
        text_converted = f"[{text_converted}]"
        print_magenta(f'''{inspect.currentframe().f_code.co_name}={text_converted}''')
        return text_converted

    def convert_mode_2(text):
        text_converted = text
        while (True):
            if "  " in text:
                text_converted = text.replace("  ", " ")
            else:
                break
        text_converted = text_converted.replace(" ", "\",\"")
        text_converted = text_converted.replace("\"\"", "\"")
        text_converted = f"\"{text_converted}\""
        text_converted = f"[{text_converted}]"
        print_magenta(f'''{inspect.currentframe().f_code.co_name}={text_converted}''')
        return text_converted

    def convert_mode_3(text):
        text = text.replace("  ", " ")
        text_converted = text.replace(" ", ",")
        print_magenta(f'''{inspect.currentframe().f_code.co_name}={text_converted}''')
        return text_converted

    def convert_mode_4(text):
        texts = text.split(" ")
        texts = get_list_striped_element(working_list=texts)
        text_converted = text
        print_magenta(f'''{inspect.currentframe().f_code.co_name}={text_converted}''')
        return text_converted

    def convert_mode_x(text):
        text_converted = text
        if "  " in text:
            text_converted = text.replace("  ", " ")
        text_converted = text.replace(" ", "\",\"")
        text_converted = f"\"{text_converted}\""
        text_converted = f"[{text_converted}]"
        print_magenta(f'''{inspect.currentframe().f_code.co_name}={text_converted}''')
        return text_converted

    def convert_mode_0(text):
        convert_mode_1(text)
        convert_mode_2(text)
        convert_mode_3(text)
        convert_mode_4(text)
        convert_mode_x(text)

    if convert_mode == 0:
        convert_mode_0(text)
        return None

    elif convert_mode == 1:
        return convert_mode_1(text)
    elif convert_mode == 2:
        return convert_mode_2(text)
    else:
        return None


def print_json_via_jq_pkg(json_str=None, json_file=None, json_list=None):
    import inspect
    import json
    from pkg_py.pk_colorful_cli_util import pk_print, print_light_white
    from pkg_py.pk_core_constants import F_JQ_WIN64_EXE
    func_n = inspect.currentframe().f_code.co_name

    if get_os_n() == 'windows':
        if get_count_none_of_list([json_str, json_file, json_list]) == 2:  # 2개가 NONE이면 1나는 BINDING 된것으로 판단하는 로직
            if json_str is not None:
                # lines=run_via_cmd_exe(cmd=rf'echo "{json_str}" | {JQ_WIN64_EXE} "."') # 나오긴 하는데 한줄로 나온다
                # lines=run_via_cmd_exe(cmd=rf'echo "{json_str}" | python -mjson.tool ')# 나오긴 하는데 한줄로 나온다
                # [print_as_success(line) for line in lines]
                json_str = json.dumps(json_str, indent=4)  # json.dumps() 함수는 JSON 데이터를 문자열로 변환하는 함수이며, indent 매개변수를 사용하여 들여쓰기를 설정하여 json 형태의 dict 를 예쁘게 출력할 수 있습니다.
                print_light_white(json_str)
            if json_file is not None:
                lines = cmd_to_os_like_person_as_admin(cmd=rf"type {json_file} | {F_JQ_WIN64_EXE} ")
                [print_light_white(line) for line in lines]
            if json_list is not None:
                lines = cmd_to_os_like_person_as_admin(cmd=rf'echo "{json_list}" | "{F_JQ_WIN64_EXE}" ')
                [print_light_white(line) for line in lines]
        else:
            pk_print(working_str=rf"{inspect.currentframe().f_code.co_name}() 를 사용하려면 json_str/json_file/json_list 파라미터들 중 둘 중 하나만 데이터바인딩이 되어야합니다")
    else:
        pk_print(working_str="리눅스 시스템에서 아직 지원되지 않는 함수입니다")


def print_current_mouse_abs_info():
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    import ipdb
    func_n = inspect.currentframe().f_code.co_name
    x, y = get_current_mouse_abs_info()
    pk_print(f'''x="{x}"''')
    pk_print(f'''y="{y}"''')

    ipdb.set_trace()


# 출력의 결과는 tasklist /svc 와 유사하다.
def print_python_process_for_killing_zombie_process():
    import inspect
    import psutil
    func_n = inspect.currentframe().f_code.co_name
    for process in psutil.process_iter():
        print(rf'str(process.pid) : {str(process.pid)}')
        print(rf'process.status() : {process.status()}')
        print(rf'process.name() : {process.name()}')


def print_and_open_py_pkg_global_path():
    import sys
    from pkg_py.pk_colorful_cli_util import pk_print
    for sys_path in sys.path:
        pk_print(working_str=sys_path)
        if is_pattern_in_prompt(prompt=sys_path, pattern='site-packages') == True:
            pk_print(f'''sys_path={sys_path}  {'%%%FOO%%%' if LTA else ''}''')
            pk_print(working_str=rf'echo "{sys_path}"')
            open_pnx_by_ext(sys_path)


def print_os_sys_environment_variables():
    import os
    import ipdb
    print_iterable_as_vertical(item_iterable=os.environ, item_iterable_n='모든 시스템 환경변수 출력')

    ipdb.set_trace()


def print_wired_connection_list(config_remote_os, wired_connection_no_range):
    import re
    ensure_ubuntu_pkg_to_remote_os(ubuntu_pkg_n='net-tools', **config_remote_os)

    for wired_connection_no in wired_connection_no_range:
        stdout_list = []

        # 한 번만 호출하여 전체 정보를 가져오기
        cmd = f"sudo nmcli connection show 'Wired connection {wired_connection_no}'"
        std_out_list, std_err_list = cmd_to_remote_os(cmd=cmd, **config_remote_os)

        # list to str
        std_out = get_str_from_list(working_list=std_out_list)

        # parse
        ipv4_address = re.search(r'ipv4.addresses\s*:\s*([\d\.\/]+)', std_out)  # 수정된 정규식
        ipv4_method = re.search(r'ipv4.method\s*:\s*(\S+)', std_out)
        ipv4_gateway = re.search(r'ipv4.gateway\s*:\s*(\S+)', std_out)
        ipv4_dns = re.search(r'ipv4.dns\s*:\s*(\S+)', std_out)

        # None filter
        not_parsed = "(not parsed)"
        ipv4_address = ipv4_address.group(1) if ipv4_address else not_parsed
        ipv4_method = ipv4_method.group(1) if ipv4_method else not_parsed
        ipv4_gateway = ipv4_gateway.group(1) if ipv4_gateway else not_parsed
        ipv4_dns = ipv4_dns.group(1) if ipv4_dns else not_parsed

        # strip() filter
        ipv4_address = ipv4_address.strip()
        ipv4_method = ipv4_method.strip()
        ipv4_gateway = ipv4_gateway.strip()
        ipv4_dns = ipv4_dns.strip()

        # add to list
        stdout_list.append(f"___________________________________________________________")
        if not_parsed in ipv4_address:
            stdout_list.append(f"{not_parsed}")
        else:
            stdout_list.append(f"ipv4.address: {ipv4_address}")
            stdout_list.append(f"ipv4.method: {ipv4_method}")
            stdout_list.append(f"ipv4.gateway: {ipv4_gateway}")
            stdout_list.append(f"ipv4.dns: {ipv4_dns}")
        stdout_list.append(f"___________________________________________________________")

        # 수직으로 출력
        print_iterable_as_vertical(item_iterable=stdout_list, item_iterable_n=f"Wired connection {wired_connection_no}")


def print_original_log_f(issue_log_index_data):
    import re
    from pkg_py.pk_colorful_cli_util import pk_print

    original_log = True

    # 전처리
    if isinstance(issue_log_index_data["_f_ 위치"], float):
        issue_log_index_data["_f_ 위치"] = ""

    issue_file_name = issue_log_index_data["_f_ 위치"].split('/')[-1]

    def get_origin_log_file_name(issue_file_name):
        # 정규식 패턴 정의: "_숫자(최대 2자리)_VIDEO"
        pattern = r"_\d{1,2}_VIDEO"
        original_filename = re.sub(pattern, "", issue_file_name)
        return original_filename

    origin_log_file_name = get_origin_log_file_name(issue_file_name)
    issue_log_index_data["주행일자"] = issue_log_index_data["_f_ 위치"].split('/')[0]
    issue_log_index_data["_f_ 위치"] = issue_log_index_data["_f_ 위치"].replace("/", f"\\")

    src = rf"\\192.168.1.33\01_Issue\{issue_log_index_data["_f_ 위치"]}"
    pk_print(working_str=rf'''src="{src}"  {'%%%FOO%%%' if LTA else ''}''')
    if original_log == True:
        src = rf"\\192.168.1.33\02_Orignal\{issue_log_index_data["차량"]}\{issue_log_index_data["지역"]}\{issue_log_index_data["주행일자"]}\{issue_log_index_data["코스"]}\{origin_log_file_name}"
        pk_print(working_str=rf'''src="{src}"  {'%%%FOO%%%' if LTA else ''}''')
        return


def print_sub_pnx_list(src):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import F_DB_YAML, F_SUCCESS_LOG, F_LOCAL_PKG_CACHE

    txt_to_exclude_list = [
        F_DB_YAML,
        F_SUCCESS_LOG,
        F_LOCAL_PKG_CACHE,
    ]

    # dir_pnxs, file_pnxs = get_sub_pnxs_without_walking(pnx=item_pnx, txt_to_exclude_list=txt_to_exclude_list)
    d_list, f_list = get_sub_pnx_list(pnx=src, txt_to_exclude_list=txt_to_exclude_list)

    pnx_list = d_list + f_list

    # 확인
    print_iterable_as_vertical(item_iterable=pnx_list, item_iterable_n="바꿀 대상")
    pk_print(working_str=rf'''len(pnxs)="{len(pnx_list)}"  {'%%%FOO%%%' if LTA else ''}''')


def print_and_open_original_log_position(area_id, course_id, vehicle_id, steering_date=None):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print

    # 매개변수가 None이면 빈 문자열을 할당
    foo = "????????"
    vehicle_id = vehicle_id if vehicle_id is not None else foo
    area_id = area_id if area_id is not None else foo
    steering_date = steering_date if steering_date is not None else foo
    course_id = course_id if course_id is not None else foo

    func_n = inspect.currentframe().f_code.co_name
    pk_print(working_str=rf'''{func_n}()  {'%%%FOO%%%' if LTA else ''}''', print_color='blue')
    data_required = {}
    data_required["차량"] = vehicle_id
    data_required["지역"] = area_id
    data_required["주행일자"] = steering_date
    data_required["코스"] = course_id

    # def get_origin_log_file_name(issue_file_name):
    #     # 정규식 패턴 정의: "_숫자(최대 2자리)_VIDEO"
    #     pattern = r"_\d{1,2}_VIDEO"
    #     original_filename = re.sub(pattern, "", issue_file_name)
    #     return original_filename

    # 정의
    # issue_file_name = issue_log_index_data["_f_ 위치"].split('/')[-1]
    # origin_log_file_name = get_origin_log_file_name(issue_file_name)
    original_log_position = rf"\\192.168.1.33\02_Orignal\{data_required['차량']}\{data_required['지역']}\{data_required['주행일자']}\{data_required['코스']}"
    pk_print(working_str=rf'''original_log_position="{original_log_position}"  {'%%%FOO%%%' if LTA else ''}''', print_color='blue')
    if foo not in original_log_position:
        cmd_to_os(cmd=rf'explorer "{original_log_position}" ')
    else:
        pk_print(f'''수집한 오리지널 로그_f_의 경로가 온전하지 않습니다.''', print_color='red')


def print_template_for_notion_issue_reporting(line_order, issues_list_csv):
    from pkg_py.pk_colorful_cli_util import pk_print
    pk_print(working_str=rf'''노션 이슈발생 템플릿  {'%%%FOO%%%' if LTA else ''}''', print_color='white')
    collect_row_data = collect_row_data_from_csv(line_order=line_order, issues_list_csv=issues_list_csv)
    pk_print(string=f'''차량 : {collect_row_data["차량"]}''', print_color='white')
    pk_print(string=f'''지역 : {collect_row_data["지역"]}''', print_color='white')
    pk_print(string=f'''코스 : {collect_row_data["코스"]}''', print_color='white')
    pk_print(string=f'''운전자 : {collect_row_data['Crew']}''', print_color='white')
    # pk_print(string=f'''문제점 상세 : \n{collect_row_data["문제점 상세"].replace("\n\n","\n")}''', print_color='white')
    pk_print(string=f'''문제점 상세 : \n{collect_row_data["문제점 상세"].replace("\n", "")}''', print_color='white')
    pk_print(string=f'''''', print_color='white')
    pk_print(string=f'''SW 버전 : {collect_row_data["SW 버전"]}''', print_color='white')
    f위치 = collect_row_data["_f_ 위치"]
    if isinstance(f위치, float):
        f위치 = ""
    pk_print(string=f'''_f_명 : {f위치}''', print_color='white')


def print_function_run_measure_seconds_via_timeit(function, repeat):
    """
    특정 함수의 평균 exec  시간을 측정하여 로그로 출력합니다.
    """
    # todo : f에 결과즐 저장해서 통계를 내릴 수 있도록한다.
    from pk_colorful_cli_util import pk_print
    import timeit
    from functools import partial as functools_partial

    if isinstance(function, functools_partial):
        func_n = function.func.__name__
    else:
        func_n = function.__name__

    execution_time = timeit.timeit(function, number=repeat)
    pk_print(f"{func_n}() : {repeat}번 반복 평균 exec  시간: {execution_time:.6f} seconds", print_color='yellow')


def kill_cmd_exe():
    from pkg_py.pk_colorful_cli_util import pk_print

    try:
        pids = get_pids("cmd.exe")
        for pid in pids:
            kill_process(pid=pid)
    except:
        pk_print(working_str=rf'''{'%%%FOO%%%' if LTA else ''}''', print_color='red')


def kill_powershell_exe(debug_mode=True):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    try:
        pids = get_pids("powershell.exe")
        for pid in pids:
            kill_process_via_wmic(pid=pid)
    except:
        pk_print(working_str=rf'''{'%%%FOO%%%' if LTA else ''}''', print_color='red')


def kill_process_via_wmic(process_img_n=None, debug_mode=True):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name
    if process_img_n is not None:
        pk_print(rf"{func_n}() 동작 조건 충족")
    else:
        pk_print(rf"{func_n}() 동작 조건 불충족")
        return

    if process_img_n is not None:
        process_img_n = process_img_n.replace("\'", "")
        process_img_n = process_img_n.replace("\"", "")
        cmd_to_os(f'wmic process where name="{process_img_n}" delete ')


def pk_kill_process_v1(cmd_exe_title):
    from pkg_py.pk_colorful_cli_util import pk_print
    import psutil
    pk_print(f'''cmd_exe_title={cmd_exe_title}  {'%%%FOO%%%' if LTA else ''}''', print_color="blue")
    """
    주어진 cmd_exe_title과 일치하는 프로세스를 찾아 동기적으로 종료하는 함수
    """
    for process in psutil.process_iter(['pid', 'name', 'cmdline']):
        try:
            # cmd_exe_title이 프로세스 cmdline에 포함되어 있는지 확인
            if process.info['cmdline'] and any(cmd_exe_title in cmd for cmd in process.info['cmdline']):
                pid = process.info['pid']
                # pk_print(f"[PROCESS TERMINATED] PID={pid}, Name={process.info['name']}")
                proc = psutil.Process(pid)
                proc.terminate()  # 프로세스 종료 요청
                proc.wait(timeout=5)  # 종료 완료를 대기, 최대 5초 대기
                pk_print(f"[PROCESS TERMINATED] PID={pid}, Name={process.info['name']}", print_color="green")
        except psutil.TimeoutExpired:
            pk_print(f"[PROCESS TERMINATED] 시간 초과 ", print_color='red')
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            pass


def pk_kill_process_v2(cmd_exe_title: str):
    import subprocess
    from pkg_py.pk_colorful_cli_util import pk_print
    import csv
    from io import StringIO
    try:
        window_title = get_window_title(window_title_seg=cmd_exe_title)
        if not window_title:
            return
        if LTA:
            pk_print(f'''window_title={window_title} {'%%%FOO%%%' if LTA else ''}''')
        # if not is_window_opened_exactly(window_title=window_title):
        #     return
        cmd = f'tasklist /FI "WINDOWTITLE eq {window_title}" /FO CSV'
        pk_print(f'''cmd={cmd} {'%%%FOO%%%' if LTA else ''}''')
        output = subprocess.check_output(cmd, shell=True, encoding='cp949', errors='ignore')

        matched_pids = set()
        reader = csv.DictReader(StringIO(output))
        for row in reader:
            pid = row.get("PID")
            if pid:
                matched_pids.add(pid)

        for pid in matched_pids:
            subprocess.run(['taskkill', '/PID', pid, '/T', '/F'],
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            pk_print(f"[PK KILL] PID={pid} cmd_exe_title={cmd_exe_title}", print_color="green")

        if not matched_pids:
            pk_print(f"[NO MATCH] '{cmd_exe_title}'와 일치하는 프로세스를 찾지 못했습니다.", print_color="red")

    except subprocess.CalledProcessError:
        pk_print(f"[NO MATCH] '{cmd_exe_title}' 프로세스를 찾지 못했습니다.", print_color="red")
    except Exception as e:
        pk_print(f"[ERROR] {e}", print_color="red")


def pk_kill_process_v3(cmd_exe_title: str):
    import wmi
    import subprocess
    from pkg_py.pk_colorful_cli_util import pk_print

    try:
        window_title = get_window_title(window_title_seg=cmd_exe_title)
        if not window_title:
            # pk_print(f"[SKIP] 창 제목 세그먼트 '{cmd_exe_title}'로 찾은 창이 없습니다.", print_color="blue")
            return

        if LTA:
            pk_print(f"window_title={window_title} {'%%%FOO%%%' if LTA else ''}")

        c = wmi.WMI()
        matched_pids = set()

        for proc in c.Win32_Process():
            try:
                title_match = window_title.lower() in (proc.CommandLine or "").lower()
                caption_match = "cmd.exe" in (proc.Caption or "").lower()

                if title_match and caption_match:
                    matched_pids.add(proc.ProcessId)
            except Exception:
                continue

        for pid in matched_pids:
            subprocess.run(['taskkill', '/PID', str(pid), '/T', '/F'],
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            pk_print(f"[PK KILL] PID={pid} window_title={window_title}", print_color="green")

        if not matched_pids:
            pk_print(f"[NO MATCH] '{window_title}'와 일치하는 프로세스를 찾지 못했습니다.", print_color="red")

    except Exception as e:
        pk_print(f"[ERROR] {e}", print_color="red")


def pk_kill_process_v5(cmd_exe_title: str):
    import psutil
    import subprocess
    from pkg_py.pk_colorful_cli_util import pk_print

    try:
        window_title = get_window_title(window_title_seg=cmd_exe_title)
        if not window_title:
            return

        if LTA:
            pk_print(f"window_title={window_title} {'%%%FOO%%%' if LTA else ''}")

        matched_pids = set()

        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                if 'cmd.exe' in (proc.info['name'] or '').lower() and window_title.lower() in ' '.join(proc.info['cmdline'] or []).lower():
                    matched_pids.add(proc.info['pid'])
            except Exception:
                continue

        for pid in matched_pids:
            try:
                subprocess.run(['taskkill', '/PID', str(pid), '/T', '/F'],
                               stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, timeout=1)
                pk_print(f"[PK KILL] PID={pid} window_title={window_title}", print_color="green")
            except subprocess.TimeoutExpired:
                pk_print(f"[TIMEOUT] PID={pid} taskkill took too long", print_color="yellow")

        if not matched_pids:
            pk_print(f"[NO MATCH] '{window_title}'와 일치하는 프로세스를 찾지 못했습니다.", print_color="red")

    except Exception as e:
        pk_print(f"[ERROR] {e}", print_color="red")


def pk_kill_process_v6(cmd_exe_title: str):
    import psutil
    import subprocess
    from pkg_py.pk_colorful_cli_util import pk_print

    try:
        window_title = get_window_title(window_title_seg=cmd_exe_title)
        if not window_title:
            return

        if LTA:
            pk_print(f"window_title={window_title} {'%%%FOO%%%' if LTA else ''}")

        matched_pids = set()

        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                cmdline = ' '.join(proc.info['cmdline']) if proc.info['cmdline'] else ''
                if 'cmd.exe' in (proc.info['name'] or '').lower() and cmd_exe_title.lower() in cmdline.lower():
                    matched_pids.add(proc.info['pid'])
            except (psutil.AccessDenied, psutil.ZombieProcess, psutil.NoSuchProcess):
                continue
            except Exception as e:
                pk_print(f"[WARN] psutil error: {e}", print_color="yellow")
                continue

        for pid in matched_pids:
            try:
                subprocess.run(
                    ['taskkill', '/PID', str(pid), '/T', '/F'],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                    timeout=1
                )
                pk_print(f"[PK KILL] PID={pid} window_title={window_title}", print_color="green")
            except subprocess.TimeoutExpired:
                pk_print(f"[TIMEOUT] taskkill for PID={pid} timed out", print_color="yellow")
            except Exception as e:
                pk_print(f"[TASKKILL ERROR] PID={pid}, {e}", print_color="red")

        if not matched_pids:
            pk_print(f"[NO MATCH] '{window_title}'와 일치하는 프로세스를 찾지 못했습니다.", print_color="red")

    except Exception as e:
        pk_print(f"[ERROR] {e}", print_color="red")


def pk_kill_process_v7(window_title_seg: str):
    import wmi
    import subprocess
    from pkg_py.pk_colorful_cli_util import pk_print
    try:
        window_title = get_window_title(window_title_seg=window_title_seg)
        if not window_title:
            return
        if LTA:
            pk_print(f"window_title={window_title} {'%%%FOO%%%' if LTA else ''}")
        c = wmi.WMI()
        matched_pids = set()
        for proc in c.query("SELECT ProcessId, CommandLine, Caption FROM Win32_Process"):
            try:
                if "cmd.exe" in (proc.Caption or "").lower() and get_nx(window_title).lower() in (proc.CommandLine or "").lower():
                    matched_pids.add(proc.ProcessId)
            except Exception:
                continue
        for pid in matched_pids:
            subprocess.run(['taskkill', '/PID', str(pid), '/T', '/F'],
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            pk_print(f"PK KILL PID={pid} window_title={window_title}", print_color="green")
        if not matched_pids:
            pk_print(f"PK KILL '{window_title}' not found", print_color="red")

    except Exception as e:
        pk_print(f"[ERROR] {e}", print_color="red")


import psutil


def pk_kill_process_v7_fast(window_title_seg: str):
    import subprocess
    from pkg_py.pk_colorful_cli_util import pk_print

    window_title = get_window_title(window_title_seg=window_title_seg)
    if not window_title:
        return

    if LTA:
        pk_print(f"window_title={window_title} {'%%%FOO%%%' if LTA else ''}")

    target = get_nx(window_title).lower()
    matched_pids = set()

    for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
        try:
            if proc.info['name'].lower() == "cmd.exe":
                cmdline = " ".join(proc.info['cmdline']).lower()
                if target in cmdline:
                    matched_pids.add(proc.info['pid'])
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            continue

    for pid in matched_pids:
        subprocess.run(['taskkill', '/PID', str(pid), '/T', '/F'],
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        pk_print(f"PK KILL PID={pid} window_title={window_title}", print_color="green")

    if not matched_pids:
        pk_print(f"PK KILL '{window_title}' not found", print_color="red")


def pk_kill_process_v8(window_title_seg: str):
    import psutil
    import subprocess
    from pkg_py.pk_colorful_cli_util import pk_print

    try:
        window_title = get_window_title(window_title_seg=window_title_seg)
        if not window_title:
            return

        if LTA:
            pk_print(f"window_title={window_title} {'%%%FOO%%%' if LTA else ''}")

        target = get_nx(window_title).lower()
        matched_pids = set()

        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                if proc.info['name'].lower() == "cmd.exe":
                    cmdline = " ".join(proc.info['cmdline']).lower()
                    if target in cmdline:
                        matched_pids.add(proc.info['pid'])
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue

        for pid in matched_pids:
            subprocess.run(['taskkill', '/PID', str(pid), '/T', '/F'],
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            pk_print(f"PK KILL PID={pid} window_title={window_title}", print_color="green")

        if not matched_pids:
            pk_print(f"PK KILL '{window_title}' not found", print_color="red")

    except Exception as e:
        pk_print(f"[ERROR] {e}", print_color="red")


def pk_kill_process_v9(window_title_seg: str):
    import psutil
    import subprocess
    from concurrent.futures import ThreadPoolExecutor
    from pkg_py.pk_colorful_cli_util import pk_print
    try:
        window_title = get_window_title(window_title_seg=window_title_seg)
        if not window_title:
            return

        if LTA:
            pk_print(f"window_title={window_title} {'%%%FOO%%%' if LTA else ''}")

        target = get_nx(window_title).lower()
        matched_pids = set()

        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                if proc.info['name'].lower() == "cmd.exe":
                    cmdline = " ".join(proc.info['cmdline']).lower()
                    if target in cmdline:
                        matched_pids.add(proc.info['pid'])
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue

        def kill_pid(pid):
            subprocess.run(['taskkill', '/PID', str(pid), '/T', '/F'],
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            pk_print(f"PK KILL PID={pid} window_title={window_title}", print_color="green")

        if matched_pids:
            with ThreadPoolExecutor(max_workers=min(4, len(matched_pids))) as executor:
                executor.map(kill_pid, matched_pids)
        else:
            pk_print(f"PK KILL '{window_title}' not found", print_color="red")

    except Exception as e:
        pk_print(f"[ERROR] {e}", print_color="red")


def pk_kill_process_v10(window_title_seg: str):
    import psutil
    from concurrent.futures import ThreadPoolExecutor
    from pkg_py.pk_colorful_cli_util import pk_print

    try:
        window_title = get_window_title(window_title_seg=window_title_seg)
        if not window_title:
            return

        if LTA:
            pk_print(f"window_title={window_title} {'%%%FOO%%%' if LTA else ''}")

        target = get_nx(window_title).lower()
        matched_pids = set()

        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                if proc.info['name'].lower() == "cmd.exe":
                    cmdline = " ".join(proc.info['cmdline']).lower()
                    if target in cmdline:
                        matched_pids.add(proc.info['pid'])
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue

        def kill_pid_psutil(pid):
            import psutil
            import time

            try:
                proc = psutil.Process(pid)
                proc.terminate()

                start = time.time()
                try:
                    proc.wait(timeout=1)
                except psutil.TimeoutExpired:
                    proc.kill()
                    try:
                        proc.wait(timeout=1)
                    except psutil.TimeoutExpired:
                        pass  # 최종 타임아웃 2초 경과 후 포기

                elapsed = time.time() - start
                if elapsed > 2.0:
                    pk_print(f"PK KILL PID={pid} TIMEOUT_ELAPSED={elapsed:.2f}s", print_color="yellow")
                else:
                    pk_print(f"PK KILL PID={pid} window_title=...", print_color="green")

            except Exception as e:
                pk_print(f"PK KILL ERROR PID={pid} : {e}", print_color="red")

        if matched_pids:
            with ThreadPoolExecutor(max_workers=min(4, len(matched_pids))) as executor:
                executor.map(kill_pid_psutil, matched_pids)
        else:
            pk_print(f"PK KILL '{window_title}' not found", print_color="red")

    except Exception as e:
        pk_print(f"[ERROR] {e}", print_color="red")


def pk_kill_process_v11(window_title_seg: str):
    import psutil
    import win32gui
    import time
    from concurrent.futures import ThreadPoolExecutor
    from pkg_py.pk_colorful_cli_util import pk_print

    try:
        @pk_measure_seconds
        def get_window_title(window_title_seg: str) -> str | None:
            matches = []

            def enum_handler(hwnd, _):
                if win32gui.IsWindowVisible(hwnd):
                    title = win32gui.GetWindowText(hwnd)
                    if window_title_seg.lower() in title.lower():
                        matches.append((hwnd, title))

            win32gui.EnumWindows(enum_handler, None)
            if matches:
                return matches[0][1]
            return None

        window_title = get_window_title(window_title_seg=window_title_seg)
        if not window_title:
            return

        if LTA:
            pk_print(f"window_title={window_title} {'%%%FOO%%%' if LTA else ''}")

        target = get_nx(window_title).lower()
        matched_pids = set()

        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                if proc.info['name'].lower() == "cmd.exe":
                    cmdline = " ".join(proc.info['cmdline']).lower()
                    if target in cmdline:
                        matched_pids.add(proc.info['pid'])
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue

        @pk_measure_seconds
        def kill_pid_psutil(pid):
            try:
                proc = psutil.Process(pid)
                proc.terminate()
                start = time.time()
                try:
                    proc.wait(timeout=1)
                except psutil.TimeoutExpired:
                    proc.kill()
                    try:
                        proc.wait(timeout=1)
                    except psutil.TimeoutExpired:
                        pass

                elapsed = time.time() - start
                if elapsed > 2.0:
                    pk_print(f"PK KILL PID={pid} TIMEOUT_ELAPSED={elapsed:.2f}s", print_color="yellow")
                else:
                    pk_print(f"PK KILL PID={pid} window_title={window_title}", print_color="green")

            except Exception as e:
                pk_print(f"PK KILL ERROR PID={pid} : {e}", print_color="red")

        if matched_pids:
            with ThreadPoolExecutor(max_workers=min(4, len(matched_pids))) as executor:
                executor.map(kill_pid_psutil, matched_pids)
        else:
            pk_print(f"PK KILL '{window_title}' not found", print_color="red")

    except Exception as e:
        pk_print(f"[ERROR] {e}", print_color="red")


def pk_kill_process_v12(window_title_seg: str):
    import psutil
    import win32gui
    import time
    from concurrent.futures import ThreadPoolExecutor
    from pkg_py.pk_colorful_cli_util import pk_print

    try:
        @pk_measure_seconds
        def get_window_title(window_title_seg: str) -> str | None:
            matches = []

            def enum_handler(hwnd, _):
                if win32gui.IsWindowVisible(hwnd):
                    title = win32gui.GetWindowText(hwnd)
                    if window_title_seg.lower() in title.lower():
                        matches.append((hwnd, title))

            win32gui.EnumWindows(enum_handler, None)
            return matches[0][1] if matches else None

        @pk_measure_seconds
        def get_nx(path: str) -> str:
            import os
            return os.path.splitext(os.path.basename(path))[0]

        @pk_measure_seconds
        def monitor_process_state(proc, max_sec=2.5, interval=0.5):
            steps = int(max_sec / interval)
            for _ in range(steps):
                if not proc.is_running():
                    break
                try:
                    cpu = proc.cpu_percent()
                    mem = proc.memory_info().rss / (1024 * 1024)
                    th = proc.num_threads()
                    pk_print(f"🔍 PID={proc.pid} CPU={cpu:.1f}% MEM={mem:.1f}MB TH={th}", print_color="yellow")
                except Exception:
                    pass
                time.sleep(interval)

        window_title = get_window_title(window_title_seg)
        if not window_title:
            return

        if LTA:
            pk_print(f"window_title={window_title} {'%%%FOO%%%' if LTA else ''}")

        target = get_nx(window_title).lower()
        matched_pids = {
            proc.info['pid']
            for proc in psutil.process_iter(['pid', 'name', 'cmdline'])
            if proc.info['name'].lower() == 'cmd.exe'
               and target in " ".join(proc.info.get('cmdline', [])).lower()
        }

        @pk_measure_seconds
        def kill_pid_psutil(pid):
            try:
                proc = psutil.Process(pid)
                proc.terminate()
                start = time.time()

                monitor_process_state(proc)  # 실시간 모니터링 시작

                try:
                    proc.wait(timeout=1)
                except psutil.TimeoutExpired:
                    proc.kill()
                    try:
                        proc.wait(timeout=1)
                    except psutil.TimeoutExpired:
                        pass

                elapsed = time.time() - start
                if elapsed > 2.5:
                    pk_print(f"⚠️ PK KILL PID={pid} TIMEOUT_ELAPSED={elapsed:.2f}s", print_color="red")
                else:
                    pk_print(f"✅ PK KILL PID={pid} window_title={window_title}", print_color="green")
            except Exception as e:
                pk_print(f"❌ PK KILL ERROR PID={pid} : {e}", print_color="red")

        if matched_pids:
            with ThreadPoolExecutor(max_workers=min(4, len(matched_pids))) as executor:
                executor.map(kill_pid_psutil, matched_pids)
        else:
            pk_print(f"PK KILL '{window_title}' not found", print_color="red")

    except Exception as e:
        pk_print(f"[ERROR] {e}", print_color="red")


def pk_kill_process_v13(window_title_seg: str):
    import psutil
    import win32gui
    import time
    from concurrent.futures import ThreadPoolExecutor
    from pkg_py.pk_colorful_cli_util import pk_print

    try:
        @pk_measure_seconds
        def get_window_title(window_title_seg: str) -> str | None:
            matches = []

            def enum_handler(hwnd, _):
                if win32gui.IsWindowVisible(hwnd):
                    title = win32gui.GetWindowText(hwnd)
                    if window_title_seg.lower() in title.lower():
                        matches.append((hwnd, title))

            win32gui.EnumWindows(enum_handler, None)
            return matches[0][1] if matches else None

        @pk_measure_seconds
        def get_nx(path: str) -> str:
            import os
            return os.path.splitext(os.path.basename(path))[0]

        @pk_measure_seconds
        def monitor_process_state(proc, max_sec=2.5, interval=0.5):
            pk_print(f"👁️ Start monitoring PID={proc.pid}", print_color="blue")
            steps = int(max_sec / interval)
            for _ in range(steps):
                if not proc.is_running():
                    break
                try:
                    cpu = proc.cpu_percent()
                    mem = proc.memory_info().rss / (1024 * 1024)
                    th = proc.num_threads()
                    pk_print(f"🔍 PID={proc.pid} CPU={cpu:.1f}% MEM={mem:.1f}MB TH={th}", print_color="blue")
                except Exception:
                    pass
                time.sleep(interval)
            pk_print(f"👁️ End monitoring PID={proc.pid}", print_color="blue")

        window_title = get_window_title(window_title_seg)
        if not window_title:
            pk_print(f"[SKIP] No window found for seg='{window_title_seg}'", print_color="yellow")
            return

        if LTA:
            pk_print(f"window_title={window_title} {'%%%FOO%%%' if LTA else ''}")

        target = get_nx(window_title).lower()
        matched_pids = {
            proc.info['pid']
            for proc in psutil.process_iter(['pid', 'name', 'cmdline'])
            if proc.info['name'].lower() == 'cmd.exe'
               and target in " ".join(proc.info.get('cmdline', [])).lower()
        }

        failed_pids = []

        @pk_measure_seconds
        def kill_pid_psutil(pid):
            try:
                proc = psutil.Process(pid)
                proc.terminate()
                start = time.time()

                monitor_process_state(proc)

                try:
                    proc.wait(timeout=1)
                except psutil.TimeoutExpired:
                    proc.kill()
                    try:
                        proc.wait(timeout=1)
                    except psutil.TimeoutExpired:
                        pass

                elapsed = time.time() - start
                if elapsed > 5.0:
                    pk_print(f"‼️ FORCED TIMEOUT: PID={pid} took {elapsed:.2f}s", print_color="red")
                    failed_pids.append(pid)
                elif elapsed > 2.5:
                    pk_print(f"⚠️ PK KILL PID={pid} TIMEOUT_ELAPSED={elapsed:.2f}s", print_color="red")
                else:
                    pk_print(f"✅ PK KILL PID={pid} window_title={window_title}", print_color="green")

            except Exception as e:
                failed_pids.append(pid)
                pk_print(f"❌ PK KILL ERROR PID={pid} : {e}", print_color="red")

        if matched_pids:
            with ThreadPoolExecutor(max_workers=min(4, len(matched_pids))) as executor:
                executor.map(kill_pid_psutil, matched_pids)
        else:
            pk_print(f"PK KILL '{window_title}' not found", print_color="red")

        if failed_pids:
            pk_print(f"❗ FAILED PIDs: {sorted(failed_pids)}", print_color="red")

    except Exception as e:
        pk_print(f"[ERROR] {e}", print_color="red")


def is_process_killed(window_title_seg: str, timeout: float = 1.0) -> bool:
    """
    주어진 window_title_seg에 해당하는 CMD 프로세스가 종료되었는지 확인하고 종료 시도.
    :param window_title_seg: 윈도우 제목 일부 문자열
    :param timeout: 종료 대기 시간 (초)
    :return: True (모두 종료됨), False (하나라도 종료 실패)
    """
    import psutil
    import os
    from pkg_py.pk_colorful_cli_util import pk_print

    def get_pids_by_title_seg(windows_title_seg: str) -> list[int]:
        matches = get_window_title(windows_title_seg)
        if not matches:
            return []

        # 첫 번째 매칭된 타이틀을 기준으로 process 검색
        target = os.path.splitext(os.path.basename(matches[0]))[0].lower()
        return [
            proc.info['pid']
            for proc in psutil.process_iter(['pid', 'name', 'cmdline'])
            if proc.info['name'].lower() == 'cmd.exe'
               and target in " ".join(proc.info.get('cmdline', [])).lower()
        ]

    try:
        pids = get_pids_by_title_seg(window_title_seg)

        if not pids:
            pk_print(f"[SKIP] No matching process found for '{window_title_seg}'", print_color="yellow")
            return True  # 이미 종료된 것으로 간주

        all_killed = True

        for pid in pids:
            try:
                proc = psutil.Process(pid)
                proc.terminate()
                try:
                    proc.wait(timeout=timeout)
                except psutil.TimeoutExpired:
                    proc.kill()
                    try:
                        proc.wait(timeout=timeout)
                    except psutil.TimeoutExpired:
                        pk_print(f"🛑 PID={pid} 종료 실패 (TIMEOUT)", print_color="red")
                        all_killed = False
                        continue

                if proc.is_running():
                    pk_print(f"⚠️ PID={pid} 여전히 실행 중", print_color="yellow")
                    all_killed = False
                else:
                    pk_print(f"✅ PID={pid} 종료 확인됨", print_color="green")

            except psutil.NoSuchProcess:
                continue
            except Exception as e:
                pk_print(f"❌ 예외 발생 PID={pid}, error={e}", print_color="red")
                all_killed = False

        return all_killed

    except Exception as e:
        pk_print(f"[ERROR] 전체 종료 확인 실패: {e}", print_color="red")
        return False


def pk_kill_process_v14(window_title_seg: str):
    import psutil
    import win32gui
    import time
    from concurrent.futures import ThreadPoolExecutor
    from pkg_py.pk_colorful_cli_util import pk_print

    try:
        @pk_measure_seconds
        def get_window_title(window_title_seg: str) -> str | None:
            matches = []

            def enum_handler(hwnd, _):
                if win32gui.IsWindowVisible(hwnd):
                    title = win32gui.GetWindowText(hwnd)
                    if window_title_seg.lower() in title.lower():
                        matches.append((hwnd, title))

            win32gui.EnumWindows(enum_handler, None)
            return matches[0][1] if matches else None

        @pk_measure_seconds
        def get_nx(path: str) -> str:
            import os
            return os.path.splitext(os.path.basename(path))[0]

        @pk_measure_seconds
        def monitor_process_state(proc, duration=1.0):
            try:
                pk_print(f"👁️ Monitor PID={proc.pid}", print_color="blue")
                cpu = proc.cpu_percent(interval=duration)
                mem = proc.memory_info().rss / (1024 * 1024)
                th = proc.num_threads()
                pk_print(f"🔍 PID={proc.pid} CPU={cpu:.1f}% MEM={mem:.1f}MB TH={th}", print_color="blue")
            except Exception:
                pass

        window_title = get_window_title(window_title_seg)
        if not window_title:
            pk_print(f"[SKIP] No window found for seg='{window_title_seg}'", print_color="yellow")
            return

        if LTA:
            pk_print(f"window_title={window_title} {'%%%FOO%%%' if LTA else ''}")

        target = get_nx(window_title).lower()
        matched_pids = {
            proc.info['pid']
            for proc in psutil.process_iter(['pid', 'name', 'cmdline'])
            if proc.info['name'].lower() == 'cmd.exe'
               and target in " ".join(proc.info.get('cmdline', [])).lower()
        }

        failed_pids = []

        @pk_measure_seconds
        def kill_pid_psutil(pid):
            try:
                proc = psutil.Process(pid)
                proc.terminate()
                start = time.time()

                monitor_process_state(proc, duration=0.5)

                try:
                    proc.wait(timeout=1)
                except psutil.TimeoutExpired:
                    proc.kill()
                    try:
                        proc.wait(timeout=1)
                    except psutil.TimeoutExpired:
                        pass

                elapsed = time.time() - start
                if elapsed > 5.0:
                    pk_print(f"‼️ FORCED TIMEOUT: PID={pid} took {elapsed:.2f}s", print_color="red")
                    failed_pids.append(pid)
                    return  # 💥 병목 방지용 조기 종료

                if elapsed > 2.5:
                    pk_print(f"⚠️ PK KILL PID={pid} TIMEOUT_ELAPSED={elapsed:.2f}s", print_color="red")
                else:
                    pk_print(f"✅ PK KILL PID={pid} window_title={window_title}", print_color="green")

            except Exception as e:
                failed_pids.append(pid)
                pk_print(f"❌ PK KILL ERROR PID={pid} : {e}", print_color="red")

        if matched_pids:
            with ThreadPoolExecutor(max_workers=4) as executor:
                executor.map(kill_pid_psutil, matched_pids)
        else:
            pk_print(f"PK KILL '{window_title}' not found", print_color="red")

        if failed_pids:
            pk_print(f"❗ FAILED PIDs: {sorted(failed_pids)}", print_color="red")

    except Exception as e:
        pk_print(f"[ERROR] {e}", print_color="red")


def pk_kill_process_v15(window_title_seg: str):
    import psutil
    import win32gui
    import time
    from concurrent.futures import ThreadPoolExecutor
    from pkg_py.pk_colorful_cli_util import pk_print

    try:
        @pk_measure_seconds
        def get_window_matches(window_title_seg: str):
            matches = []

            def enum_handler(hwnd, _):
                if win32gui.IsWindowVisible(hwnd):
                    title = win32gui.GetWindowText(hwnd)
                    if title:
                        similarity = window_title_seg.lower() in title.lower()
                        matches.append((hwnd, title, similarity))

            win32gui.EnumWindows(enum_handler, None)

            # 출력용 정렬: 유사한 것 먼저
            matches.sort(key=lambda x: x[2], reverse=True)
            return matches

        @pk_measure_seconds
        def get_nx(path: str) -> str:
            import os
            return os.path.splitext(os.path.basename(path))[0]

        @pk_measure_seconds
        def monitor_process_state(proc, max_sec=2.5, interval=0.5):
            pk_print(f"👁️ Start monitoring PID={proc.pid}", print_color="blue")
            steps = int(max_sec / interval)
            for _ in range(steps):
                if not proc.is_running():
                    break
                try:
                    cpu = proc.cpu_percent()
                    mem = proc.memory_info().rss / (1024 * 1024)
                    th = proc.num_threads()
                    pk_print(f"🔍 PID={proc.pid} CPU={cpu:.1f}% MEM={mem:.1f}MB TH={th}", print_color="blue")
                except Exception:
                    pass
                time.sleep(interval)
            pk_print(f"👁️ End monitoring PID={proc.pid}", print_color="blue")

        matches = get_window_matches(window_title_seg)

        if not matches:
            pk_print(f"[SKIP] No window found for seg='{window_title_seg}'", print_color="yellow")
            return

        pk_print(f"[INFO] Found {len(matches)} window(s). Similarity check:", print_color="cyan")
        for hwnd, title, is_similar in matches:
            sim_mark = "✅" if is_similar else "  "
            pk_print(f"{sim_mark} [{hwnd}] {title}", print_color="cyan")

        best_match_title = matches[0][1]
        if LTA:
            pk_print(f"🪟 Using best match title: {best_match_title} {'%%%FOO%%%' if LTA else ''}", print_color="cyan")

        target = get_nx(best_match_title).lower()
        matched_pids = {
            proc.info['pid']
            for proc in psutil.process_iter(['pid', 'name', 'cmdline'])
            if proc.info['name'].lower() == 'cmd.exe'
               and target in " ".join(proc.info.get('cmdline', [])).lower()
        }

        failed_pids = []

        @pk_measure_seconds
        def kill_pid_psutil(pid):
            try:
                proc = psutil.Process(pid)
                proc.terminate()
                start = time.time()

                monitor_process_state(proc)

                try:
                    proc.wait(timeout=1)
                except psutil.TimeoutExpired:
                    proc.kill()
                    try:
                        proc.wait(timeout=1)
                    except psutil.TimeoutExpired:
                        pass

                elapsed = time.time() - start
                if elapsed > 5.0:
                    pk_print(f"‼️ FORCED TIMEOUT: PID={pid} took {elapsed:.2f}s", print_color="red")
                    failed_pids.append(pid)
                elif elapsed > 2.5:
                    pk_print(f"⚠️ PK KILL PID={pid} TIMEOUT_ELAPSED={elapsed:.2f}s", print_color="red")
                else:
                    pk_print(f"✅ PK KILL PID={pid} window_title={best_match_title}", print_color="green")

            except Exception as e:
                failed_pids.append(pid)
                pk_print(f"❌ PK KILL ERROR PID={pid} : {e}", print_color="red")

        if matched_pids:
            with ThreadPoolExecutor(max_workers=min(4, len(matched_pids))) as executor:
                executor.map(kill_pid_psutil, matched_pids)
        else:
            pk_print(f"PK KILL '{best_match_title}' not found", print_color="red")

        if failed_pids:
            pk_print(f"❗ FAILED PIDs: {sorted(failed_pids)}", print_color="red")

    except Exception as e:
        pk_print(f"[ERROR] {e}", print_color="red")


def pk_kill_process(window_title: str):
    import psutil
    import win32gui
    import win32process
    from concurrent.futures import ThreadPoolExecutor
    from pkg_py.pk_colorful_cli_util import pk_print
    try:
        def enum_handler(hwnd, matches):
            if win32gui.IsWindowVisible(hwnd):
                title = win32gui.GetWindowText(hwnd)
                if title and title.lower() == window_title.lower():
                    matches.append((hwnd, title))

        matches = []
        win32gui.EnumWindows(lambda h, _: enum_handler(h, matches), None)

        if not matches:
            pk_print(f"[SKIP] No exact window found: '{window_title}'", print_color="yellow")
            return

        pk_print(f"[INFO] Found {len(matches)} exact window(s) for '{window_title}'", print_color="cyan")

        matched_pids = set()
        for hwnd, title in matches:
            try:
                _, pid = win32process.GetWindowThreadProcessId(hwnd)
                matched_pids.add(pid)
            except Exception:
                continue

        if not matched_pids:
            pk_print(f"[ERROR] Found window(s) but no PIDs for '{window_title}'", print_color="red")
            return

        # 3) PID별 종료 시도
        failed = []

        def kill_pid(pid):
            try:
                proc = psutil.Process(pid)
                proc.terminate()
                try:
                    proc.wait(timeout=1)
                except psutil.TimeoutExpired:
                    proc.kill()
                    proc.wait(timeout=1)
                pk_print(f"✅ KILLED PID={pid} ('{window_title}')", print_color="green")
            except Exception as e:
                failed.append(pid)
                pk_print(f"❌ FAILED PID={pid}: {e}", print_color="red")

        with ThreadPoolExecutor(max_workers=min(4, len(matched_pids))) as ex:
            ex.map(kill_pid, matched_pids)

        if failed:
            pk_print(f"❗ FAILED PIDs: {sorted(failed)}", print_color="red")

    except Exception as e:
        pk_print(f"[ERROR] {e}", print_color="red")


def pk_kill_process_by_window_title_seg(window_title_seg: str):
    import psutil
    import win32gui
    import win32process
    import time
    from concurrent.futures import ThreadPoolExecutor
    from pkg_py.pk_colorful_cli_util import pk_print

    try:
        @pk_measure_seconds
        def get_window_matches(window_title_seg: str):
            matches = []

            def enum_handler(hwnd, _):
                if win32gui.IsWindowVisible(hwnd):
                    title = win32gui.GetWindowText(hwnd)
                    if title:
                        similarity = window_title_seg.lower() in title.lower()
                        matches.append((hwnd, title, similarity))

            win32gui.EnumWindows(enum_handler, None)
            matches.sort(key=lambda x: x[2], reverse=True)
            return matches

        @pk_measure_seconds
        def monitor_process_state(proc, max_sec=2.5, interval=0.5):
            pk_print(f"👁️ Start monitoring PID={proc.pid}", print_color="blue")
            steps = int(max_sec / interval)
            for _ in range(steps):
                if not proc.is_running():
                    break
                try:
                    cpu = proc.cpu_percent()
                    mem = proc.memory_info().rss / (1024 * 1024)
                    th = proc.num_threads()
                    pk_print(f"🔍 PID={proc.pid} CPU={cpu:.1f}% MEM={mem:.1f}MB TH={th}", print_color="blue")
                except Exception:
                    pass
                time.sleep(interval)
            pk_print(f"👁️ End monitoring PID={proc.pid}", print_color="blue")

        matches = get_window_matches(window_title_seg)

        if not matches:
            pk_print(f"[SKIP] No window found for seg='{window_title_seg}'", print_color="yellow")
            return

        pk_print(f"[INFO] Found {len(matches)} window(s). Similarity check:", print_color="cyan")
        for hwnd, title, is_similar in matches:
            sim_mark = "✅" if is_similar else "  "
            pk_print(f"{sim_mark} [{hwnd}] {title}", print_color="cyan")

        # 유사도 높은 첫 번째 타이틀로 선택
        best_match_hwnd, best_match_title, _ = matches[0]
        if LTA:
            pk_print(f"🪟 Using best match title: {best_match_title} {'%%%FOO%%%' if LTA else ''}", print_color="cyan")

        # 해당 타이틀을 가진 윈도우들의 PID 직접 수집
        matched_pids = set()
        for hwnd, title, is_similar in matches:
            if is_similar:
                try:
                    _, pid = win32process.GetWindowThreadProcessId(hwnd)
                    matched_pids.add(pid)
                except Exception:
                    continue

        failed_pids = []

        @pk_measure_seconds
        def kill_pid_psutil(pid):
            try:
                proc = psutil.Process(pid)
                proc.terminate()
                start = time.time()

                monitor_process_state(proc)

                try:
                    proc.wait(timeout=1)
                except psutil.TimeoutExpired:
                    proc.kill()
                    try:
                        proc.wait(timeout=1)
                    except psutil.TimeoutExpired:
                        pass

                elapsed = time.time() - start
                if elapsed > 5.0:
                    pk_print(f"‼️ FORCED TIMEOUT: PID={pid} took {elapsed:.2f}s", print_color="red")
                    failed_pids.append(pid)
                elif elapsed > 2.5:
                    pk_print(f"⚠️ PK KILL PID={pid} TIMEOUT_ELAPSED={elapsed:.2f}s", print_color="red")
                else:
                    pk_print(f"✅ PK KILL PID={pid} title_match={best_match_title}", print_color="green")

            except Exception as e:
                failed_pids.append(pid)
                pk_print(f"❌ PK KILL ERROR PID={pid} : {e}", print_color="red")

        if matched_pids:
            with ThreadPoolExecutor(max_workers=min(4, len(matched_pids))) as executor:
                executor.map(kill_pid_psutil, matched_pids)
        else:
            pk_print(f"PK KILL '{best_match_title}' not found (No PIDs)", print_color="red")

        if failed_pids:
            pk_print(f"❗ FAILED PIDs: {sorted(failed_pids)}", print_color="red")

    except Exception as e:
        pk_print(f"[ERROR] {e}", print_color="red")


def kill_wsl_exe():
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    process_name = "wsl.exe"
    cmd = "wsl --shutdown"
    cmd_to_os(cmd=cmd, mode="a")
    pids = get_pids("wsl.exe")
    if pids is not None:
        for pid in pids:
            if pid is not None:
                kill_process_via_taskkill(pid=pid)
    write_like_person("exit")
    pk_press("enter")


def kill_thread(thread_name):
    import threading
    # 종료할 스레드 이름

    # 현재 exec  중인 모든 스레드 가져오기
    current_threads = threading.enumerate()

    # 종료할 스레드 찾기
    target_thread = None
    for thread in current_threads:
        if thread.name == thread_name:
            target_thread = thread
            break

    # 스레드 종료
    if target_thread:
        target_thread.join()
        print(f"{thread_name} 스레드가 종료되었습니다.")
    else:
        print(f"{thread_name} 스레드를 찾을 수 없습니다.")


def kill_us_keyboard():
    """
    프로세스 간 공유 메모리를 내부에서 초기화하고 사용하도록 변경
    """
    import threading
    from multiprocessing import shared_memory, Lock
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PKG_CMD, Encoding
    from colorama import init as pk_colorama_init
    pk_colorama_init(autoreset=True)

    if get_os_n() == 'windows':
        chcp_65001()

    shm_name = "flag_to_detect_enter"
    lock = Lock()

    try:
        # 기존 공유 메모리 존재 여부 확인
        shm = shared_memory.SharedMemory(name=shm_name, create=False)
        pk_print(rf"기존 공유 메모리 발견, 초기화 생략 shm_name={shm_name}", print_color="green")
    except FileNotFoundError:
        pk_print(rf"새로운 공유 메모리 생성 shm_name={shm_name}", print_color="green")
        shm = shared_memory.SharedMemory(create=True, size=1, name=shm_name)
        shm.buf[0] = 0  # 초기값 False (0)

    def listen_enter():
        """사용자가 Enter 키를 입력하면 flag를 True로 설정"""
        try:
            existing_shm = shared_memory.SharedMemory(name=shm_name)
            flag = existing_shm.buf
        except FileNotFoundError:
            pk_print("listen_enter: 공유 메모리가 존재하지 않음. 종료.", print_color='red')
            return

        while 1:
            input()  # Enter 입력 대기
            with lock:
                flag[0] = 1  # flag를 True로 변경
                pk_print("Enter detected! flag 업데이트됨.", print_color="blue")

        existing_shm.close()

    def main_loop():
        """flag 값이 True가 되면 특정 작업 수행 후 다시 False로 초기화"""
        try:
            existing_shm = shared_memory.SharedMemory(name=shm_name)
            flag = existing_shm.buf
        except FileNotFoundError:
            pk_print("main_loop: 공유 메모리가 존재하지 않음. 종료.", print_color='red')
            return

        while 1:
            # exec 할 명령
            f_cmd = rf"{D_PKG_CMD}/pk_kill_us_keyboard.cmd"
            f_cmd = get_pnx_os_style(pnx=f_cmd)
            cmd_to_os(cmd=rf'"{f_cmd}"', encoding=Encoding.CP949)

            # sleep
            sleep_seconds = 3
            for _ in range(sleep_seconds):
                with lock:
                    if flag[0]:  # flag가 True면 리셋 후 루프 재시작
                        pk_print("Enter detected! Restarting loop...", print_color="white")

                        # pk_system_kill_us_keyboard.cmd (run)
                        f_cmd = rf"{D_PKG_CMD}/pk_kill_us_keyboard.cmd"
                        f_cmd = get_pnx_os_style(pnx=f_cmd)
                        cmd_to_os(cmd=rf'"{f_cmd}"', encoding='utf-8')

                        flag[0] = 0  # flag를 다시 False로 초기화
                        pk_print(f"wait for enter  {'%%%FOO%%%' if LTA else ''}", print_color='white')
                        break
                pk_sleep(seconds=1)

        existing_shm.close()

    # thread run (in background)
    thread = threading.Thread(target=listen_enter, daemon=True)
    thread.start()

    # main loop run
    main_loop()

    # 공유 메모리 해제 (필요하면 exec )
    shm.close()
    # shm.unlink()  # 주석 해제하면 공유 메모리 삭제됨 (프로세스 간 공유 유지하려면 유지)


async def pk_kill_process_as_async(f):
    """
    주어진 cmd_exe_title과 일치하는 프로세스를 찾아 비동기적으로 종료하는 함수
    """
    import psutil
    import asyncio
    tasks = []

    f = get_pnx_os_style(f)
    f_nx = get_nx(f)
    # f_nx = f_nx

    for process in psutil.process_iter(['pid', 'name', 'cmdline']):
        try:
            cmdline = process.info.get('cmdline', [])
            if cmdline and any(f_nx in cmd for cmd in cmdline):
                pid = process.info['pid']
                name = process.info['name']
                tasks.append(terminate_process_async(pid, name, f_nx))
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            continue  # 권한 오류나 존재하지 않는 프로세스는 무시

    if tasks:
        await asyncio.gather(*tasks)  # 모든 프로세스를 비동기적으로 종료


def kill_process(img_name=None, pid=None):
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import UNDERLINE
    func_n = inspect.currentframe().f_code.co_name
    pk_print(working_str=rf'''{UNDERLINE}{func_n}()  {'%%%FOO%%%' if LTA else ''}''')
    # function_arg_names= [param.name for param in inspect.signature(process_kill).parameters.values()] # fail
    Nones = [img_name, pid]
    None_count = Nones.count(None)
    if None_count == 2:
        pk_print(working_str=rf''' 이 {func_n}()의 인자는 최대 1개 까지 받을 수 있습니다.  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
    if None_count == 1:
        if img_name is not None:
            img_name = img_name.replace("\'", "")
            img_name = img_name.replace("\"", "")
            cmd_to_os(f'taskkill /f /im "{img_name}"')
            cmd_to_os(f'wmic process where name="{img_name}" delete ')
        if pid is not None:
            # cmd_to_os(f'taskkill /f /pid {pid}', debug_mode=debug_mode)
            cmd_to_os(f'taskkill /f /pid {pid}')
    if None_count == 0:
        pk_print(working_str=rf''' 이 {func_n}()의 인자는 최소 1개의 인자가 요구됩니다.  {'%%%FOO%%%' if LTA else ''}''', print_color='red')


def get_process_name_list(unique: bool = True, sort: bool = True) -> list:
    """
    현재 실행 중인 모든 프로세스의 이름 목록을 반환합니다.

    :param unique: True일 경우 중복 remove
    :param sort: True일 경우 알파벳 순 정렬
    :return: 프로세스 이름 리스트
    """
    import psutil
    names = []

    for proc in psutil.process_iter(['name']):
        try:
            if proc.info['name']:
                names.append(proc.info['name'])
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            continue

    if unique:
        names = list(set(names))
    if sort:
        names.sort()

    return names


def save_screen():
    # cmd_to_os_like_person(cmd=rf'''%systemroot%\system32\scrnsave.scr /s''')# 성공
    cmd = rf'''%systemroot%\system32\scrnsave.scr /s '''  # 성공
    if is_os_windows():
        cmd_to_os(cmd=cmd)
    else:
        cmd = get_pnx_wsl_unix_style(pnx=cmd)
        cmd_to_os(cmd=cmd)


def lock_screen():
    cmd = "rundll32.exe user32.dll,LockWorkStation"
    if is_os_windows():
        cmd_to_os(cmd=cmd)
    else:
        cmd = get_pnx_wsl_unix_style(pnx=cmd)
        cmd_to_os(cmd=cmd)


def save_power_as_s4():
    # h3
    # 최대절전모드
    cmd = r'C:\Windows\System32\rundll32.exe powrprof.dll,SetSuspendState hibernate'
    if is_os_windows():
        cmd_to_os(cmd=cmd)
    else:
        cmd = get_pnx_wsl_unix_style(pnx=cmd)
        cmd_to_os(cmd=cmd)


def save_power_as_s3():
    # 절전모드
    # cmd_to_os(cmd=rf"powercfg /setacvalueindex scheme_current sub_buttons button=1-3 action=0")
    cmd = rf"rundll32.exe powrprof.dll,SetSuspendState 0,1,0"
    if is_os_windows():
        cmd_to_os(cmd=cmd)
    else:
        cmd = get_pnx_wsl_unix_style(pnx=cmd)
        cmd_to_os(cmd=cmd)


def make_os_shutdown(seconds=None, milliseconds=None, mins=None, restart_mode=0, cancel_mode=0):
    from pkg_py.pk_colorful_cli_util import pk_print

    mode_list = [restart_mode, cancel_mode]
    false_count = mode_list.count(False)

    none_list = [seconds, milliseconds, mins]
    none_count = none_list.count(None)

    if false_count == 2 and none_count == 3:
        pk_print(f"이 함수의 최소인자의 수는 1개 입니다")
        return

    if false_count < 2:
        if restart_mode == 1:
            cmd = f'shutdown.exe /r'
            cmd_to_os(cmd=cmd)
            return

        if cancel_mode == 1:
            cmd = f'shutdown.exe /a'
            cmd_to_os(cmd=cmd)
            return
    else:

        if none_count != 2:
            pk_print(f"이 함수는 시간단위에 대한인자를 1개의 인자만 받도록 만들어졌습니다")
            return

        # sys_shutdown(seconds=x)
        # sys_shutdown(mins=x)
        if milliseconds is not None:
            seconds = milliseconds
        elif mins is not None:
            seconds = mins * 60

        cmd = f'shutdown.exe /s /t {seconds}'
        cmd_to_os(cmd=cmd)


# [def set]
def set_up_jetson_nano_dev_environment():
    import inspect
    func_n = inspect.currentframe().f_code.co_name
    # winget # fail # windows 11 부터 시도해보자. 10 지원 끝난듯.
    # winget 윈도우에서 마소 official 패키지 매니저
    # winget --version
    # winget search Google Chrome
    # winget install Google.Chrome --silent
    # winget install Microsoft.VisualStudio --silent

    # choco # fail
    # console_title="choco install"
    # run_powershell_as_admin()
    # write_like_person(string=rf"$host.ui.RawUI.WindowTitle='{console_title}'  ", interval=0.005)
    # press("enter")
    # write_like_person(string=rf"$Host.UI.RawUI.BufferSize=New-Object Management.Automation.Host.Size(1000, 1000) ", interval=0.005)
    # press("enter")
    # write_like_person(string=rf"$Host.UI.RawUI.WindowSize=New-Object Management.Automation.Host.Size(1000, 1000)  ", interval=0.005)
    # press("enter")
    # write_like_person(string=rf" Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol=[System.Net.SecurityProtocolType]::Tls12; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1')) ", interval=0.005)
    # press("enter")
    # choco search usbipd-win
    # choco list #설치된 패키지 확인

    # usbipd
    # chdir(pnx=DOWNLOADS)
    # write_like_person(string=rf"  choco install usbpid-win --silent ", interval=0.005)
    # press("enter")
    # cmd=rf'curl -O "https://github.com/dorssel/usbipd-win/releases/download/v4.3.0/usbipd-win_4.3.0.msi" ' #fail 왜안되나 손으로 클릭하면 되는데
    # cmd=rf'explorer "https://github.com/dorssel/usbipd-win/releases/tag/v4.3.0" '
    # cmd_run(cmd=cmd)
    # pk_sleep(milliseconds=1200)
    # click_text_coordinates_via_easy_ocr(string="usbipd-win_4.3.0.msi")
    # cmd=rf'explorer "{DOWNLOADS}\usbipd-win_4.3.0.msi" '
    # cmd_run(cmd=cmd)


def ensure_remote_os_as_nopasswd(**config_remote_os):
    try:
        from pkg_py.pk_core_constants import STAMP_REMOTE_DEBUG, STAMP_REMOTE_ERROR
        from pkg_py.pk_colorful_cli_util import pk_print

        local_ssh_public_key = config_remote_os['local_ssh_public_key']
        local_ssh_private_key = config_remote_os['local_ssh_private_key']
        ip = config_remote_os['ip']
        port = config_remote_os['port']
        user_n = config_remote_os['user_n']
        pw = config_remote_os['pw']
        # public_key = config_remote_os['public_key']

        cmd = f"sudo grep -n '{user_n} ALL=(ALL:ALL) NOPASSWD:ALL' /etc/sudoers"
        std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd=cmd, **config_remote_os)
        signiture = f"{user_n} ALL=(ALL:ALL) NOPASSWD:ALL"
        for std_out_str in std_out_list:
            if signiture in std_out_str:
                pk_print("THE ENTRY IS ALREADY PRESENT")
                return 1
            else:
                cmd = f"echo '{pw}' | sudo -S bash -c \"echo '{user_n} ALL=(ALL:ALL) NOPASSWD:ALL' >> /etc/sudoers\""
                std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd=cmd, **config_remote_os)
                if not len(std_err_list) == 0:
                    for std_err_str in std_err_list:
                        pk_print(working_str=rf'{STAMP_REMOTE_ERROR} {std_err_str}', print_color='red')
                if not len(std_out_list) == 0:
                    for std_out_str in std_out_list:
                        pk_print(working_str=rf'{STAMP_REMOTE_DEBUG} {std_out_str}')
                cmd = f"sudo visudo -c"
                std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd=cmd, **config_remote_os)
                if not len(std_err_list) == 0:
                    for std_err_str in std_err_list:
                        pk_print(working_str=rf'{STAMP_REMOTE_ERROR} {std_err_str}', print_color='red')
                if not len(std_out_list) == 0:
                    for std_out_str in std_out_list:
                        pk_print(working_str=rf'{STAMP_REMOTE_DEBUG} {std_out_str}')
    except:
        import traceback
        pk_print(working_str=rf"{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''} ", print_color='red')


# [def play]
def play_wav_f(f):
    import os
    import pyglet
    import pkg_py.pk_core_constants as pk_core_constants
    f = pk_core_constants.F_POP_SOUND_POP_SOUND_WAV
    if os.path.exists(f):
        source = pyglet.media.load(f)
        source.play()
    pass


def play_my_sound_track():
    import inspect
    from pkg_py.pk_core_constants import F_PKG_SOUND_POTPLAYER64_DPL
    func_n = inspect.currentframe().f_code.co_name

    # cmd_to_os(cmd=rf'taskkill /f /im "alsong.exe" ', debug_mode=True)

    cmd_to_os(cmd=rf'explorer "{F_PKG_SOUND_POTPLAYER64_DPL}" ')


# [def build]
def build_project_cmake(project_pnx, **config_remote_os):
    try:
        from pkg_py.pk_core_constants import STAMP_REMOTE_DEBUG, STAMP_REMOTE_ERROR
        import traceback
        from pkg_py.pk_colorful_cli_util import pk_print
        import inspect

        func_n = inspect.currentframe().f_code.co_name

        ip = config_remote_os['ip']
        pw = config_remote_os['pw']
        port = config_remote_os['port']
        user_n = config_remote_os['user_n']
        local_ssh_public_key = config_remote_os['local_ssh_public_key']
        local_ssh_private_key = config_remote_os['local_ssh_private_key']

        cmd = "cmake --version"
        std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd=cmd, **config_remote_os)
        if not len(std_err_list) == 0:
            for std_err_str in std_err_list:
                pk_print(working_str=rf'{STAMP_REMOTE_ERROR} {std_err_str}', print_color='red')
            return
        if not len(std_out_list) == 0:
            for std_out_str in std_out_list:
                pk_print(working_str=rf'{STAMP_REMOTE_DEBUG} {std_out_str}')
                prompt_positive = "cmake version "
                if prompt_positive in std_out_str:
                    break

        cmd = rf"rm -rf {project_pnx}/build"
        std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd=cmd, **config_remote_os)
        if not len(std_err_list) == 0:
            for std_err_str in std_err_list:
                pk_print(working_str=rf'{STAMP_REMOTE_ERROR} {std_err_str}', print_color='red')
            return
        if not len(std_out_list) == 0:
            for std_out_str in std_out_list:
                pk_print(working_str=rf'{STAMP_REMOTE_DEBUG} {std_out_str}')

        cmd = rf"mkdir -p {project_pnx}/build"
        std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd=cmd, **config_remote_os)
        if not len(std_err_list) == 0 and not len(std_out_list) == 0:
            return

        cmd = rf"cd {project_pnx}/build && cmake .."
        std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd=cmd, **config_remote_os)
        if not len(std_err_list) == 0:
            for std_err_str in std_err_list:
                pk_print(working_str=rf'{STAMP_REMOTE_ERROR} {std_err_str}', print_color='red')

            # [ TRY GUIDE ] : sudo apt install build-essential cmake g++ make git libyaml-cpp-dev

            # cmd = rf"sudo apt update"
            # std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(ip=ip, port=port, username=username, local_ssh_private_key=local_ssh_private_key, cmd=cmd)
            # if not len(std_err_list) == 0:
            #     for std_err_str in std_err_list:
            #         pk_print(str_working=rf'{STAMP_REMOTE_ERROR} {std_err_str}', print_color='red')
            #     return
            # if not len(std_out_list) == 0:
            #     for std_out_str in std_out_list:
            #         pk_print(str_working=rf'{STAMP_REMOTE_DEBUG} {std_out_str}')

            # cmd = rf"sudo apt install build-essential cmake g++ make git libyaml-cpp-dev"
            # std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(ip=ip, port=port, username=username, local_ssh_private_key=local_ssh_private_key, cmd=cmd)
            # if not len(std_err_list) == 0:
            #     for std_err_str in std_err_list:
            #         pk_print(str_working=rf'{STAMP_REMOTE_ERROR} {std_err_str}', print_color='red')
            #     return
            # if not len(std_out_list) == 0:
            #     for std_out_str in std_out_list:
            #         pk_print(str_working=rf'{STAMP_REMOTE_DEBUG} {std_out_str}')

            return
        if not len(std_out_list) == 0:
            for std_out_str in std_out_list:
                pk_print(working_str=rf'{STAMP_REMOTE_DEBUG} {std_out_str}')

        cmd = rf"cd {project_pnx}/build && make"
        std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd=cmd, **config_remote_os)
        if not len(std_err_list) == 0:
            for std_err_str in std_err_list:
                pk_print(working_str=rf'{STAMP_REMOTE_ERROR} {std_err_str}', print_color='red')
            return
        if not len(std_out_list) == 0:
            for std_out_str in std_out_list:
                pk_print(working_str=rf'{STAMP_REMOTE_DEBUG} {std_out_str}')

        pk_print(working_str=rf'''{func_n}()  {'%%%FOO%%%' if LTA else ''}''', print_color='green')
    except:
        pk_print(working_str=rf"{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''} ", print_color='red')
        raise


# [def exec]
def exec_project_cmake(project_pnx, **config_remote_os):
    try:
        from pkg_py.pk_core_constants import STAMP_REMOTE_DEBUG, STAMP_REMOTE_ERROR
        from pkg_py.pk_colorful_cli_util import pk_print
        import traceback
        import sys
        import inspect
        func_n = inspect.currentframe().f_code.co_name
        ip = config_remote_os['ip']
        pw = config_remote_os['pw']
        port = config_remote_os['port']
        user_n = config_remote_os['user_n']
        local_ssh_public_key = config_remote_os['local_ssh_public_key']
        local_ssh_private_key = config_remote_os['local_ssh_private_key']

        cmd = rf"cd {project_pnx}/build && ./project_cmake"  # build 를 통해서 생성된 project_cmake exec  f 이다
        std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd=cmd, **config_remote_os)
        cmd_to_remote_os_with_pubkey(cmd='sudo apt update', **config_remote_os)
        if not len(std_err_list) == 0:
            for std_err_str in std_err_list:
                pk_print(working_str=rf'{STAMP_REMOTE_ERROR} {std_err_str}', print_color='red')
            return
        if not len(std_out_list) == 0:
            for std_out_str in std_out_list:
                pk_print(working_str=rf'{STAMP_REMOTE_DEBUG} {std_out_str}')
        pk_print(working_str=rf'''{func_n}()  {'%%%FOO%%%' if LTA else ''}''', print_color='green')
    except:
        pk_print(working_str=rf"{traceback.format_exc()}  {'%%%FOO%%%' if LTA else ''} ", print_color='red')
        raise


# [def assist]
def assist_to_run_project_cmake():
    import os
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PROJECT_CMAKE, STAMP_TRY_GUIDE

    wsl_distro_n = 'Ubuntu-24.04'
    ensure_wsl_distro_session(wsl_distro_n=wsl_distro_n)
    config_remote_os = {
        'port': ensure_and_get_wsl_port(wsl_distro_n),
        'ip': get_wsl_ip(wsl_distro_n),
        'user_n': get_wsl_user_n(wsl_distro_n),
        'pw': get_wsl_pw(wsl_distro_n),
        'local_ssh_public_key': os.path.join(D_HOME, ".ssh", "id_ed25519.pub"),
        'local_ssh_private_key': os.path.expanduser("~/.ssh/id_ed25519"),
    }
    ip = config_remote_os['ip']
    pw = config_remote_os['pw']
    port = config_remote_os['port']
    user_n = config_remote_os['user_n']
    local_ssh_public_key = config_remote_os['local_ssh_public_key']
    local_ssh_private_key = config_remote_os['local_ssh_private_key']

    ensure_ssh_public_key_to_remote_os(**config_remote_os)
    ensure_remote_os_as_nopasswd(**config_remote_os)

    project_pnx = D_PROJECT_CMAKE

    pk_print(f'''{STAMP_TRY_GUIDE} ssh -p {port} {user_n}@{ip} {'%%%FOO%%%' if LTA else ''}''')

    std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd=rf"sudo apt update", **config_remote_os)
    std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd=rf"echo y | sudo apt install build-essential", **config_remote_os)
    std_out_list, std_err_list = cmd_to_remote_os_with_pubkey(cmd=rf"echo y | sudo apt install libyaml-cpp-dev", **config_remote_os)

    build_project_cmake(project_pnx=project_pnx, **config_remote_os)
    exec_project_cmake(project_pnx=project_pnx, **config_remote_os)


def check_manual_task_iteractively(question, ignore_uppercase_word_list=None):
    try:
        from pkg_py.pk_colorful_cli_util import pk_print
        from colorama import init as pk_colorama_init

        import traceback
        from pkg_py.pk_core_constants import UNDERLINE
        from pkg_py.pk_core_constants import STAMP_EXCEPTION_DISCOVERED
        import sys

        pk_colorama_init(autoreset=True)

        if ignore_uppercase_word_list is None:
            ignore_uppercase_word_list = []

        question = question.upper()

        for word in ignore_uppercase_word_list:
            question = question.replace(word.upper(), word)

        # [OPTION]
        # line_feed_cnt = 6
        line_feed_cnt = 3
        line_feed_char = ''
        for _, __ in enumerate(get_list_from_integer_range(1, line_feed_cnt)):
            # print(f'''{__}''')
            print(f'''{line_feed_char}''')

        pk_print(working_str=question, print_color="white")

        while 1:
            answer = input(rf"{pk_get_colorful_working_str_with_stamp_enviromnet(func_n=func_n)} >").strip().lower()
            if answer is not None:
                if answer != '':
                    pk_print(working_str=rf"ANSWER='{answer}'")
                break
            else:
                pk_print(working_str="INVALID INPUT. PLEASE PRESS ENTER TO CONTINUE.")
    except KeyboardInterrupt:
        raise
    except:
        traceback.print_exc()
        import sys
        traceback.print_exc(file=sys.stdout)


def driver_get_url_in_browser_and_wait_loaded(url, driver):
    from pkg_py.pk_colorful_cli_util import pk_print
    import json

    driver_get_url_in_browser(url=url, driver=driver)

    # 네트워크 로그 가져오기
    logs = driver.get_log("performance")
    events = [json.loads(entry["message"])["message"] for entry in logs]

    # 가장 늦게 로드된 네트워크 요청 찾기
    latest_time = 0
    latest_url = None

    for event in events:
        if event["method"] == "Network.responseReceived":
            response_time = event["params"]["timestamp"]
            request_url = event["params"]["response"]["url"]

            if response_time > latest_time:
                latest_time = response_time
                latest_url = request_url

    pk_print(f"가장 늦게 로드된 요소 URL: {latest_url}")
    pk_print(f"로드 완료 시간: {latest_time}")
    return latest_url, latest_time


def test_api():
    # def save_data_via_api_server():
    import requests
    import json
    from pkg_py.pk_core_constants import F_CONFIG_TOML
    import toml

    # SWAGGER ACCESS # FASTAPI # INCLUDE ROUTING TEST
    config = toml.load(F_CONFIG_TOML)
    pk_protocol_type = config["pk_uvicorn"]["protocol_type"]
    pk_host = config["pk_uvicorn"]["host"]
    pk_port = config["pk_uvicorn"]["port"]
    cmd_to_os(cmd=fr"explorer.exe {pk_protocol_type}://{pk_host}:{pk_port}/docs")
    cmd_to_os(cmd=fr"explorer.exe {pk_protocol_type}://{pk_host}:{pk_port}/redoc")
    cmd_to_os(cmd=fr"explorer.exe {pk_protocol_type}://{pk_host}:{pk_port}")

    # TODO : ROUTING TEST

    # POST REQUEST TEST
    url = "https://pk_system.store/api/db-maria/items"
    data = {
        "name": "John Doe",
        "email": "johndoe@example.com",
        "pw": "pw",
    }
    json_data = json.dumps(data)
    headers = {"Content-Type": "application/json"}
    response = requests.post(url, headers=headers, data=json_data)
    if response.status_code == 201:
        print("데이터가 성공적으로 저장되었습니다.")
    else:
        print("데이터 저장에 실패했습니다.")


@pk_measure_seconds
def get_pnx_working_with_idx_dict(pnx_working_list, pnx_minus_list=None, pnx_plus_list=None):
    if pnx_plus_list is not None:
        pnx_working_list = get_list_unioned(list_a=pnx_working_list, list_b=pnx_plus_list)
    if pnx_minus_list is not None:
        pnx_working_list = get_list_differenced(list_a=pnx_working_list, list_b=pnx_minus_list)
    pnx_working_with_idx_dict = {}
    for index, pnx_working in enumerate(pnx_working_list):
        pnx_working_with_idx_dict[index] = pnx_working
    return pnx_working_with_idx_dict


def get_idx_list(item_iterable):
    return list(range(0, len(item_iterable)))


def get_pnx_working_without_idx_list(pnx_working_with_idx_dict):
    pnx_working_list = []
    for idx, pnx_working_with_idx in enumerate(pnx_working_with_idx_dict):
        pnx_working_list.append(pnx_working_with_idx_dict[idx])
    return pnx_working_list


def save_d_to_f(d, f):
    from pkg_py.pk_colorful_cli_util import pk_print
    with open(f, "w", encoding='utf-8') as f_obj:
        d = get_pnx_os_style(d)
        f_obj.write(d)
        if LTA:
            pk_print(f'''d={d} %%%FOO%%%''')


def pk_cd(sys_argv):
    '''
    [archived]
    [개요]
    타이핑 최소화

    [참고]
    pk_cd.cmd 에 종속적으로 동작
    실제로 cd 되지 않음. cd 할 경로를 f_cd_txt 에 저장함 pk_cd.cmd 에서 cd 함

    [사용법]
    pk cd 로 가용 cd {index} 출력
    cd {index} 호출하여 사용
    '''
    from pkg_py.pk_core_constants import D_PKG_PY, D_HOME, D_DESKTOP
    from pkg_py.pk_core_constants import D_WORKING, D_PROJECT, D_DOWNLOADS
    from pkg_py.pk_core_constants import D_PKG_TXT
    from pkg_py.pk_colorful_cli_util import pk_print
    import os
    import sys
    f_cd_txt = os.path.join(D_PKG_TXT, "pk_cd.txt")
    if not does_pnx_exist(f_cd_txt):
        ensure_pnx_made(f_cd_txt, mode='f')
    d_working_list = get_pnx_list(with_walking=0, d_working=get_d_working_in_python(), mode='d')
    minus_list = [rf"{D_PKG_PY}/???.py"]
    minus_list = [get_pnx_os_style(element) for element in minus_list]
    plus_list = [
        D_PKG_PY,
        D_PROJECT,
        D_WORKING,
        D_DOWNLOADS,
        D_HOME,
        D_DESKTOP,
    ]
    d_working_with_idx_dict = get_pnx_working_with_idx_dict(pnx_working_list=d_working_list, pnx_minus_list=minus_list, pnx_plus_list=plus_list)
    # d_working_without_idx_list = get_pnx_working_without_idx_list(pnx_working_with_idx_dict=d_working_with_idx_dict)
    d_working_idx_list = get_idx_list(item_iterable=d_working_with_idx_dict)
    # d_working_idx_list = list(map(str, d_working_idx_list))  # each (element ->> str(element))
    if LTA:
        pk_print(f'''len(sys_argv)={len(sys_argv)} {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''f_cd_txt={f_cd_txt} {'%%%FOO%%%' if LTA else ''}''')
    if len(sys_argv) == 1:
        return
    elif len(sys_argv) == 2:
        nx_by_user_input = sys_argv[1]
        if LTA:
            pk_print(f'''nx_by_user_input={nx_by_user_input} {'%%%FOO%%%' if LTA else ''}''')
        if str.isdigit(nx_by_user_input):
            if LTA:
                pk_print(f'''인자가 숫자입니다. {'%%%FOO%%%' if LTA else ''}''')
            return
        else:
            if LTA:
                pk_print(f'''인자가 숫자가 아닙니다. {'%%%FOO%%%' if LTA else ''}''', print_color='red')
            else:
                if does_pnx_exist(sys.argv[1]):
                    d_dst = os.path.abspath(sys.argv[1])
                    save_d_to_f(d=d_dst, f=f_cd_txt)
                return


def decrypt_token(ciphertext, iv, key):
    from base64 import b64decode
    from Cryptodome.Cipher import AES
    def unpad(s):
        return s[:-ord(s[-1])]

    cipher = AES.new(key, AES.MODE_CBC, iv=b64decode(iv))
    decrypted = cipher.decrypt(b64decode(ciphertext))
    return unpad(decrypted.decode('utf-8'))


def encrypt_token(token, key):
    from base64 import b64encode
    from Cryptodome.Cipher import AES
    from Cryptodome.Random import get_random_bytes
    def pad(s):
        return s + (16 - len(s) % 16) * chr(16 - len(s) % 16)

    iv = get_random_bytes(16)  # 16바이트 IV
    cipher = AES.new(key, AES.MODE_CBC, iv)
    padded_token = pad(token).encode()
    ciphertext = cipher.encrypt(padded_token)
    return {
        "ciphertext": b64encode(ciphertext).decode("utf-8"),
        "iv": b64encode(iv).decode("utf-8")
    }


def get_pk_key_from_f(f):
    f = get_pnx_os_style(f)
    with open(f, "r", encoding="utf-8") as f:
        key_byte = f.read().strip().encode()  # 문자열을 bytes로
        return key_byte


def get_pk_plain_str(f_token, f_key):
    import toml
    config = toml.load(f_token)
    data = config["api"]
    key_byte = get_pk_key_from_f(f=f_key)
    return decrypt_token(data["ciphertext"], data["iv"], key_byte)


def set_pk_plain_str(f_token, plain_str, f_key):
    from pkg_py.pk_colorful_cli_util import pk_print
    f_token = get_pnx_os_style(f_token)
    if does_pnx_exist(f_token) and len(get_str_from_f(f=f_token).strip()) == 0:
        ensure_pnx_removed(f_token)

    if not does_pnx_exist(f_token):
        ensure_pnx_made(pnx=f_token, mode='f')
        import toml
        data = encrypt_token(plain_str, get_pk_key_from_f(f=f_key))
        o = {"api": data}
        with open(f_token, "w", encoding="utf-8") as f_obj:
            toml.dump(o, f_obj)
        if LTA:
            pk_print(f'''token set. {f_token} {'%%%FOO%%%' if LTA else ''}''', print_color='green')
    else:
        if LTA:
            pk_print(f'''len(get_list_from_f(f_token))={len(get_list_from_f(f_token))} {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''token is already set {f_token} {'%%%FOO%%%' if LTA else ''}''')


def ensure_repo_cloned_via_git(repo_url: str, d_dst: str):
    import subprocess
    from pkg_py.pk_colorful_cli_util import pk_print
    subprocess.run(["git", "clone", repo_url, d_dst], check=True)
    pk_print(f'''git cloned {repo_url} at {d_dst} {'%%%FOO%%%' if LTA else ''}''')


# def get_pk_token(f_token, initial_str):
#     from pkg_py.pk_colorful_cli_util import pk_print
#     from pkg_py.pk_core_constants import D_PKG_TOML, D_PK_TEMP
#     import os
#     f_master_key = rf"{D_PKG_TOML}/pk_token_key.toml"
#     if not does_pnx_exist(pnx = f_master_key):
#         ensure_repo_cloned_via_git(repo_url = 'http://github.com/PARK4139/pkg_toml.git', d_dst = D_PK_TEMP)
#         f_master_key_new = f"{D_PKG_TOML}/pk_token_key.toml"
#         move_pnx(pnx=f_master_key_new, d_dst=D_PKG_TOML)
#     set_pk_plain_str(f_token=f_token, plain_str=initial_str, f_key=f_master_key)
#     pk_plain_str = get_pk_plain_str(f_token=f_token, f_key=f_master_key)
#     if LTA:
#         pk_print(f'''pk_plain_str={pk_plain_str} {'%%%FOO%%%' if LTA else ''}''', print_color='blue')
#     return pk_plain_str

def get_pk_token(f_token, initial_str):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PKG_TOML, D_PK_TEMP
    import os

    f_master_key = rf"{D_PKG_TOML}/pk_token_key.toml"

    if not does_pnx_exist(pnx=f_master_key):
        ensure_pnx_removed(D_PK_TEMP)
        ensure_repo_cloned_via_git(repo_url='http://github.com/PARK4139/pkg_toml.git', d_dst=D_PK_TEMP)
        f_master_key_cloned = os.path.join(D_PK_TEMP, "pk_token_key.toml")
        if not os.path.exists(f_master_key_cloned):
            raise FileNotFoundError(f"Cloned key file not found at: {f_master_key_cloned}")
        move_pnx(pnx=f_master_key_cloned, d_dst=D_PKG_TOML)

    set_pk_plain_str(f_token=f_token, plain_str=initial_str, f_key=f_master_key)
    pk_plain_str = get_pk_plain_str(f_token=f_token, f_key=f_master_key)

    if LTA:
        pk_print(f'''pk_plain_str={pk_plain_str} {'%%%FOO%%%' if LTA else ''}''', print_color='blue')

    return pk_plain_str


def get_wsl_distro_info_std_list() -> list[str]:
    from pkg_py.pk_colorful_cli_util import pk_print
    import subprocess
    try:
        result = subprocess.run(['wsl', '-l', '-v'], capture_output=True)
        output = result.stdout.decode('utf-16')  # ✅
        std_list = output.splitlines()
        highlight_config_dict = {
            "green": [
                'Running'
            ],
            'red': [
                'Stopped'
            ],
        }
        return std_list
    except Exception as e:
        pk_print(f"Failed to get WSL details: {e}", print_color='red')
        return []


def print_wsl_distro_info_std_list() -> list[str]:
    from pkg_py.pk_colorful_cli_util import pk_print
    try:
        pk_print("======== wsl -l -v ========")
        std_list = get_wsl_distro_info_std_list()
        highlight_config_dict = {
            "green": [
                'Running'
            ],
            'red': [
                'Stopped'
            ],
        }
        pk_debug_state_for_py_data_type(pk_stamp='%%%FOO%%%-1', data_working=std_list, highlight_config_dict=highlight_config_dict, with_LTA=0)
        return std_list
    except Exception as e:
        pk_print(f"Failed to get WSL details: {e}", print_color='red')
        return []


def check_installed_wsl():
    import subprocess
    import re
    from pkg_py.pk_colorful_cli_util import pk_print

    def clean_line(line: str) -> str:
        return ''.join(line.strip().split())

    def get_wsl_distro_n_list() -> list[str]:
        from pkg_py.pk_colorful_cli_util import pk_print
        try:
            result = subprocess.run(['wsl', '--list', '--quiet'], capture_output=True)
            output = result.stdout.decode('utf-16')
            return [line.replace(" ", "") for line in output.splitlines() if line.strip()]
        except Exception as e:
            pk_print(f"Failed to get WSL names: {e}", print_color='red')
            return []

    state_wsl_installed = None
    wsl_cmd_map_dict = {}
    wsl_distro_n_list = get_wsl_distro_n_list()
    if not wsl_distro_n_list:
        pk_print("No WSL distros found.", print_color='yellow')
        state_wsl_installed = 0
        return state_wsl_installed, wsl_cmd_map_dict

    wsl_cmd_map_dict["wsl state"] = ["wsl", "-l", "-v"]
    std_list = get_wsl_distro_info_std_list()
    for idx, name in enumerate(wsl_distro_n_list):
        matched_line = next((line for line in std_list if name.replace(" ", "") in clean_line(line)), "")
        state = "Unknown"
        version = "?"
        if matched_line:
            tokens = clean_line(matched_line)
            if "Running" in tokens:
                state = "Running"
            elif "Stopped" in tokens:
                state = "Stopped"
            match = re.search(r'(?:Running|Stopped)(\d)', tokens)
            if match:
                version = match.group(1)

        cmd_key = f"wsl {idx}"
        cmd_value = ["wsl", "-d", name]
        wsl_cmd_map_dict[cmd_key] = cmd_value
        if LTA:
            pk_print(f"Added: {cmd_key} = {cmd_value} ({state}, v{version})")
        state_wsl_installed = 1

    # shutdown 명령 수동 등록
    wsl_cmd_map_dict["wsl shutdown"] = ["wsl", "--shutdown"]

    return state_wsl_installed, wsl_cmd_map_dict


def assist_to_change_d():
    from pkg_py.pk_core_constants import D_PKG_PY, D_HOME, D_DOWNLOADS
    import os
    import inspect
    import sys
    from colorama import init as pk_colorama_init
    from pkg_py.pk_core_constants import D_PROJECT, STAMP_TRY_GUIDE, D_WORKING, D_PKG_TXT, D_DESKTOP, D_C_DRIVE, D_D_DRIVE, D_F_DRIVE, D_G_DRIVE, D_H_DRIVE, D_I_DRIVE, D_J_DRIVE

    from pkg_py.pk_colorful_cli_util import pk_print

    pk_colorama_init(autoreset=True)

    f_cd_txt = os.path.join(D_PKG_TXT, "pk_cd.txt")
    if not does_pnx_exist(f_cd_txt):
        ensure_pnx_made(f_cd_txt, mode='f')

    minus_list = [rf"{D_PKG_PY}/???.py"]
    minus_list = [get_pnx_os_style(element) for element in minus_list]
    from os import path

    plus_list = [
        D_PKG_PY,
        D_PROJECT,
        D_WORKING,
        D_DOWNLOADS,
        D_HOME,
        D_DESKTOP,
        D_C_DRIVE,
        D_D_DRIVE,
        D_F_DRIVE,
        D_G_DRIVE,
        D_H_DRIVE,
        D_I_DRIVE,
        D_J_DRIVE,
    ]
    plus_list = [p for p in plus_list if path.exists(p)]  # 존재하는 경로만 필터링
    plus_list = [get_pnx_os_style(p) for p in plus_list]  # 파일경로 OS 스타일로 업데이트

    pk_cmd_n = 'cd'
    pk_cmd_single_dict = {
        '.': '.',
        'cls': 'cls',
        'cmd': 'cmd',
    }
    func_n = inspect.currentframe().f_code.co_name
    # stamp_func_n = rf'({func_n})'

    first_loop = 1
    if LTA:
        pk_print(f'''first_loop={first_loop} {'%%%FOO%%%' if LTA else ''}''')

    while 1:
        d_working_list = get_pnx_list(with_walking=0, d_working=get_d_working_in_python(), mode='d')
        d_working_with_idx_dict = get_pnx_working_with_idx_dict(pnx_working_list=d_working_list, pnx_minus_list=minus_list, pnx_plus_list=plus_list)

        pk_cmd = None
        pk_cmd_str = None
        pk_sys_argv = None
        if first_loop:  # trigger : oneshoot

            first_loop = 0
            if LTA:
                pk_print(f'''first_loop={first_loop} {'%%%FOO%%%' if LTA else ''}''')
            pk_cmd = ''
            pk_cmd_str = pk_cmd.strip()
            pk_sys_argv = pk_cmd_str.split(" ")
        else:
            pk_cmd = pk_input_validated(str_working='', mode_verbose=0, mode_upper=0, mode_blank_validation=0, input_str=rf'''{pk_get_colorful_working_str_with_stamp_enviromnet(func_n=func_n, ment=f'{get_d_working_in_python()} >>>')}''')  # best practice input
            pk_cmd_str = pk_cmd.strip()
            pk_sys_argv = pk_cmd_str.split(" ")

        if len(pk_sys_argv) >= 2:
            if not str.isdigit(pk_sys_argv[1]):
                pk_print(f'''{STAMP_TRY_GUIDE} cd {{index}} , index is not str ' {'%%%FOO%%%' if LTA else ''}''', print_color='red')
                continue
            if str.isdigit(pk_sys_argv[1]):
                if int(pk_sys_argv[1]) >= len(d_working_with_idx_dict):
                    pk_print(f'''{STAMP_TRY_GUIDE} cd {{index}} , out of index' {'%%%FOO%%%' if LTA else ''}''', print_color='red')
                    continue

        if LTA:
            pk_print(f'''pk_cmd_argv={pk_sys_argv} {'%%%FOO%%%' if LTA else ''}''')
            pk_print(f'''len(pk_cmd_argv)={len(pk_sys_argv)} {'%%%FOO%%%' if LTA else ''}''')

        if len(pk_sys_argv) == 1:
            if pk_cmd_single_dict['.'] == pk_sys_argv[0]:
                if is_os_windows():
                    cmd_to_os(f'explorer.exe {get_d_working_in_python()}')
                continue
            elif pk_cmd_single_dict['cls'] == pk_sys_argv[0]:  # fail
                if is_os_windows():
                    cmd_to_os(f'cls')
                continue
            elif pk_cmd_single_dict['cmd'] == pk_sys_argv[0]:
                if is_os_windows():
                    # cmd_to_os(f'start "" cmd')
                    cmd_to_os(f'cmd /k')
                continue
            elif pk_cmd_str == "":
                highlight_config_dict = {
                    "green": [
                        'cd',
                        pk_cmd_n
                    ],
                    'red': [
                        'Stopped'
                    ],
                }
                list_to_print = []
                for idx, pnx_working in enumerate(d_working_with_idx_dict):
                    list_to_print.append(f'''{pk_cmd_n} {idx:<2} ({d_working_with_idx_dict[idx]})''')
                pk_debug_state_for_py_data_type(pk_stamp='%%%FOO%%%-1', data_working=list_to_print, highlight_config_dict=highlight_config_dict, with_LTA=0)
                continue
            else:
                pk_print(f'''Not Prepared function :) {'%%%FOO%%%' if LTA else ''}''', print_color='green', mode_verbose=0)
                continue

        if len(pk_sys_argv) == 2:
            nx_by_user_input = pk_sys_argv[1]
            if str.isdigit(nx_by_user_input):
                if LTA:
                    pk_print(f'''인자가 숫자 입니다. {'%%%FOO%%%' if LTA else ''}''')
                idx_by_user_input = int(pk_sys_argv[1])
                d_idx = d_working_with_idx_dict[idx_by_user_input]
                nx_idx = get_nx(d_working_with_idx_dict[idx_by_user_input])
                cmd = f'cd {d_idx}"'
                os.chdir(d_idx)
                # pk_copy(str_working=d_idx)
                if LTA:
                    pk_print(f'{pk_cmd_n} {pk_sys_argv[1]} {get_nx(d_idx)}')
                    pk_print(f'''{STAMP_TRY_GUIDE} {cmd} {'%%%FOO%%%' if LTA else ''}''')
                save_d_to_f(d=d_idx, f=f_cd_txt)
                if LTA:
                    f_cd_txt_list = get_list_from_f(f=f_cd_txt)
                    pk_print(f'''f_cd_txt_list={f_cd_txt_list} {'%%%FOO%%%' if LTA else ''}''')
                pk_cd(sys_argv=sys.argv)
                continue
            else:
                if LTA:
                    pk_print(f'''인자가 숫자가 아닙니다. {'%%%FOO%%%' if LTA else ''}''')
                continue

        elif len(sys.argv) < 2:
            if LTA:
                pk_print(f'인자가 {len(pk_sys_argv)}개 입력되었습니다 {'%%%FOO%%%' if LTA else ''}')

        break


def get_age_package(yyyy_birth, mm_birth, dd_birth, today_date=None):
    from datetime import date

    yyyy_birth = int(yyyy_birth)
    mm_birth = int(mm_birth)
    dd_birth = int(dd_birth)

    # today_date가 주어지지 않으면 오늘 날짜로 설정
    today = today_date or date.today()

    korean_age = today.year - yyyy_birth + 1
    has_had_birthday = (today.month, today.day) >= (mm_birth, dd_birth)
    international_age = today.year - yyyy_birth if has_had_birthday else today.year - yyyy_birth - 1

    return korean_age, international_age


def get_hostname_v2():
    hostname = cmd_to_os("hostname")[0]
    hostname = get_str_url_decoded(hostname)
    return hostname


def get_hostname():
    return get_hostname_v2()


def is_second(ss):
    from datetime import datetime
    return datetime.today().second == int(ss)


def is_minute(mm):
    from datetime import datetime
    return datetime.today().minute == int(mm)


def is_hour(hh):
    from datetime import datetime
    return datetime.today().hour == int(hh)


def is_day(dd):
    from datetime import datetime
    return datetime.today().day == int(dd)


def is_month(mm):
    from datetime import datetime
    return datetime.today().month == int(mm)


def is_year(yyyy):
    from datetime import datetime
    return datetime.today().year == int(yyyy)


def make_and_get_d_temp(prefix: str = "temp") -> str:
    # todo with open() 처럼 동작하는 코드로 만들어 보자 # pk_explorer # pk_dot_slash
    import uuid
    from pathlib import Path

    D_DESKTOP = Path.home() / "Desktop"
    unique_n = f"{prefix}_{uuid.uuid4().hex[:8]}"  # sample: temp_5f2d8c3a
    pnx_working = D_DESKTOP / unique_n

    if not does_pnx_exist(str(pnx_working)):
        ensure_pnx_made(pnx=str(pnx_working), mode='d')

    return str(pnx_working)


def shutdown_this_computer():
    cmd_to_os(rf'%windir%\System32\Shutdown.exe -s ')


def kill_os():
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    pk_print(f"{inspect.currentframe().f_code.co_name}()")
    shutdown_this_computer()


def get_installed_wsl_distros():
    from pkg_py.pk_colorful_cli_util import pk_print
    import subprocess
    import re
    try:
        result = subprocess.run(['wsl', '-l', '-v'], capture_output=True)
        output = result.stdout.decode('utf-16')
        std_list = output.splitlines()
        for std_str in std_list:
            if LTA:
                pk_print(std_str)
        distros = []
        for line in std_list[1:]:
            line = line.strip()
            if not line:
                continue
            if line.startswith("*"):
                line = line[1:].strip()
            parts = re.split(r'\s{2,}', line)
            if LTA:
                pk_print(f'''parts={parts} {'%%%FOO%%%' if LTA else ''}''')
            if len(parts) >= 3:
                name, state, version = parts[0], parts[1], parts[2]
                distros.append({
                    'name': name.strip(),
                    'state': state.strip(),
                    'version': int(version.strip())
                })
        return distros
    except subprocess.CalledProcessError as e:
        pk_print(f"Failed to list WSL distros: {e}", print_color='red')
        return []


def assist_to_control_wsl(**pk_config):
    from pkg_py.pk_core_constants import STAMP_TRY_GUIDE
    from pkg_py.pk_colorful_cli_util import pk_print
    from colorama import init as pk_colorama_init
    import inspect
    import subprocess
    import time
    pk_colorama_init(autoreset=True)
    func_n = inspect.currentframe().f_code.co_name

    class _PkWslController:
        def __init__(self):
            self._pk_wsl_controller_version = pk_config.get('pk_wsl_controller_version', 'auto_version.1.0')
            self._pk_wsl_cmd_exec_map_dict = pk_config.get('pk_wsl_cmd_exec_map_dict', {})
            self._pk_wsl_cmd_list = pk_config.get('pk_wsl_cmd_list', [])
            self._pk_wsl_cmd_map_dict = pk_config.get('pk_wsl_cmd_map_dict', {})
            self._pk_wsl_cmd_list_len = pk_config.get('pk_wsl_cmd_list_len', 0)

        def _print_pk_wsl_ver(self, version):
            pk_print(version, print_color='blue')

        def _print_pk_available_wsl_cmd_list(self):
            pk_print("======== Available WSL Commands ========")
            for idx, cmd in enumerate(self._pk_wsl_cmd_list):
                actual_cmd = ' '.join(self._pk_wsl_cmd_exec_map_dict.get(cmd, [cmd]))
                pk_print(f'wsl {idx} : {actual_cmd}')

        def _excute_wsl_cmd(self, idx_by_user_input, sys_arg2=None):

            user_cmd_key = self._pk_wsl_cmd_map_dict.get(idx_by_user_input)
            exec_cmd = self._pk_wsl_cmd_exec_map_dict.get(user_cmd_key)

            if exec_cmd is None:
                pk_print(f"Unknown command mapping for '{user_cmd_key}'", print_color='red')
                return

            if LTA:
                pk_print(f"Trying to run: {exec_cmd}")

            if "-d" in exec_cmd:
                real_distro = exec_cmd[-1]
                current_installed_distros = get_installed_wsl_distros()
                if not any(d['name'].strip().lower() == real_distro.strip().lower() for d in current_installed_distros):
                    pk_print(f"Distro '{real_distro}' not found. Please install it first.", print_color='red')
                    return

            try:
                if LTA:
                    pk_print(f"{STAMP_TRY_GUIDE} silently ran: {' '.join(exec_cmd)}")
                    pk_print(f"{' '.join(exec_cmd)} started in background", print_color='green')
                if "-d" in exec_cmd:
                    state_before_list = get_wsl_distro_info_std_list()
                    subprocess.Popen(exec_cmd, creationflags=subprocess.CREATE_NO_WINDOW)
                    while 1:
                        state_after_list = get_wsl_distro_info_std_list()
                        if state_before_list != state_after_list:
                            print_wsl_distro_info_std_list()
                elif '--shutdown' in exec_cmd:
                    state_before_list = get_wsl_distro_info_std_list()
                    subprocess.Popen(['wsl', '--shutdown'], creationflags=subprocess.CREATE_NO_WINDOW)
                    while 1:
                        state_after_list = get_wsl_distro_info_std_list()
                        if LTA:
                            pk_print(f'''state_before_list={state_before_list} {'%%%FOO%%%' if LTA else ''}''')
                            pk_print(f'''state_after_list={state_after_list} {'%%%FOO%%%' if LTA else ''}''')
                        if state_before_list != state_after_list:
                            print_wsl_distro_info_std_list()
                            break
                elif '-l' in exec_cmd and '-v' in exec_cmd:
                    print_wsl_distro_info_std_list()

            except Exception as e:
                pk_print(f"Failed to run {' '.join(exec_cmd)}: {e}", print_color='red')

        def _guide_error_mssage(self):
            pk_print("Not Prepared function :)", print_color='green', mode_verbose=0)

    _pwc = _PkWslController()
    cnt_loop = 0
    pk_sys_argv = []
    while 1:
        if cnt_loop == 0:  # trigger : oneshoot
            cnt_loop = cnt_loop + 1
            # pk_sys_argv = ['wsl', '0']  # wsl 0 실행
        if is_office_pc():
            if cnt_loop == 1:
                cnt_loop = cnt_loop + 1
                # pk_sys_argv = ['wsl', '1']
                # pk_sleep(seconds = 4) # wsl 실행시간 대기
            if cnt_loop == 2:
                cnt_loop = cnt_loop + 1
                pk_sys_argv = ['wsl', '3']
                pk_seconds_limit = 5
                pk_time_s = time.time()
                while 1:
                    elapsed = time.time() - pk_time_s
                    if elapsed >= pk_seconds_limit:
                        pk_print(f'''time is limited (pk_time_limit={pk_seconds_limit}) {'%%%FOO%%%' if LTA else ''}''')
                        raise
                    user_input = pk_input_with_timeout("계속 wsl 환경을 쓸까요? 아무것도 안하면 환경이 종료됩니다. Enter를 누르면 유지됩니다", timeout_secs=int(pk_seconds_limit - elapsed))
                    if user_input == "":
                        break
                    elif user_input is None:
                        pk_print(f'''time is limited (pk_time_limit={pk_seconds_limit}) {'%%%FOO%%%' if LTA else ''}''')
                        raise

        else:
            if cnt_loop == 1:
                pk_sys_argv = ['wsl', '1']
                cnt_loop = cnt_loop + 1

        if len(pk_sys_argv) == 1:
            _pwc._print_pk_available_wsl_cmd_list()

        elif len(pk_sys_argv) == 2:
            idx_map = get_idx_list(item_iterable=_pwc._pk_wsl_cmd_map_dict)
            idx_map = list(map(str, idx_map))

            if pk_sys_argv[1] in ['--version', '-v', 'ver']:
                _pwc._print_pk_wsl_ver(version=_pwc._pk_wsl_controller_version)

            elif pk_sys_argv[1] in ['--list', '-l', 'ls'] or pk_sys_argv == ['wsl', 'ls']:
                _pwc._print_pk_available_wsl_cmd_list()

            elif pk_sys_argv[1] in idx_map:
                _pwc._excute_wsl_cmd(idx_by_user_input=int(pk_sys_argv[1]))

            else:
                _pwc._guide_error_mssage()

        elif len(pk_sys_argv) == 3:
            idx_map = get_idx_list(item_iterable=_pwc._pk_wsl_cmd_map_dict)
            idx_map = list(map(str, idx_map))
            if pk_sys_argv[1] in idx_map:
                _pwc._excute_wsl_cmd(idx_by_user_input=int(pk_sys_argv[1]))

        pk_wsl_cmd_from_input = input(rf'{pk_get_colorful_working_str_with_stamp_enviromnet(func_n=func_n, ment="WRITE PK WSL CMD")} >>>')
        pk_wsl_cmd_from_input = pk_wsl_cmd_from_input.strip()
        pk_wsl_cmd_list = pk_wsl_cmd_from_input.split(" ")
        pk_sys_argv = pk_wsl_cmd_list


def print_data_from_csv(f_csv_path, preview_rows=10):
    import pandas as pd
    import os
    from pkg_py.pk_colorful_cli_util import pk_print
    if not os.path.exists(f_csv_path):
        pk_print(f"❌ 파일이 존재하지 않습니다: {f_csv_path}", print_color='red')
        return
    try:
        df = pd.read_csv(f_csv_path)
        pk_print(f"📄 파일 로드 성공: {f_csv_path}", print_color="green")
        pk_print(f"🔢 총 {len(df)}행 × {len(df.columns)}열", print_color="blue")
        pk_print(df)

    except Exception as e:
        pk_print(f"⚠️ CSV 파일 읽기 실패: {e}", print_color='red')


def get_migrate_device_table_from_f_xlsx_to_local_db():
    """함수 호출 주의 sqlite/table overiwte 됨"""

    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PROJECT_RELEASE_SERVER

    import pandas as pd
    import sqlite3

    # 1. 엑셀 파일 로드
    excel_path = f"{D_PROJECT_RELEASE_SERVER}\\영상처리제어기 업무현황.xlsx"
    sheet_name = "업무현황"
    df_raw = pd.read_excel(excel_path, sheet_name=sheet_name)

    # 2. 첫 번째 행을 컬럼으로 설정하고 불필요한 행 remove
    df_raw.columns = df_raw.iloc[0]
    df = df_raw[1:].copy()

    # 3. 필요한 컬럼만 선택
    df = df[[
        "장비식별자", "스티커라벨코드", "Nvidia Serial", "용도",
        "AI fraework 배포파일 버전", "위치", "업무트래킹", "최신업무트래킹"
    ]]
    df = df.dropna(subset=["장비식별자"])

    # 4. SQLite DB로 저장
    db_path = "xc_status.db"
    conn = sqlite3.connect(db_path)
    df.to_sql("xc_status", conn, if_exists="replace", index=False)

    cursor = conn.cursor()
    cursor.execute("SELECT COUNT(*) FROM xc_status;")
    total_rows = cursor.fetchone()[0]
    pk_print(f"xc_status 테이블 총 {total_rows}행 저장됨", print_color='blue')

    pk_print("저장된 데이터 미리보기:", print_color='blue')
    preview_df = pd.read_sql("SELECT * FROM xc_status LIMIT 5", conn)
    print(preview_df)

    pk_print("테이블 컬럼 구조:", print_color='blue')
    cursor.execute("PRAGMA table_info(xc_status);")
    for col in cursor.fetchall():
        print(f"- {col[1]} ({col[2]})")

    conn.close()
    pk_print("마이그레이션 완료: xc_status.db (테이블명: xc_status)", print_color='green')


def pk_input_with_timeout(working_str: str, timeout_secs: int = 9999) -> str | None:
    import sys
    import threading
    from queue import Queue, Empty

    print(working_str, end=" ", flush=True)
    input_queue = Queue()

    def read_input():
        user_input = sys.stdin.readline()
        input_queue.put(user_input.strip())

    input_thread = threading.Thread(target=read_input, daemon=True)
    input_thread.start()

    try:
        return input_queue.get(timeout=timeout_secs)
    except Empty:
        return None


@pk_measure_seconds
def get_pk_pnx_working_with_idx_dict():
    from pkg_py.pk_core_constants import D_PKG_PY
    pnx_list = get_pnx_list(d_working=D_PKG_PY, with_walking=0)
    list_b = [rf"{D_PKG_PY}/__init__.py", f"{D_PKG_PY}/__pycache__"]
    list_b = [get_pnx_os_style(element) for element in list_b]
    pk_pnx_working_with_idx_dict = get_pnx_working_with_idx_dict(pnx_working_list=pnx_list, pnx_minus_list=list_b)
    return pk_pnx_working_with_idx_dict


def get_available_pk_python_program_pnx(pk_idx):
    pk_pnx_working_with_idx_dict = get_pk_pnx_working_with_idx_dict()
    pk_python_program_pnx_working = pk_pnx_working_with_idx_dict[pk_idx]
    return pk_python_program_pnx_working


def ensure_tmux_pk_session_removed(tmux_pk_session):
    from pkg_py.pk_colorful_cli_util import pk_print
    if LTA:
        pk_print(f'''pk_session_n={tmux_pk_session} {'%%%FOO%%%' if LTA else ''}''')
    for std_str in cmd_to_os(f'tmux ls'):
        if tmux_pk_session in std_str:
            cmd_to_os(f'tmux kill-session -t {tmux_pk_session}')


@pk_measure_seconds
def pk_run_process_by_idx(pk_idx, pk_arg_list):
    import os
    from pkg_py.pk_core_constants import STAMP_TRY_GUIDE
    from pkg_py.pk_colorful_cli_util import pk_print
    cmd_to_run = None
    cmd = None
    if pk_arg_list is None:
        pk_arg_list = []
    if LTA:
        pk_print(f'''pk_idx={pk_idx} {'%%%FOO%%%' if LTA else ''}''')
        for idx, _ in enumerate(pk_arg_list):
            pk_print(f'''pk_arg_list[{idx}]={pk_arg_list[idx]} {'%%%FOO%%%' if LTA else ''}''')
    available_pk_python_program_pnx = get_available_pk_python_program_pnx(pk_idx)
    if pk_arg_list is None:
        pk_arg_list = []  # ✅ 빈 리스트로 대체
    # if get_x(available_pk_python_program_pnx) == '.py':
    #     cmd_to_run = 'python'
    cmd_to_run = 'uv run python'
    cmd_to_run = 'python'
    if LTA:
        pk_print(f'''pk_idx={pk_idx} {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''get_nx(pk_python_program_pnx_working)={get_nx(available_pk_python_program_pnx)} {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''cmd_to_run={cmd_to_run} {'%%%FOO%%%' if LTA else ''}''')
    if is_os_windows():
        cmd_to_autorun = get_cmd_to_autorun()
        if LTA:
            pk_print(f'''pk_arg_list={pk_arg_list} {'%%%FOO%%%' if LTA else ''}''')
        arg_cnt_allowed = 2
        while len(pk_arg_list) <= arg_cnt_allowed:
            pk_arg_list.append('')
        if pk_arg_list[2] in ['-ww', '--without window']:
            if LTA:
                cmd = f'cmd.exe /k "{cmd_to_autorun} && title {get_nx(available_pk_python_program_pnx)}&& {cmd_to_run} {available_pk_python_program_pnx}"'
            else:
                cmd = f'cmd.exe /c "{cmd_to_autorun} && title {get_nx(available_pk_python_program_pnx)}&& {cmd_to_run} {available_pk_python_program_pnx}"'
            # cmd_to_os(cmd=cmd, mode_with_window=0)
            cmd_to_os(cmd=cmd, mode='a', mode_with_window=0)
        else:  # with new window
            if LTA:
                cmd = f'start "" cmd.exe /k "{cmd_to_autorun} && title {get_nx(available_pk_python_program_pnx)}&& {cmd_to_run} {available_pk_python_program_pnx}"'
            else:
                cmd = f'start "" cmd.exe /c "{cmd_to_autorun} && title {get_nx(available_pk_python_program_pnx)}&& {cmd_to_run} {available_pk_python_program_pnx}"'
            #         cmd_to_os(cmd=cmd, mode_with_window=1)
            cmd_to_os(cmd=cmd, mode='a', mode_with_window=1)
        if LTA:
            pk_print(f'''{STAMP_TRY_GUIDE} {cmd} {'%%%FOO%%%' if LTA else ''}''')
    if is_os_wsl_linux():
        # available_pk_python_program_pnx = get_pnx_windows_style(available_pk_python_program_pnx)
        # if LTA:
        #     cmd = f'bash.sh /c "title {get_nx(available_pk_python_program_pnx)} && {cmd_to_run} {available_pk_python_program_pnx}"'
        # else:
        #     cmd = f'bash.sh /c "title {get_nx(available_pk_python_program_pnx)} && '
        # tmux_pk_session = f'{get_nx(available_pk_python_program_pnx).replace(".", "_")}'
        # ensure_tmux_pk_session_removed(tmux_pk_session = tmux_pk_session)
        # # cmd_to_os(cmd=f'tmux new-session -s {tmux_pk_session} -d')       # 백그라운드에 {pk_session_n} 세션 생성
        # # cmd_to_os(cmd=f'tmux split-window -t pk_session_1:0 -v')    # 첫 창을 상하로 분할
        # # cmd_to_os(cmd=f'tmux split-window -t {tmux_pk_session}:0 -v')    # 첫 창을 상하로 분할
        # # cmd_to_os(cmd=f'tmux split-window -t {tmux_pk_session}:0.1 -h')  # 아래쪽 페인을 좌우로 분할
        # # cmd_to_os(cmd=f"tmux send-keys -t {tmux_pk_session} 'clear && {cmd_to_run} {available_pk_python_program_pnx}' C-m")       # 세션에 명령어 수행
        # # cmd_to_os(cmd=f'tmux attach-session -t {tmux_pk_session}')       # 세션에 연결
        # # cmd_to_os(cmd=f"tmux split-window -t {tmux_pk_session}:0 -h 'clear && {cmd_to_run} {available_pk_python_program_pnx}' C-m'")
        # # cmd_to_os(cmd=f"tmux split-window -t {tmux_pk_session}:0 -h 'clear && {cmd_to_run} {available_pk_python_program_pnx}'")
        # if LTA:
        #     cmd_to_os(cmd=f"tmux split-window -t {tmux_pk_session}:0 -v 'clear && {cmd_to_run} {available_pk_python_program_pnx}; sleep 99999 '")
        #     cmd_to_os(cmd=f"tmux a -t {tmux_pk_session}")
        # else:
        #     cmd_to_os(cmd=f"tmux split-window -t {tmux_pk_session}:0 -v 'clear && {cmd_to_run} {available_pk_python_program_pnx}; '")
        #     cmd_to_os(cmd=f"tmux a -t {tmux_pk_session}")

        # tmux_pk_session = get_nx(available_pk_python_program_pnx).replace(".", "_")
        # # 기존 세션이 있으면 삭제
        # ensure_tmux_pk_session_removed(tmux_pk_session)
        # # 새로운 세션 생성 후 첫 페인에서 실행
        # cmd_to_os(cmd=(
        #     f"tmux new-session -s {tmux_pk_session} -d "
        #     f"'clear && {cmd_to_run} {available_pk_python_program_pnx}'"
        # ))
        # # 위/아래 분할(수직) 후 아래쪽 페인에서 동일 명령 실행
        # cmd_to_os(cmd=(
        #     f"tmux split-window -v -t {tmux_pk_session} "
        #     f"'clear && {cmd_to_run} {available_pk_python_program_pnx}'"
        # ))
        # # 세션에 연결
        # cmd_to_os(cmd=f"tmux attach-session -t {tmux_pk_session}")

        # 기존 세션 제거
        tmux_session = get_nx(available_pk_python_program_pnx).replace(".", "_")
        ensure_tmux_pk_session_removed(tmux_session)

        # # 새 세션 생성 & 첫 페인에서 실행
        # cmd_to_os(cmd=(
        #     f"tmux new-session -s {tmux_session} -d "
        #     f"'clear && {cmd_to_run} {available_pk_python_program_pnx}'"
        # ))
        #
        # # 상하 분할 & 아래 페인에서 동일 명령 실행
        # cmd_to_os(cmd=(
        #     f"tmux split-window -v -t {tmux_session} "
        #     f"'clear && {cmd_to_run} {available_pk_python_program_pnx}'"
        # ))
        #
        # # 이미 tmux 안에서 실행 중인지 확인
        # if os.environ.get("TMUX"):
        #     # nested 세션일 땐 switch-client
        #     attach_cmd = f"tmux attach-session -t {tmux_session}"
        # else:
        #     # tmux 밖에서 실행 중이면 attach
        #     attach_cmd = f"tmux switch-client -t {tmux_session}"
        # cmd_to_os(cmd=attach_cmd)

        # (A) 이미 tmux 내부에서 실행 중이라면: 현재 활성 페인만 분할해 실행
        if os.environ.get("TMUX"):
            # 수직 분할: -v, 수평 분할: -h 로 바꿀 수 있음
            split_flag = "-v"
            # LTA 모드라면 끝에 sleep 추가
            sleep_cmd = "; sleep 99999" if LTA else ""
            cmd_to_os(cmd=(
                f"tmux split-window {split_flag} "
                # f"'clear && {cmd_to_run} {available_pk_python_program_pnx}{sleep_cmd}'"
                f"'{cmd_to_run} {available_pk_python_program_pnx}{sleep_cmd}'"
            ))
            return

        # (B) tmux 밖에서 실행 중이라면: new-session → split → attach
        tmux_session = get_nx(available_pk_python_program_pnx).replace(".", "_")
        ensure_tmux_pk_session_removed(tmux_session)

        # 새 세션 생성 & 첫 페인에서 실행
        cmd_to_os(cmd=(f"tmux new-session -s {tmux_session} -d '{cmd_to_run} {available_pk_python_program_pnx}'"))
        # 수직 분할 & 아래 페인에서 동일 명령 실행
        cmd_to_os(cmd=(f"tmux split-window -v -t {tmux_session} '{cmd_to_run} {available_pk_python_program_pnx}'"))
        # 세션에 연결
        cmd_to_os(cmd=f"tmux attach-session -t {tmux_session}")

        # run_pk_for_wsl_linux(
        #     cmd_to_autorun="cmd.exe",
        #     cmd_to_run="uv run python",
        #     available_pk_python_program_pnx=available_pk_python_program_pnx,
        #     pk_arg_list=pk_arg_list,
        #     LTA=True
        # )
    else:
        # run_pk_on_linux(
        #     cmd_to_autorun="source ~/.bashrc",
        #     cmd_to_run="uv run python",
        #     available_pk_python_program_pnx=available_pk_python_program_pnx,
        #     pk_arg_list=pk_arg_list,
        #     LTA=True
        # )
        pass


def run_pk_on_linux(cmd_to_autorun: str,
                    cmd_to_run: str,
                    available_pk_python_program_pnx: str,
                    pk_arg_list: list[str],
                    LTA: bool = False):
    from pkg_py.pk_colorful_cli_util import pk_print
    if not is_os_windows():
        if LTA:
            pk_print(f"cmd_to_autorun={cmd_to_autorun} {'%%%FOO%%%' if LTA else ''}")
            pk_print(f"cmd_to_run={cmd_to_run} {'%%%FOO%%%' if LTA else ''}")
            pk_print(f"available_pk_python_program_pnx={available_pk_python_program_pnx} {'%%%FOO%%%' if LTA else ''}")
            pk_print(f"pk_arg_list={pk_arg_list} {'%%%FOO%%%' if LTA else ''}")

        # Ensure minimum length
        while len(pk_arg_list) <= 2:
            pk_arg_list.append('')

        # dedulication tmux session
        ensure_tmux_pk_session_removed(tmux_pk_session=f'{get_n(available_pk_python_program_pnx)}')

        # Build the command string
        # {cmd_to_autorun} &&
        full_cmd = f"{cmd_to_run} {available_pk_python_program_pnx}"
        pk_print(f"full_cmd={full_cmd} {'%%%FOO%%%' if LTA else ''}")
        cmd_to_os(full_cmd)

        return

        # Ensure tmux is installed
        ensure_ubuntu_pkg_installed(ubuntu_pkg_n='tmux')
        tmux_bin = shutil.which(ubuntu_pkg_n)

        # Determine session and working directory
        session = os.environ.get('PK_TMUX_SESSION', pk_session_n)
        cwd = os.getcwd()

        # Create session if it doesn't exist
        result = subprocess.run([tmux_bin, 'has-session', '-t', session],
                                stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        if result.returncode != 0:
            subprocess.run(
                [tmux_bin, 'new-session', '-d', '-s', session, '-c', cwd],
                check=True
            )

        # Split a new pane in the first window (index 0) and run the command
        target_pane = f"{session}:0"
        split_cmd = [
            tmux_bin,
            'split-window',
            '-t', target_pane,
            '-c', cwd,
            f"{full_cmd}; exec bash"
        ]

        if LTA:
            pk_print(f"RUN_PANE: {' '.join(split_cmd)} {'%%%FOO%%%' if LTA else ''}")
        subprocess.Popen(split_cmd)
        # cmd_to_os('tmux ls')
        cmd_to_os(f'tmux a -t {pk_session_n}')


def run_pk_for_wsl_linux(cmd_to_autorun: str,
                         cmd_to_run: str,
                         available_pk_python_program_pnx: str,
                         pk_arg_list: list[str],
                         LTA: bool = False):
    from pkg_py.pk_colorful_cli_util import pk_print
    if not is_os_windows():
        if LTA:
            pk_print(f"cmd_to_autorun={cmd_to_autorun} {'%%%FOO%%%' if LTA else ''}")
            pk_print(f"cmd_to_run={cmd_to_run} {'%%%FOO%%%' if LTA else ''}")
            pk_print(f"available_pk_python_program_pnx={available_pk_python_program_pnx} {'%%%FOO%%%' if LTA else ''}")
            pk_print(f"pk_arg_list={pk_arg_list} {'%%%FOO%%%' if LTA else ''}")

        # Ensure minimum length
        while len(pk_arg_list) <= 2:
            pk_arg_list.append('')

        # dedulication session
        pk_session_n = f'{get_n(available_pk_python_program_pnx)}'
        pk_print(f'''pk_session_n={pk_session_n} {'%%%FOO%%%' if LTA else ''}''')

        for std_str in cmd_to_os(f'tmux ls'):
            if pk_session_n in std_str:
                cmd_to_os(f'tmux kill-session -t {pk_session_n}')

        # Build the command string
        # {cmd_to_autorun} &&
        full_cmd = f"{cmd_to_run} {available_pk_python_program_pnx}"
        pk_print(f"full_cmd={full_cmd} {'%%%FOO%%%' if LTA else ''}")
        cmd_to_os(full_cmd)

        return

        # Ensure tmux is installed
        ensure_ubuntu_pkg_installed(ubuntu_pkg_n='tmux')
        tmux_bin = shutil.which(ubuntu_pkg_n)

        # Determine session and working directory
        session = os.environ.get('PK_TMUX_SESSION', pk_session_n)
        cwd = os.getcwd()

        # Create session if it doesn't exist
        result = subprocess.run([tmux_bin, 'has-session', '-t', session],
                                stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        if result.returncode != 0:
            subprocess.run(
                [tmux_bin, 'new-session', '-d', '-s', session, '-c', cwd],
                check=True
            )

        # Split a new pane in the first window (index 0) and run the command
        target_pane = f"{session}:0"
        split_cmd = [
            tmux_bin,
            'split-window',
            '-t', target_pane,
            '-c', cwd,
            f"{full_cmd}; exec bash"
        ]

        if LTA:
            pk_print(f"RUN_PANE: {' '.join(split_cmd)} {'%%%FOO%%%' if LTA else ''}")
        subprocess.Popen(split_cmd)
        # cmd_to_os('tmux ls')
        cmd_to_os(f'tmux a -t {pk_session_n}')


def pk_run_process_v1(pk_program_n_seg=None, pk_arg_list=None):
    from pkg_py.pk_colorful_cli_util import pk_print
    # from colorama import init as pk_colorama_init
    # pk_colorama_init(autoreset=True)
    if pk_program_n_seg:
        pk_python_program_pnx_list = get_pk_python_program_pnx_list()
        for pk_idx, pk_python_program_pnx in enumerate(pk_python_program_pnx_list):
            if pk_program_n_seg in pk_python_program_pnx:
                pk_run_process_by_idx(pk_idx=int(pk_idx), pk_arg_list=pk_arg_list)
                if LTA:
                    pk_print(f'''pk_idx={pk_idx} get_nx(pk_python_program_pnx)={get_nx(pk_python_program_pnx)} pk_python_program_n_seg={pk_program_n_seg} {'%%%FOO%%%' if LTA else ''}''', print_color='green')
            else:
                if LTA:
                    pk_print(f'''pk_idx={pk_idx} get_nx(pk_python_program_pnx)={get_nx(pk_python_program_pnx)} pk_python_program_n_seg={pk_program_n_seg} {'%%%FOO%%%' if LTA else ''}''', print_color='red')


def pk_run_process_v2(pk_program_n_seg=None, pk_arg_list=None):
    from pkg_py.pk_colorful_cli_util import pk_print

    if not pk_program_n_seg:
        pk_print("[SKIP] No segment provided.", print_color="yellow")
        return

    pk_list = get_pk_python_program_pnx_list()
    nx_map = [(i, get_nx(p)) for i, p in enumerate(pk_list)]

    for pk_idx, program_nx in nx_map:
        if pk_program_n_seg in program_nx:
            pk_run_process_by_idx(pk_idx, pk_arg_list)
            if LTA:
                pk_print(f"pk_idx={pk_idx} get_nx={program_nx} pk_program_n_seg={pk_program_n_seg} {'%%%FOO%%%' if LTA else ''}", print_color="green")
            break
        else:
            if LTA:
                pk_print(f"pk_idx={pk_idx} get_nx={program_nx} pk_program_n_seg={pk_program_n_seg} {'%%%FOO%%%' if LTA else ''}")


@pk_measure_seconds
def pk_run_process(pk_program_n_seg=None, pk_arg_list=None):
    pk_run_process_v2(pk_program_n_seg=pk_program_n_seg, pk_arg_list=pk_arg_list)


@pk_measure_seconds
def print_pk_ls():
    from pkg_py.pk_core_constants import D_PKG_PY
    from pkg_py.pk_colorful_cli_util import pk_print

    pnx_list = get_pnx_list(d_working=D_PKG_PY, with_walking=0)
    list_b = [rf"{D_PKG_PY}/__init__.py", f"{D_PKG_PY}/__pycache__"]
    list_b = [get_pnx_os_style(element) for element in list_b]
    pnx_working_with_idx_dict = get_pnx_working_with_idx_dict(pnx_working_list=pnx_list, pnx_minus_list=list_b)

    if LTA:
        pk_print(f'''{'%%%FOO%%%' if LTA else ''}''')
    for idx, pnx_working in enumerate(pnx_working_with_idx_dict):
        print(f'pk {idx} {get_nx(pnx_working_with_idx_dict[idx])}')


@pk_measure_seconds
def get_pk_python_program_pnx_list():
    pk_pnx_working_with_idx_dict = get_pk_pnx_working_with_idx_dict()
    pk_python_pnx_working_without_idx_list = get_pnx_working_without_idx_list(pnx_working_with_idx_dict=pk_pnx_working_with_idx_dict)
    return pk_python_pnx_working_without_idx_list


@pk_measure_seconds
def cmd_to_pk():
    try:
        import sys
        from pkg_py.pk_colorful_cli_util import pk_print
        pk_python_program_available_idx_list = get_pk_python_program_available_idx_list()
        if LTA:
            pk_print(f'''len(sys.argv)={len(sys.argv)} {'%%%FOO%%%' if LTA else ''}''')
        if len(sys.argv) == 1:
            if LTA:
                pk_print(f'인자가 {len(sys.argv)}개 입력되었습니다 {'%%%FOO%%%' if LTA else ''}')
            print_pk_ls()
        elif len(sys.argv) == 2:
            if LTA:
                pk_print(f'인자가 {len(sys.argv)}개 입력되었습니다 {'%%%FOO%%%' if LTA else ''}')
            if sys.argv[1] in ['--version', '-v', 'ver']:
                print_pk_ver()
            elif sys.argv[1] in ['--list', '-l', 'ls']:
                print_pk_ls()
            elif sys.argv[1] in pk_python_program_available_idx_list:
                pk_run_process_by_idx(pk_idx=int(sys.argv[1]), pk_arg_list=sys.argv)
            else:
                if not str.isdigit(sys.argv[1]):
                    guide_to_use_pk_python_program(pk_python_program_pnx_list=get_pk_python_program_pnx_list(), nx_by_user_input=sys.argv[1])
                else:
                    guide_pk_error_mssage()

        elif len(sys.argv) == 3:
            # todo : pk ass sche 인자 2개로 검색 후 출력
            if LTA:
                pk_print(f'인자가 {len(sys.argv)}개 입력되었습니다 {'%%%FOO%%%' if LTA else ''}')
            if sys.argv[1] in pk_python_program_available_idx_list:
                pk_run_process_by_idx(pk_idx=int(sys.argv[1]), pk_arg_list=sys.argv)
    except:
        import traceback
        traceback.print_exc()
        import sys
        traceback.print_exc(file=sys.stdout)


@pk_measure_seconds
def get_pk_python_program_available_idx_list():
    pk_python_pnx_working_without_idx_list = get_pk_python_program_pnx_list()
    pnx_working_idx_list = get_idx_list(item_iterable=pk_python_pnx_working_without_idx_list)
    pnx_working_idx_list = list(map(str, pnx_working_idx_list))  # each (element ->> str(element))
    return pnx_working_idx_list


@pk_measure_seconds
def guide_to_use_pk_python_program(pk_python_program_pnx_list, nx_by_user_input):
    from pkg_py.pk_core_constants import STAMP_TRY_GUIDE
    from pkg_py.pk_colorful_cli_util import pk_print

    if LTA:
        pk_print(f'''{'%%%FOO%%%' if LTA else ''}''')
    for idx, pnx_working in enumerate(pk_python_program_pnx_list):
        if nx_by_user_input in pnx_working:
            if LTA:
                pk_print(f'''pnx_working={pnx_working} {'%%%FOO%%%' if LTA else ''}''')
            if nx_by_user_input in get_nx(pnx_working):
                if nx_by_user_input != get_nx(pnx_working):
                    print(rf'''{STAMP_TRY_GUIDE} pk {idx} ({get_nx(pnx_working)}) {'%%%FOO%%%' if LTA else ''}''')
            else:
                if LTA:
                    pk_print(f'''{'%%%FOO%%%' if LTA else ''}''')
                break


def install_py_module(module_name):
    import sys
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", module_name])


def ensure_python_pkg_to_remote_os(py_pkg_n, **config_remote_os):
    # 파이썬 모듈 설치기능
    import importlib
    from pkg_py.pk_colorful_cli_util import pk_print

    if not is_internet_connected():
        pk_print(f'''can not install python module for internet not connected  {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        raise

    # todo if config_remote_os['ip'] == 'localhost' or local private ip or local public ip: 
    try:
        return importlib.import_module(py_pkg_n)
    except ModuleNotFoundError:
        pk_print(f"[ WARN ] '{py_pkg_n}' 모듈이 없습니다.", print_color='yellow')
        yn = input(f">> '{py_pkg_n}'를 설치하시겠습니까? (y/n): ").strip().lower()
        if yn != 'y':
            pk_print(f"[ ABORTED ] '{py_pkg_n}' 설치를 건너뜁니다.", print_color='yellow')
            return
        try:
            install_py_module(py_pkg_n)
            # todo installed 목록에서 확인 후 green
            pk_print(f"'{py_pkg_n}' installation", print_color='green')
            return importlib.import_module(py_pkg_n)
        except Exception as e:
            pk_print(f"'{py_pkg_n}' installation {e}", print_color='red')
            raise


def restart_f_list_with_new_window_as_async(f_list):
    import asyncio
    for f in f_list:
        asyncio.run(pk_kill_process_as_async(f=f))
    for f in f_list:
        asyncio.run(pk_run_process_as_async(f=f))


def ensure_vpc_accessable(vpc_data, **config_remote_os):
    ensure_vpc_ip(vpc_data, **config_remote_os)


def ensure_vpc_flash_report_file_existance(**config):
    # TODO
    vpc_type = config['vpc_type']
    flash_report_file_path = f"{vpc_type}_flash_report.txt"
    ensure_pnx_made(pnx=flash_report_file_path, mode='f', script_list=[
        "====================== ACU NO flash report ======================\n",
    ])
    with open(flash_report_file_path, "a") as f:
        f.write("ACU NO flash report\n")


def write_str_to_vpc_flash_report_file(wroking_str, **config, ):
    # TODO
    vpc_type = config['vpc_type']
    flash_report_file_path = f"{vpc_type}_flash_report.txt"
    with open(flash_report_file_path, "a") as f:
        f.write(f"{wroking_str}\n")


def ensure_wiring_pysical_right(vpc_data):
    from pkg_py.pk_colorful_cli_util import pk_print

    vpc_identifier = vpc_data.vpc_identifier

    # bring_NO_flash_kit_from_warehouse()  # zipper bag
    ensure_usb_cable_connected_right()  # HOST_PC 에서 EVM(origin)로 ACCESS      # without_usb_hub
    ensure_lan_cable_connected_right()  # HOST_PC 에서 EVM(origin) LAN6(하단케이스에 적힌) 포트에

    if 'no' in vpc_identifier:

        pass
    elif 'nx' in vpc_identifier:
        pass
    elif 'xc' in vpc_identifier:
        pass
    elif 'evm' in vpc_identifier:
        pass
    else:
        pk_print(f'''unknown vpc_identifier ({vpc_data.vpc_identifier}) {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        raise


def locate_dip_switchitch_on_board_to_left_down():
    # if no:
    #     left_down # 위치 재확인필요
    #     #         2개 스위치 제외(A/B selector, S/W 5) # 위치 재확인필요
    todo('%%%FOO%%%')


def ensure_dip_switch_position_right(vpc_data):
    from pkg_py.pk_colorful_cli_util import pk_print

    vpc_identifier = vpc_data.vpc_identifier
    if 'no' in vpc_identifier:
        locate_dip_switchitch_on_board_to_left_down()
    elif 'nx' in vpc_identifier:
        pass
    elif 'xc' in vpc_identifier:
        pass
    elif 'evm' in vpc_identifier:
        pass
    else:
        pk_print(f'''unknown vpc_identifier ({vpc_identifier}) {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        raise


def ensure_wsl_flash_directory_flashable(vpc_data):
    from pkg_py.pk_colorful_cli_util import pk_print
    if 'no' in vpc_data.vpc_identifier:
        cmd_to_remote_os("mkdir -p ~/Downloads/flash/no_flash/")
    elif 'nx' in vpc_data.vpc_identifier:
        cmd_to_remote_os("mkdir -p ~/Downloads/flash/nx_flash/")
    elif 'xc' in vpc_data.vpc_identifier:
        cmd_to_remote_os("mkdir -p ~/Downloads/flash/xc_flash/")
    elif 'evm' in vpc_data.vpc_identifier:
        cmd_to_remote_os("mkdir -p ~/Downloads/flash/evm_flash/")
    else:
        pk_print(f'''unknown vpc_data.identifier ({vpc_data.vpc_identifier}) {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        raise


def is_module_flashed_by_mtc():
    pass


def ensure_vpc_nvidia_sdk_components_intalled(vpc_data):
    from pkg_py.pk_colorful_cli_util import pk_print
    if vpc_data.vpc_with_flash_image == 0:
        # jetpack sdk component install 창 자동시현
        if 'no' in vpc_data.vpc_identifier:
            cmd_to_remote_os("sdkmanager --archived-versions")  # wsl 에서 수행
            pass
        elif 'nx' in vpc_data.vpc_identifier:
            pass
        elif 'xc' in vpc_data.vpc_identifier:
            pass
        elif 'evm' in vpc_data.vpc_identifier:
            # sdkmanager
            # show all versions
            # JETPACK 4.6.5
            # Download now. install Later 미체크  #체크 시 플래시imageCREATE 안함 #다음에는 체크해보자 불필요하게 size이 늘거 같은 생각이 든다. 왜냐면 초창기 img  f 은 회사에서는 필요없기 때문
            # APT repository access for Debian package installation(host). 에러발생
            # Skip Check
            # nvidia/nvidia/Flash
            # installation failed
            # retry # reflash
            # #팀Laptop 4.6.5 로 flash 해도 4.6.6 이 INSTALLATION_가 됨.
            pass
        else:
            pk_print(f'''unknown vpc_data.identifier ({vpc_data.vpc_identifier}) {'%%%FOO%%%' if LTA else ''}''', print_color='red')
            raise
    elif vpc_data.vpc_with_flash_image == 1:
        pass


def ensure_module_location():
    # if not found python module location:
    # pip install -e .
    todo('%%%FOO%%%')


def ensure_jetpack_via_sdkmanager(config_remote_os):  # sdkmanager cil 활용해서 가능하면 자동화.
    # cmd_to_remote_os(jetpack version)
    todo('%%%FOO%%%')


def is_aifw_running():
    # cmd_to_remote_os(jetpack version)
    todo('%%%FOO%%%')


def remove_vpc_aifw(vpc_data, config_remote_os):
    if vpc_data.vpc_type == 'no':
        # remote os 가 docker 여도 가능한지 모르겠다.
        # * 넣을지 말지 판단필요
        cmd_to_remote_os(cmd='rm -rf ~/Workspace/ai_framework*', **config_remote_os)


def cmd_to_docker_container(cmd):
    # cmd_to_remote_os(cmd='rm -rf ~/Workspace/ai_framework*', **config_remote_os) 로 먼저 가능성 확인해봐야함
    # local의 container 가 아닌 remote 의 container 를 제어 해야함.
    # ssh 로 local 에서 remote 를 접속이 가능한 상태를 확신하고 진행
    pass


def is_aifw_docker_container_running():
    pass


def ensure_aifw_running(vpc_data, config_remote_os):
    if vpc_data.vpc_type == 'no':
        while 1:
            if not is_aifw_docker_container_running():
                run_vpc_aifw_docker_container(vpc_data, config_remote_os)
                if is_aifw_docker_container_running():
                    break
    elif vpc_data.vpc_type == 'nx':
        # cd ~/works/ai_framework/bin
        # ./a2z_component_front_launcher cfg_pack_merge_front.cfg
        # ./a2z_component_merge_launcher cfg_pack_merge_front.cfg
        pass
    elif vpc_data.vpc_type == 'xc':
        # exec ai_framework
        # vscode/Remote Explorer/SSH/192.168.2.114/~/works/ai_framework/bin
        # vscode/Remote Explorer/SSH/192.168.2.114/~/works/ai_framework/bin ./a2z_component_front_launcher cfg_pack_merge_front.cfg
        # vscode/Remote Explorer/SSH/192.168.2.114/~/works/ai_framework/bin ./a2z_component_merge_launcher cfg_pack_merge_front.cfg
        pass


def ensure_vpc_aifw_running(vpc_data, config_remote_os):
    remove_vpc_aifw(vpc_data, config_remote_os)
    # 노션/AI_Framework 2 도커 환경 셋업  # apply target :NX , NO
    # run_container 레포 같은데
    download_vpc_aifw_docker_image(vpc_data, config_remote_os)
    ensure_vpc_config_right(vpc_data, config_remote_os)
    run_vpc_aifw_docker_container(vpc_data, config_remote_os)
    download_aifw(vpc_data, config_remote_os)
    build_aifw(vpc_data, config_remote_os)
    # exit_docker_container() ?
    ensure_aifw_running(vpc_data, config_remote_os)  # ?


def run_vpc_aifw_docker_container(vpc_data, config_remote_os):
    if vpc_data.vpc_type == 'no':
        config_remote_os(cmd='sudo run_container -b', **config_remote_os)


def download_vpc_aifw_docker_image(vpc_data, config_remote_os):
    if vpc_data.vpc_type == 'no':
        todo('%%%FOO%%%')


def ensure_vpc_config_right(vpc_data, config_remote_os):
    if vpc_data.vpc_type == 'no':
        # ensure_vpc_config_py_debug_true
        # config.py 에서 마지막 10줄을 가져오고, 그 아래에서 특정항목의 debug=True를 설정확인
        # run_container -b 옵션으로 container에 접속이 가능
        todo('%%%FOO%%%')
    if vpc_data.vpc_type == 'nx':
        # ai_framework config custom
        # vi ~/works/remote_release/cam_merge_f.cfg
        # vi cam_merge_f.cfg
        # vi cam_merge_lf.cfg
        # vi cam_merge_rf.cfg
        # vi cfg_pack_merge_front.cfg
        # vi env_merge_front.cfg
        todo('%%%FOO%%%')
    if vpc_data.vpc_type == 'xc':
        # 192.168.2.114/~/works/ai_framework/config/env_f.cfg
        # 192.168.2.114/~/works/ai_framework/config/env_lf.cfg
        # 192.168.2.114/~/works/ai_framework/config/env_rf.cfg

        todo('%%%FOO%%%')


def download_aifw(vpc_data, config_remote_os):
    if vpc_data.vpc_type == 'no':
        # 도커 컨테이너 내부의 특정경로에서 git clone 해야함, 도커내부에 명령어를 수행해야함. cmd_to_remote_os 로 docker container 제어 가능한지 확인이 필요.
        cmd_to_docker_container(cmd='mkdir -p ~/Workspace/ai_framwork/build')
        # cd ~/Workspace
        # git clone http://192.168.1.39:8090/ai_framework -b {aifw_branch_n}?
    elif vpc_data.vpc_type == 'nx':
        cmd_to_docker_container(cmd='mkdir -p ~/works/')
        # cd ~/works/
        # # git clone http://192.168.1.39:8090/ai_dept/ai_framework
        # git clone http://211.171.108.170:8003/ai_dept/ai_framework


def build_aifw(vpc_data, config_remote_os):
    if vpc_data.vpc_type == 'no':
        # 도커 컨테이너 내부의 특정경로에서 build 해야함, 도커내부에 명령어를 수행해야함. cmd_to_remote_os 로 docker container 제어 가능한지 확인이 필요.
        d_packing_mode = vpc_data.vpc_aifw_packing_mode
        aifw_branch_n = vpc_data.vpc_aifw_branch_n  # 이 거 build 에서만 필요한 거 같은데
        if d_packing_mode == 1:
            # a2z내부개발용 # without packing mode
            # cd ~/Workspace/ai_framwork/build
            # cmake .. -DPACKING=1     # DPACKING = 0 이면  PACKING ? 확인필요
            todo('%%%FOO%%%')
        elif d_packing_mode == 0:
            # a2z외부차량탑재용 # with packing mode
            todo('%%%FOO%%%')
    elif vpc_data.vpc_type == 'nx':
        # cd ~/works/ai_framework/build
        # cmake --version
        # sudo apt-get install cmake
        # wget https://cmake.org/files/v3.16/cmake-3.16.3.tar.gz
        # tar -xvf cmake-3.16.3.tar.gz
        # cmake ..
        # make -j8  # 8 은 코어의 수 참조
        todo('%%%FOO%%%')
    elif vpc_data.vpc_type == 'xc':
        # build ai_framework
        # vscode/Remote Explorer/SSH/192.168.2.114/~/works/ai_framework/build
        # vscode/Remote Explorer/SSH/192.168.2.114/~/works/ai_framework/build make -j8
        todo('%%%FOO%%%')


def exec_jetson_up():
    todo('%%%FOO%%%')
    # ./install.py
    # ./install.py


def download_jetson_setup():
    todo('%%%FOO%%%')


def ensure_jetson_setup():
    download_jetson_setup()
    exec_jetson_up()


def ensure_remote_os_connection(**config_remote_os):
    ip = config_remote_os['ip']
    while 1:
        if not ping(ip=ip):
            todo('%%%FOO%%%')
            continue
        if ping(ip=ip):
            break


def ensure_screen_black_never():
    todo('%%%FOO%%%')


def reboot_vpc(**config_remote_os):
    from pkg_py.pk_colorful_cli_util import pk_print
    # stdout, stderr = cmd_to_remote_os(cmd = "sudo reboot",**config_remote_os)
    stdout, stderr = cmd_to_remote_os(cmd="sudo shutdown -r now", **config_remote_os)
    ip = config_remote_os['ip']
    while 1:
        if not ping(ip):
            pk_print(f'''ping ({ip}) {'%%%FOO%%%' if LTA else ''}''', print_color='green')
            return
        pk_sleep(milliseconds=20)


def ensure_maxn():
    todo('%%%FOO%%%')


def get_vpc_issue_code(vpc_issue_code=None):
    from pkg_py.pk_colorful_cli_util import pk_print
    if not vpc_issue_code:
        pk_print(f'''등록된 모든 테스트를 진행합니다. {'%%%FOO%%%' if LTA else ''}''')
    else:
        pk_print(f'''vpc_issue_code 에 대한 특정 테스트를 진행했습니다. {'%%%FOO%%%' if LTA else ''}''')


def solve_issue(issue_code):
    pass


def remove_issue_code():
    from pkg_py.pk_colorful_cli_util import pk_print
    pk_print(f'''issu_code is removed {'%%%FOO%%%' if LTA else ''}''')


def report_vpc_test_report(issue_code, solution_code):
    # issue discovered
    pass


def exec_vpc_doctor(vpc_issue_code):
    from pkg_py.pk_colorful_cli_util import pk_print
    # todo 3 번 재시도 후, loop out,   pk_print(f'''solution_code를 3번 해결하려고 했으나  issue_code를 해결할 수 없었습니다. {'%%%FOO%%%' if LTA else ''}''')
    solution_code = None
    while 1:
        report_vpc_issue_discovered()
        if vpc_issue_code:
            solution_code = get_solution_code_from_map_issue_and_solution_code()
            if solution_code:
                solve_issue(solution_code)
                vpc_issue_code = get_vpc_issue_code(vpc_issue_code)
                if not vpc_issue_code:
                    pk_print(f'''issue_code is solved {'%%%FOO%%%' if LTA else ''}''', print_color='green')
                    remove_issue_code()
                    break
            elif not solution_code:
                pk_print(f'''solution_code is not found {'%%%FOO%%%' if LTA else ''}''', print_color='red')
            continue
    report_vpc_test_report(vpc_issue_code, solution_code)


def report_vpc_issue_discovered():
    from pkg_py.pk_colorful_cli_util import pk_print
    pk_print(f'''vpc issue is discovered {'%%%FOO%%%' if LTA else ''}''', print_color='red')


def save_vpc_issue_code(issue_code):
    from pkg_py.pk_colorful_cli_util import pk_print
    pk_print(f'''issu_code is saved {'%%%FOO%%%' if LTA else ''}''')


def get_solution_code_from_map_issue_and_solution_code():
    pass


def ensure_vpc_issue_clear():
    from pkg_py.pk_colorful_cli_util import pk_print
    vpc_issue_code = get_vpc_issue_code()
    if vpc_issue_code:
        pk_print(f'''vpc_issue_code={vpc_issue_code} {'%%%FOO%%%' if LTA else ''}''')
        save_vpc_issue_code(vpc_issue_code)
        exec_vpc_doctor(vpc_issue_code)  # run solution function about solution code


def assist_to_ensure_vpc_bit(bit_mode):
    from pkg_py.pk_colorful_cli_util import pk_print

    # 개요 : vpc 트래킹 시스템, 이슈발생 vpc 이슈트래킹시스템 필요.
    # BIT # Built in Test
    # P BIT # non-continuous : pilot or maintenance
    # C BIT # continuous     : os
    # 프로그램 대기능 정의 : vpc 테스트/이슈레포팅/해결 자동시스템
    # 프로그램명 : oo.py
    # 프로그램 설치위치 : vpc/도커/oo.py or IT/도커/oo.py
    # 개발순서 : P BIT > C BIT

    if not LTA:
        if not is_internet_connected():
            pk_print(f'''인터넷이 연결되어야 vpc bit 가 진행이 가능합니다. {'%%%FOO%%%' if LTA else ''}''', print_color='red')

    # ensure ping to acu_it # [acu_it] from toml

    # ensure ping to vpc side a # [vpc side a] from toml

    # ensure ping to vpc side b # [vpc side b] from toml

    state_c_bit_activated = 1
    if bit_mode == "p":
        state_c_bit_activated = 0
    if bit_mode == "c":
        state_c_bit_activated = 1
    while 1:
        pk_print(f'''bit_mode={bit_mode} {'%%%FOO%%%' if LTA else ''}''')
        if ensure_vpc_issue_clear():
            pass
        if state_c_bit_activated == 0:
            break
        pk_sleep(milliseconds=1000)


def ensure_power_saving_mode_diasble():
    pass


def ensure_wsl_sdkmanager(config_remote_os):
    # _______________________________________________________________________
    from pkg_py.pk_core_constants import D_DOWNLOADS
    # [how] nvidia sdkmanager download.
    # nvidia developer login.
    # click button ".deb Ubuntu" # sdkmanager_2.2.0-12028_amd64.deb downloaded at 250331

    # wsl 에서 수행
    # ensure_general_ubuntu_pkg(ubuntu_pkg_n='sdkmanager', **config_remote_os) #
    cmd_to_remote_os(cmd='sudo apt update', **config_remote_os)
    cmd_to_remote_os(cmd='sudo apt --fix-broken install', **config_remote_os)
    # mv "/mnt/c/Autonomousa2z/Downloads/pk_working/sdkmanager_2.2.0-12028_amd64.deb" "."
    # explorer.exe .
    f_nx = 'sdkmanager_2.2.0-12028_amd64.deb'
    cmd_to_remote_os(cmd='mkdir -p ~/Downloads/pk_working', **config_remote_os)
    upload_pnx_to_remote_os(local_pnx_src=f'{D_DOWNLOADS}/pk_working/{f_nx}', remote_pnx_dst=f'~/Downloads/pk_working/{f_nx}', **config_remote_os)
    cmd_to_remote_os(cmd=f'sudo dpkg -i ~/Downloads/pk_working/{f_nx}', **config_remote_os)  # todo sdkmanager cli 로 업그레이드 시도


def ensure_vpc_ubuntu_pkg_installed(vpc_data, config_remote_os):
    # todo 1개씩 나눠서 설치 후 설치여부 재확인    # wsl 환경에 설치
    cmd_to_remote_os(cmd='sudo apt install -y libxml2-utils', **config_remote_os)
    cmd_to_remote_os(cmd='sudo apt install -y simg2img', **config_remote_os)  # 설치 실패
    # Package simg2img is not available, but is referred to by another package.
    # This may mean that the package is missing, has been obsoleted, or
    # is only available from another source
    # However the following packages replace it:
    #   android-sdk-libsparse-utils
    #
    # E: Package 'simg2img' has no installation candidate
    cmd_to_remote_os(cmd='sudo apt install -y abootimg liblz4-tool binutils', **config_remote_os)
    if 'no' in vpc_data.vpc_identifier:
        pass
    if 'nx' in vpc_data.vpc_identifier:
        pass


def ensure_hardware_right(vpc_data):
    from pkg_py.pk_colorful_cli_util import pk_print

    ensure_wiring_pysical_right(vpc_data)
    ensure_dip_switch_position_right(vpc_data)

    if 'no' in vpc_data.vpc_identifier:
        pass
    elif 'nx' in vpc_data.vpc_identifier:
        pk_print(f'''케이스 조립 전 종단저항 12개 remove{'%%%FOO%%%' if LTA else ''}''')
    elif 'xc' in vpc_data.vpc_identifier:
        pk_print(f'''XC 메인보드에 특이사항 저항 없으면 출고불가능 처리{'%%%FOO%%%' if LTA else ''}''')
    elif 'evm' in vpc_data.vpc_identifier:
        pk_print(f'''evm/메인보드/SD 카드 remove {'%%%FOO%%%' if LTA else ''}''')
        pk_print(f'''evm/메인보드/2핀점퍼 remove {'%%%FOO%%%' if LTA else ''}''')


def ensure_vpc_bsp_installed(vpc_data, config_remote_os):
    from pkg_py.pk_colorful_cli_util import pk_print
    if 'no' in vpc_data.vpc_identifier:
        #  \\a2z_AINas_2\30_VISION_DEV\ACU_NO\90_received\20250325 ACU_NO 최종 제출 자료 2차\몹티콘-ACUNO 최종결과물\몹티콘-ACUNO 최종결과물\5.SW 자료\01.BSP\BSP_250312.tar.bz2
        if not is_module_flashed_by_mtc():
            # mtc 모듈은 flash 되어 들어와서 bsp flash 이미지를 tar
            # LINUX_for_Tegra 의 상위 폴더 에서 sudo 붙여서 BSP 압축해제 # 꽤 걸림
            cmd_to_remote_os("cd ~/working_directory_for_flash", config_remote_os)
            # cmd_to_remote_os("sudo tar -xvf BSP20240305.tar", config_remote_os)  # BSP20240305.tar 는 초기버전.
            cmd_to_remote_os("sudo tar -jxvf Flash_Image_Release_1.3.0.tar.bz2 ", config_remote_os)  # a2z 40 nas/30_VISION_DEV/ACU_NX/20_flash/의 최신디렉토리의 파일을 받아야함.
            # tar 인 경우: -j remove->-xvf
        pass
    elif 'nx' in vpc_data.vpc_identifier:
        pass
    elif 'xc' in vpc_data.vpc_identifier:
        pass
    elif 'evm' in vpc_data.vpc_identifier:
        # Driver Package (BSP) DOWNLOAD
        # sudo mv "/mnt/c/Users/user/Downloads/Jetson_LINUX_R32.7.5_aarch64.tbz2" /Downloads/flash/EVM_flash/
        # sudo tar -jxvf /Downloads/flash/EVM_flash/Jetson_LINUX_R32.7.5_aarch64.tbz2 #압축해제
        # sudo find -type f -name "Jetson_LINUX_R32.7.5_aarch64.tbz2"

        # ensure existance JETSON_LINUX_R32.7.5_AARCH64.TBZ2
        #    explorer https://developer.nvidia.com/jetpack-sdk-465  # jetpack 4.6.5 Driver for Jetson AGX Xavier
        #    sudo mv /mnt/c/Users/user/Downloads/Tegra_LINUX_Sample-Root-Filesystem_R32.7.5_aarch64.tbz2 /Downloads/flash/EVM_flash/LINUX_for_Tegra/rootfs

        # ensure tar
        # sudo tar -jxvf /Downloads/flash/EVM_flash/LINUX_for_Tegra/rootfs/Tegra_LINUX_Sample-Root-Filesystem_R32.7.5_aarch64.tbz2 #압축해제
        # sudo find -type f -name "Tegra_LINUX_Sample-Root-Filesystem_R32.7.5_aarch64.tbz2"
        pass
    else:
        pk_print(f'''unknown vpc_data.identifier ({vpc_data.vpc_identifier}) {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        raise


def ensure_vpc_flash_image_saved():
    # flash image를 만들때 특정 192.168.2.114/22 로 eth0(Wired connection 1 and 3) 로 셋업을 해둬서 XC를 headless 모드로 셋팅(화면 볼필요 없이, ssh로 바로 접속)

    # if xc:
    #     jetpack_version
    # # todo : flash image 생성
    # #  추후에 4.6.6 이 필요하다면, flash image 새로생성하자
    # #  영상처리제어기 headless 로 flash 를 위한 선행작업,
    # #  꼭 ip를 미리 192.168.10.114 로 셋팅을 해두자. headless 로 flash 를 하기 위해서

    # EVM_flash_241125.img
    # EVM_flash_241125.img.raw
    # cp EVM_flash_241125.img ~/Download
    # scp EVM_flash_241125.img park4139@x.x.x.x:/home/pk_system/    # send to galaxybook4_junghoonpark

    # to local
    # to nas
    # to nas
    pass


def ensure_vpc_os_poweroff():
    pass


def ensure_vpc_report_about_vpc_basic_setup():
    # todo : with_flash_image 가 False 일 때는 정상동작 확인필요.
    # todo : setup 레포트가 작성
    pass


def ensure_auto_reboot_test():
    # EVM
    # poweroff
    # disconnect power
    # connect 2pin jumper #EVM의 경우, J#xx 점퍼로 전원인가를 자동화
    # connect power
    pass


def ensure_vpc_network_eh0_connected():
    # EVM terminal x
    # nmcli d | grep eth0 # check connection number of eth0
    # nm-connection-editor
    # conect to 114
    # ping google.com
    pass


def check_latest_aifw_version_and_get_version_seleted(vpc_identifier, aifw_version):
    return aifw_version  # code for temp

    vpc_identifier = vpc_identifier.strip()
    vpc_identifier = vpc_identifier.lower()
    if 'no' in vpc_identifier:
        # todo gitlab 에서 latest 파싱하도록 후 vpc_aifw_version 와 비교, 같으면 진행, 다르면 질의(latest 는 몇입니다. 업데이트 할까요?)
        pass
    elif 'nx' in vpc_identifier:
        pass
    elif 'xc' in vpc_identifier:
        pass
    elif 'evm' in vpc_identifier:
        pass
    else:
        pk_print(f'''unknown vpc_identifier ({vpc_identifier}) {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        raise
    if LTA:
        pk_print(f'''aifw_version={aifw_version} {'%%%FOO%%%' if LTA else ''}''')
    return aifw_version


def check_latest_jetpack_version_and_get_version_seleted(vpc_identifier, jetpack_version):
    return jetpack_version  # code for temp

    vpc_identifier = vpc_identifier.strip()
    vpc_identifier = vpc_identifier.lower()
    if 'no' in vpc_identifier:
        # todo gitlab 에서 latest 파싱하도록 후 vpc_aifw_version 와 비교, 같으면 진행, 다르면 질의(latest 는 몇입니다. 업데이트 할까요?)
        jetpack_version = "5.1.2"
    elif 'nx' in vpc_identifier:
        jetpack_version = "5.0.2"
    elif 'xc' in vpc_identifier:
        jetpack_version = "4.6.5"
    elif 'evm' in vpc_identifier:
        jetpack_version = "4.6.6"
    else:
        pk_print(f'''unknown vpc_identifier ({vpc_identifier}) {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        raise
    if LTA:
        pk_print(f'''jetpack_version={jetpack_version} {'%%%FOO%%%' if LTA else ''}''')
    return jetpack_version


def get_vpc_identifier_matched_from_vpc_db(vpc_nvidia_serial, vpc_side_mode):
    # todo : vpc_db.sqlite or vpc_db.pickle or vpc_db._toml 에서 가져오도록
    from pkg_py.pk_core_constants import F_VPC_MAMNAGEMENT_MAP_TOML
    f = F_VPC_MAMNAGEMENT_MAP_TOML
    if vpc_identifier:
        return vpc_identifier


@pk_measure_seconds
def ensure_vpc_flashed(wsl_data, vpc_data, config_remote_os):
    import time
    from pkg_py.pk_colorful_cli_util import pk_print
    # pk_print(str_working=rf'''flash 를 진행하기 위해서 불필요한 창들을 끕니다  {'%%%FOO%%%' if LTA else ''}''', print_color='blue')
    # answer = input(rf"{get_stamp_func_n(func_n=func_n)} >")
    # cmd_to_os(cmd=rf'taskkill /f /im "cmd.exe" ', debug_mode=False)
    # process_kill_wsl_exe(debug_mode=False)
    # process_kill_cmd_exe(debug_mode=False)
    # process_kill_powershell_exe(debug_mode=False)

    wsl_window_title_seg = f"{wsl_data.vpc_user_n}@{wsl_data.HOSTNAME}"
    pk_print(str_working=rf'''wsl_window_title_seg="{wsl_window_title_seg}"  {'%%%FOO%%%' if LTA else ''}''')

    # sudo find -type f -name "flash.sh"
    # sudo find . -type f -name "flash.sh" # f 찾기 #재귀적으로

    if 'no' in vpc_data.vpc_identifier:
        with_flash_image = vpc_data.vpc_with_flash_image
        if vpc_with_flash_image == 0:
            cmd_to_remote_os(cmd='sdkmanager', **config_remote_os)  # excute sdkmanager    # todo sdkmanager cli 로 업그레이드 시도

            ensure_remote_os_connection(**config_remote_os)  # test_ip

            ensure_vpc_jetpack(**config_remote_os)

            ensure_jetson_setup()

            ensure_remote_os_connection(**config_remote_os)  # test_ip

            ensure_power_saving_mode_diasble()
            ensure_screen_black_never()
            ensure_maxn()
            reboot_vpc()

        if vpc_with_flash_image == 1:
            ensure_remote_os_connection(**config_remote_os)

        ensure_vpc_aifw_running(vpc_data, config_remote_os)  # todo
    elif 'nx' in vpc_data.vpc_identifier:
        pass
    elif 'xc' in vpc_data.vpc_identifier:
        while 1:
            # todo : reference : XC도 4.6.6 고정되고 나면 플래시 이미지로만 관리
            if vpc_with_flash_image == 0:
                cmd_to_wsl_os_like_person_deprecated(cmd=rf"echo {pw} | sudo -S ./flash.sh -r jetson-xavier mmcblk0p1", remote_os_distro_n=wsl_distro_n, wsl_window_title_seg=wsl_window_title_seg)

                # vpc 추가설정
                #  ntp
                #  stacksize

                gen_vpc_flash_image()

            elif vpc_with_flash_image == 1:
                # cd
                # cmd = "cd ~/Downloads/flash/xc_flash/Linux_for_Tegra/"
                # cmd_to_wsl_os_like_person_deprecated(cmd=cmd, remote_os_distro_n=vpc_os_n, wsl_window_title_seg=wsl_window_title_seg, exit_mode=exit_mode)

                # ensure system.img* and system.img.raw
                ensure_location_about_system_img_and_system_img_raw(**config_remote_os)

                # flash
                cmd = rf"echo {pw} | sudo -S ./flash.sh -r jetson-xavier mmcblk0p1"
                cmd_to_wsl_os_like_person_deprecated(cmd=cmd, remote_os_distro_n=wsl_distro_n, wsl_window_title_seg=wsl_window_title_seg)

                # sudo mv /home/pk_system/Downloads/flash/xc_flash/Linux_for_Tegra/system.img* /home/pk_system/Downloads/flash/xc_flash/Linux_for_Tegra/rootfs/bin/

                # cmd = rf'sudo find -type f -name "system.img*"'
                # cmd_to_wsl_like_person(cmd=cmd, remote_os_distro_n=remote_os_distro_n, wsl_window_title_seg=wsl_window_title_seg)
                #
                # cmd = rf'df -h'
                # cmd_to_wsl_like_person(cmd=cmd, remote_os_distro_n=remote_os_distro_n, wsl_window_title_seg=wsl_window_title_seg)
                #
                # cmd = rf'explorer \\wsl$'
                # cmd_to_os(cmd=cmd)

                time_s_local = time.localtime(time_s)
                check_manual_task_iteractively(f'''The flash has Started at {time_s_local.tm_hour:02}:{time_s_local.tm_min:02}. Has the flash ended?''')

                elapsed_seconds = time.time() - time_s
                elapsed_minutes = elapsed_seconds / 60

                pk_print(str_working=rf'''FLASH : This function took {elapsed_minutes} minutes  {'%%%FOO%%%' if LTA else ''}''', print_color="green")
                # todo : elapsed_minutes 이걸 f에 매번 기록, 공정시간 자동통계
                # 해당공정이 통계시간보다 느리거나 빠르게 종료되었다는 것을 출력 하도록

            check_manual_task_iteractively(question=rf'''DID YOU EXIT WSL FLASH PROGRAM AT LOCAL?  %%%FOO%%%''')
            check_manual_task_iteractively(question=rf'''DID YOU EXIT WSL ATTACH PROGRAM AT LOCAL?  %%%FOO%%%''')
            # todo : 플래시이미지 재생성 후 해당 내용 네트워크 설정 자동화 후 추후삭제예정
            check_manual_task_iteractively(question=rf'''DID YOU SET WIRED CONNECTION 3 AS {vpc_data.vpc_wired_connection_3_new} ?  %%%FOO%%%''')
            ensure_vpc_side_mode(vpc_data=vpc_data, **config_remote_os)
            if not ensure_vpc_accessable(vpc_data, **config_remote_os):
                # history : ensure_vpc_accessable() 수행 -> vpc 접속안됨 -> Wired Connection 활성화 실패->gui 통해서 2.76 으로 ssh 접속 시도->fail->flash 재수행->success
                # flash 재수행해야 하는 경우로 판단
                continue
    elif 'evm' in vpc_data.vpc_identifier:
        if vpc_data.vpc_with_flash_image == 0:
            cmd_to_remote_os(cmd='sdkmanager', **config_remote_os)  # excute sdkmanager    # todo sdkmanager cli 로 업그레이드 시도
            # sdkmanager    #  sdkmanager --archived-versions 이거 아님. # 안될때 sudo sdkmanager 로그인 했다가 종료하고 sdkmanager 로 다시 접속
            # cmd_run_via_wsl(wsl_cmd=wsl_cmd, remote_os_distro_n=remote_os_distro_n, window_title_seg=wsl_windows_title_seg)

            # WSL 에서 실행중인데 cmd  를 관리자 권한으로 실행하고 WSL 을 실행해서 sdkmanger 실행했는데 여전히 You do not have permission to access the download folder. 나와
            # download 폴더를 변경 create and select pk_download   -> ~/Downloads/pk_nvidia ->   flash/evm_flash

            # nvidia developer login
            # 로그인웹이 자동으로 안열리는 경우, 재부팅부터 해보자, QR code 로 시도
            # smart phone 에서 QR 촬영을 해서 smart phone web 열리면 로그인
            # 다른거 치라는데 패스워드 치면 됨.
            # 로그인 되면서 device type select 창이 나옴.
            # Jetson AGX Xavier
            # OK
            # Later

            # show all versions
            # 4.6.6
            # [fail] ensure only os without nvidia sdk component
            # ensure both os and nvidia sdk component
            # continue
            # ensure download now. install later. disable # 이거 체크하면 flash 진행하지 않음
            # ensure I accpet the terms and conditions of the license agreements. able
            # continue
            # manual flash try, # 안해도 될 듯 download now. install later. able 처리해서 발생한 문제
            # wait for OEM Configuration setting pop up
            # Runtime # OEM Configuration # 자꾸 안되서 Runtime 안하고 pre-config 로 해봄 pre-config는 default 임
            # Flash
            # finish

            # [fail] ensure ubuntu OEM : in evm
            # evm
            # EVM terminal x
            # accept blah lisence
            # display on
            # agree
            # english
            # english(US)
            # english(US)
            # seoul
            # nvidia
            # nvidia
            # nvidia
            # nvidia
            # nvidia
            # MAXN
            # log in automatically
            # Install # if this process fail, retry flash

            # set evm network wired connection 1 as 192.168.2.124 22 192.168.1.1 8.8.8.8 manualy in evm
            # sudo apt update in evm
            # skip check
            # pkill sdkmanger-gui
            # sdkmanger
            # ensure only nvidia sdk component without os(jetpack)
            # Ethernet
            # 192.168.2.124
            # nvidia
            # nvidia
            # install

            # ensure log in automatically

            # ensure MAXN

            # ensure no passwd

            # ensure stack size 10240 #MEMORY LEAK 예방 #10240로 합의
            # sudo vi /etc/security/limits.conf
            # #End of file
            # nvidia hard stack 10240
            # nvidia soft stack 10240
            # ubuntu hard stack 10240
            # ubuntu soft stack 10240
            # root hard stack 10240
            # root soft stack 10240
            # :wq
            # cat /etc/security/limits.conf

            # ensure ntp available
            # sudo vi /etc/systemd/timesyncd.conf
            # [Time]
            # NTP=192.168.10.10 #server ip(control PC)
            # FallbackNTP=ntp.ubuntu.com
            # RootDistanceMaxSec=15 #5→15
            # PollIntervalMinSec=32
            # PollIntervalMaxSec=2048
            # # timedatectl set-ntp no #자동 시간동기화 해제
            # # date
            # # timedatectl set-time "2024-10-28 13:26:00" #수동 시간 SETTING

            # ensure auto reboot

            # make flash image # started at 15:18
            # recovery mode again
            # sudo find /home -type f -name "flash.sh"
            # evm_flash_jetpack_4_6_6_ready.img 는 ip124,  ntp, stack, ensure 함.
            # evm_flash_jetpack_4_6_6_with_side_a.img
            # evm_flash_jetpack_4_6_6_with_side_b.img
            # sudo ./flash.sh -r -k APP -G evm_flash_jetpack_4_6_6_ready.img jetson-xavier mmcblk0p1
            # sudo ./flash.sh -r -k APP -G evm_flash_jetpack_4_6_6_with_side_a.img jetson-xavier mmcblk0p1
            # sudo ./flash.sh -r -k APP -G evm_flash_jetpack_4_6_6_with_side_b.img jetson-xavier mmcblk0p1
            # sudo find /home -type f -name "evm_flash_jetpack_4_6_6*"
            # ended at mkr.
            pass
        elif vpc_data.vpc_with_flash_image == 1:
            # sudo ./flash.sh -r -k APP -G EVM_flash_241125.img jetson-xavier mmcblk0p1
            pass
    else:
        pk_print(f'''unknown vpc_data.identifier ({vpc_data.vpc_identifier}) {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        raise


def ensure_vpc_ready(vpc_data, wsl_data, **config_remote_os):
    if not LTA:
        ensure_hardware_right(vpc_data)

    wsl_distro_n = wsl_data.vpc_os_distro_n
    vpc_type = vpc_data.vpc_type
    with_flash_image = vpc_data.vpc_with_flash_image

    ensure_wsl_flash_directory_flashable(vpc_data)
    ensure_wsl_sdkmanager(config_remote_os)

    ensure_vpc_ubuntu_pkg_installed(vpc_data, config_remote_os)
    ensure_vpc_bsp_installed(vpc_data, config_remote_os)
    ensure_vpc_recovery_mode_entered(vpc_data, wsl_data, config_remote_os)

    ensure_vpc_flashed(vpc_data, config_remote_os)

    ensure_vpc_network_eh0_connected()  # 114

    ensure_vpc_nvidia_sdk_components_intalled(vpc_data)

    ensure_vpc_smoke_test(vpc_data)

    ensure_vpc_flash_image_saved()

    save_vpc_tracking_map_with_nvidia_serial_to_vpc_mamnagement_map_toml(vpc_data)

    ensure_vpc_report_about_vpc_basic_setup()

    ensure_vpc_os_poweroff()


def get_wsl_data_raw_data(vpc_data_raw):
    import os
    from pkg_py.pk_core_constants import D_HOME
    from pkg_py.pk_core_class import A2zCarDataStructure
    wsl_data_raw = A2zCarDataStructure.RemoteDeviceDataStructure()
    # if not is_wsl_distro_installed(wsl_distro_n=PK_WSL_DISTRO_N):
    #     ensure_wsl_distro_installed(wsl_distro_n='Ubuntu-24.04')
    #     mkr.

    wsl_data_raw.vpc_os_distro_n = get_vpc_wsl_distro_n(vpc_data_raw.vpc_type)
    wsl_distro_n = wsl_data_raw.vpc_os_distro_n
    wsl_data_raw.vpc_ip = get_wsl_ip(wsl_distro_n)
    wsl_data_raw.vpc_port = ensure_and_get_wsl_port(wsl_distro_n)
    wsl_data_raw.vpc_user_n = get_wsl_user_n(wsl_distro_n)
    wsl_data_raw.vpc_pw = get_wsl_pw(wsl_distro_n)
    wsl_data_raw.vpc_local_ssh_public_key = os.path.join(D_HOME, ".ssh", "id_ed25519.pub")
    wsl_data_raw.vpc_local_ssh_private_key = os.path.expanduser("~/.ssh/id_ed25519")
    return wsl_data_raw


@pk_measure_seconds
def assist_to_perform_to_ensure_vpc_condition():
    # todo:  request_template_raw 를 넣고 request 를 만들고 request 대로 셋팅 수행 ...하는 로직 파이프 고민필요
    from pkg_py.pk_core_class import A2zCarDataStructure
    from pkg_py.pk_core_constants import F_VPC_MAMNAGEMENT_MAP_TOML
    import inspect
    from pkg_py.pk_colorful_cli_util import pk_print
    func_n = inspect.currentframe().f_code.co_name

    if is_os_windows():
        # mkr_assist_to_perform_to_ensure_vpc_condition
        # todo guide_to_edit_vpc_config_script_and_update_toml        and        save to vpc_mamnagement_map_toml
        # todo : migrate hardcoding to get_from_toml # 현업에서는 협업을 위해서 필요.
        # 고정값은 migrate to toml and get from toml
        # 가변값은 guide
        f = F_VPC_MAMNAGEMENT_MAP_TOML

        # vpc data model orm (OBJECT RELATIONAL MAPPING)
        vpc_data_raw = get_vpc_data_raw_from_vpc_request()
        vpc_data = A2zCarDataStructure.RemoteDeviceDataStructure()
        vpc_data.set_remote_device_data_field_all(pk_structure=vpc_data_raw)
        vpc_data.print_remote_device_data_field_all(instance_name='vpc_data_defined')

        wsl_data_raw = get_wsl_data_raw_data(vpc_data_raw)
        wsl_data = A2zCarDataStructure.RemoteDeviceDataStructure()
        wsl_data.set_remote_device_data_field_all(pk_structure=wsl_data_raw)
        wsl_data.print_remote_device_data_field_all(instance_name='wsl_data')
        # [ how ] msi/wsl_ubuntu_24_04_no_flash/login.
        # msi

        ensure_wsl_distro_installed(wsl_distro_n=wsl_data.vpc_os_distro_n)
        ensure_wsl_distro_session(wsl_distro_n=wsl_data.vpc_os_distro_n)
        ensure_wsl_usb_ip_connection_established(wsl_distro_n=wsl_data.vpc_os_distro_n, config_remote_os=config_remote_os)

        if vpc_data.vpc_ip:
            if LTA:
                pk_print(f'''vpc_data.ip={vpc_data.vpc_ip} {'%%%FOO%%%' if LTA else ''}''')
            config_remote_os = {}
            config_remote_os['ip'] = vpc_data.vpc_ip
            config_remote_os['local_ssh_private_key'] = vpc_data.vpc_local_ssh_private_key
            config_remote_os['port'] = vpc_data.vpc_port
            config_remote_os['user_n'] = vpc_data.vpc_user_n

            ensure_ssh_public_key_to_remote_os(**config_remote_os)
            ensure_remote_os_as_nopasswd(**config_remote_os)

        # argument 유효성 검사
        # pk_print(f'''ooo 과 ooo 이 초기화되지 않아 {vpc_identifier} 장비를 베이직 셋업과 스모크 테스트를 진행할 수 없습니다. {'%%%FOO%%%' if LTA else ''}''')
        # pk_print(f'''ooo a2z 외부차량탑재용으로 {vpc_identifier} 장비를 베이직 셋업과 스모크 테스트를 진행하시겠습니까? {'%%%FOO%%%' if LTA else ''}''')
        print_iterable_as_vertical(item_iterable=config_remote_os)
        raise

        ensure_vpc_ready(wsl_data=wsl_data, vpc_data=vpc_data, **config_remote_os)

        assist_to_ensure_vpc_bit(bit_mode='p')

        assist_to_ensure_vpc_bit(bit_mode='c')


def get_pk_nick_name_dict():
    return {
        'nick_name': "full_name",
        'vpc': "vision process controller",
    }


def get_vpc_identifier_by_input(input_ment, vpc_type):
    from pkg_py.pk_colorful_cli_util import pk_print

    # todo 숫자 아니면 continue
    state_nick_name_passed = 0
    while 1:
        vpc_identifier_number = input(input_ment)
        vpc_identifier = f'{vpc_type}_#{vpc_identifier_number}'.lower()
        if 'no_#' or 'nx_#' or 'xc_#' or 'evm_#' in vpc_identifier:
            state_nick_name_passed = 1
        if state_nick_name_passed == 1:
            if LTA:
                pk_print(f'''vpc_identifier={vpc_identifier} {'%%%FOO%%%' if LTA else ''}''')
            return vpc_identifier


def ensure_vpc_jetpack(**config_remote_os):
    # todo

    from pkg_py.pk_colorful_cli_util import pk_print

    a, b = cmd_to_remote_os(cmd='todo', **config_remote_os)
    if 'Ubuntu' not in a:
        pk_print(f'''ubuntu is not installed({a}) {'%%%FOO%%%' if LTA else ''}''', print_color='red')
        raise


def get_dict_merged(dict_1, dict_2):
    # todo  dict + dict
    pass


def pk_print_collected_all_import_code_from_f_py(f_py):
    # collect import code from python file  
    # # # todo fix    수작업 결과보다 적었음. 잘못 로직을 만든 것 같음.
    line_imported_pkg_set = set()
    line_list = get_list_from_f(f=f_py)
    signiture1 = f'import'
    signiture2 = f'from'
    for line in line_list:
        line = line.strip()
        if line.startswith('#'):
            line = line.replace('#', "", 1)
        if line.startswith(signiture1):
            line_imported_pkg_set.add(line.strip())
        if line.startswith(signiture2):
            line_imported_pkg_set.add(line.strip())
    line_imported_pkg_set = sorted(line_imported_pkg_set, reverse=True)
    for line_imported_pkg in line_imported_pkg_set:
        print(line_imported_pkg)


def get_vpc_wsl_distro_n(vpc_type):
    from pkg_py.pk_core_constants import PK_WSL_DISTRO_N
    if not is_office_pc():
        return PK_WSL_DISTRO_N
    wsl_distro_n = None
    if vpc_type == 'no':
        wsl_distro_n = 'wsl_ubuntu_20_04_no_flash'
    if vpc_type == 'nx':
        wsl_distro_n = 'wsl_ubuntu_20_04_nx_flash_at_250416'
    if vpc_type == 'xc':
        wsl_distro_n = 'wsl_ubuntu_18_04_xc_flash_at_250416'
    if vpc_type == 'evm':
        wsl_distro_n = 'wsl_ubuntu_18_04_evm_flash'
    return wsl_distro_n


def get_extension_set_from_d(dir_path: str) -> set[str]:
    import os
    extensions = set()
    if not os.path.isdir(dir_path):
        return extensions
    for filename in os.listdir(dir_path):
        file_path = os.path.join(dir_path, filename)
        if os.path.isfile(file_path):
            _, ext = os.path.splitext(filename)
            if ext:
                extensions.add(ext)
    return extensions


def is_valid_ngram(k: str) -> bool:
    import re
    if len(k.split()) < 2:
        return False

    # 숫자 단독, (1080p), 등 무의미한 값 제외
    if re.fullmatch(r"\d+|\d{3,4}p|\(\d{3,4}p\)", k.strip()):
        return False

    # "- 12" 같은 기호+숫자 조합 제거
    if re.fullmatch(r"[-~–—]\s*\d+", k.strip()):
        return False

    # "12 (1080p)" 같은 회차 + 화질 제거
    if re.search(r"\b\d{1,2} ?\(\d{3,4}p\)", k):
        return False

    return True


def get_all_ngram_list(f_nx, max_n, token_splitter_pattern):
    import os
    import re
    f_n, _ = os.path.splitext(f_nx)
    tokens = re.split(token_splitter_pattern, f_n)
    tokens = [t for t in tokens if t]  # 빈 문자열 제거
    all_ngram_list = []

    for n in range(max_n, 0, -1):
        if len(tokens) >= n:
            ngrams = [' '.join(tokens[i:i + n]) for i in range(len(tokens) - n + 1)]
            all_ngram_list.extend(ngrams)
    return all_ngram_list


@pk_measure_seconds
def get_categorized_f_dict_by_priority_ngrams(f_list, min_support, max_n, token_splitter_pattern):
    from collections import defaultdict, Counter
    ngram_counter = Counter()
    all_ngram_set = {}

    for f in f_list:
        all_ngram_list = get_all_ngram_list(f, max_n, token_splitter_pattern)
        all_ngram_set[f] = all_ngram_list
        ngram_counter.update(all_ngram_list)

    sorted_keywords = sorted(
        [k for k, v in ngram_counter.items() if v >= min_support and is_valid_ngram(k)],
        key=lambda x: -len(x.split())
    )

    categorized = defaultdict(list)
    assigned_files = set()

    for keyword in sorted_keywords:
        for f in f_list:
            if f in assigned_files:
                continue
            if keyword in all_ngram_set[f]:
                categorized[keyword].append(f)
                assigned_files.add(f)

    for f in f_list:
        if f not in assigned_files:
            categorized["기타"].append(f)
    return dict(categorized)


def print_preview(categorized_f_dict):
    from pkg_py.pk_colorful_cli_util import pk_print
    from colorama import init as pk_colorama_init
    pk_colorama_init(autoreset=True)

    pk_print(f'''[ ngram 기반 분류결과(preview) ] {'%%%FOO%%%' if LTA else ''}''', print_color='blue')
    # f_print_mode = get_pk_input_via_tab(message='f_print_mode=', tab_completer_iterable=["o","x"])
    for group, files in categorized_f_dict.items():
        # print(f"\n\U0001F4C2 {group} = []")
        # if f_print_mode=="o":
        #     for f in files:
        #         print(f"  └─ {f}")
        # else:
        #     pass
        f_filtered = []
        for f in files:
            if len(f_filtered) < 10:
                f_filtered.append(f)
            elif len(f_filtered) == 10:
                f_filtered.append("...")
            else:
                pass
        print(f"\n\U0001F4C2 {group} = {f_filtered}")


def move_f_list_by_category(categorized, base_p="."):
    import os
    import shutil
    for category, f_nx_list in categorized.items():
        if category == "기타":
            continue
        d_n = category.replace(" ", "_")
        category_d = os.path.join(base_p, d_n)
        os.makedirs(category_d, exist_ok=True)
        for f_nx in f_nx_list:
            src = os.path.join(base_p, f_nx)
            dst = os.path.join(category_d, f_nx)
            if os.path.exists(src):
                shutil.move(src, dst)


def pk_organize_f_list_by_ngram(f_to_organize_list, d_working, token_splitter_pattern, min_support, max_n):
    categorized_f_dict = get_categorized_f_dict_by_priority_ngrams(f_to_organize_list, min_support=min_support, max_n=max_n, token_splitter_pattern=token_splitter_pattern)
    print_preview(categorized_f_dict)

    ans = pk_input_v44_uv_theme(
        working_str="위와 같이 파일을 분류할까요? (o/x):",
        limit_seconds=60,
        return_default="x",
        fuzzy_accept=[("o", "ok", "yes", "y"), ("x", "no", "n")],
        validator=lambda s: s.lower() in {"o", "x", "yes", "no", "y", "n"},
        masked=False,
    )
    ans = ans.strip()
    ans = ans.lower()
    if ans == 'o':
        move_f_list_by_category(categorized_f_dict, base_p=d_working)
        print("\n✅ 분류 완료!")
    else:
        print("\n❌ 분류를 취소했습니다.")


def pk_input_v1(working_str, limit_seconds, return_default, get_input_validated=None):
    import sys
    import threading
    import time
    from queue import Queue, Empty
    from pkg_py.pk_colorful_cli_util import pk_print  # 로깅 함수 사용 시
    pk_print(f'''working_str={working_str} {'%%%FOO%%%' if LTA else ''}''')
    pk_print(f'''limit_seconds={limit_seconds} {'%%%FOO%%%' if LTA else ''}''')
    pk_print(f'''return_default={return_default} {'%%%FOO%%%' if LTA else ''}''')
    pk_print(f'''get_input_validated={get_input_validated} {'%%%FOO%%%' if LTA else ''}''')
    input_queue = Queue()

    def read_input():
        try:
            user_input = sys.stdin.readline()
            input_queue.put(user_input.strip())
        except Exception as e:
            input_queue.put(None)

    input_thread = threading.Thread(target=read_input, daemon=True)
    input_thread.start()

    start_time = time.time()
    remaining = limit_seconds

    try:
        while remaining > 0:
            user_input = ""
            try:
                user_input = input_queue.get(timeout=1)
                print()  # 줄 바꿈
                if get_input_validated and not get_input_validated(user_input):
                    pk_print("[RETRY] 유효하지 않은 입력입니다. 다시 시도해주세요.", print_color='red')
                    return pk_input(working_str, limit_seconds, return_default, get_input_validated)
                return user_input
            except Empty:
                remaining = limit_seconds - int(time.time() - start_time)
                print(f"\r⏳ remaining seconds : {remaining:2d} {working_str}{user_input}", end="", flush=True)
        print()  # 줄 바꿈 (시간 초과 시)
        pk_print(f"[TIMEOUT] 입력 시간 초과 → 기본값 반환: {return_default}", print_color='red')
        return return_default

    except KeyboardInterrupt:
        print()  # 줄 바꿈
        pk_print("[INTERRUPT] 사용자 입력 취소됨 → 기본값 반환", print_color='red')
        return return_default


def pk_input_v22(
        working_str: str,
        limit_seconds: int = 30,
        return_default: str | None = None,
        *,
        get_input_validated=None,  # bool 반환 함수
        verbose_log: bool = True,
        masked: bool = False,
        auto_repeat: bool = False,
        fuzzy_accept: list[tuple[str, ...]] | None = None,
):
    import sys, threading, time, os, msvcrt
    from pkg_py.pk_colorful_cli_util import pk_print

    def _read_masked() -> str:
        """Windows 전용·동기. Ctrl+C→KeyboardInterrupt."""
        buf: list[str] = []
        while True:
            ch = msvcrt.getwch()
            if ch in ("\r", "\n"):
                print()
                return "".join(buf)
            if ch == "\x03":  # ^C
                raise KeyboardInterrupt
            if ch == "\x08":  # Backspace
                if buf:
                    buf.pop()
                    sys.stdout.write("\b \b")  # 지운 자리에 공백
                    sys.stdout.flush()
            else:
                buf.append(ch)
                sys.stdout.write("*" if masked else ch)
                sys.stdout.flush()

    # -------------------- 입력 스레드 --------------------
    user: dict[str, str | None] = {"value": None}

    def _input_worker():
        try:
            if masked and os.name == "nt":
                user["value"] = _read_masked()
            else:
                user["value"] = input()
        except (EOFError, KeyboardInterrupt):
            user["value"] = None

    thr = threading.Thread(target=_input_worker, daemon=True)
    thr.start()

    # -------------------- 진행바 루프 --------------------
    start = time.time()
    bar_w = 20
    max_line_len = 0  # 이전 라인의 길이를 기억해 남은 글자 덮어쓰기

    try:
        while thr.is_alive():
            elapsed = time.time() - start
            remaining = int(limit_seconds - elapsed)

            if remaining < 0:
                break

            filled = round(bar_w * remaining / limit_seconds)
            bar = "▰" * filled + "▱" * (bar_w - filled)
            bar_color = "\033[92m" if remaining > 5 else "\033[91m\033[5m"
            msg = f"⏳ {remaining:2d}s {bar_color}{bar}\033[0m {working_str} "

            # 한 줄만 쓰고 이전보다 짧으면 빈칸으로 덮어쓰기
            padding = " " * max(0, max_line_len - len(msg))
            sys.stdout.write(f"\r{msg}{padding}")
            sys.stdout.flush()
            max_line_len = max(max_line_len, len(msg))

            time.sleep(1)

            if not thr.is_alive():  # 입력 끝났으면 즉시 루프 탈출
                break

    except KeyboardInterrupt:
        if verbose_log:
            pk_print("[INTERRUPT] 사용자 입력 취소 → 기본값 반환", print_color="red")
        return return_default

    # 줄 정리
    sys.stdout.write("\r" + " " * max_line_len + "\r")
    sys.stdout.flush()

    # -------------------- 결과 처리 --------------------
    result = (user["value"] or "").strip()
    if not result:
        if verbose_log:
            pk_print(f"[TIMEOUT] 입력 없음 → 기본값 반환: {return_default}", print_color="red")
        return return_default

    # fuzzy matching
    if fuzzy_accept:
        low = result.lower()
        for group in fuzzy_accept:
            if low in group:
                result = group[0]  # canonical
                break

    # validation
    if get_input_validated and not get_input_validated(result):
        if verbose_log:
            pk_print("❌ 입력값이 유효하지 않습니다.", print_color="red")
        if auto_repeat:
            # 남은 시간만큼 재귀 호출
            left = max(0, limit_seconds - int(time.time() - start))
            return pk_input_v22(
                working_str=working_str,
                limit_seconds=left,
                return_default=return_default,
                get_input_validated=get_input_validated,
                verbose_log=verbose_log,
                masked=masked,
                auto_repeat=auto_repeat,
                fuzzy_accept=fuzzy_accept,
            )
        return return_default

    return result


def pk_input_v33_nvim_theme(
        working_str: str,
        limit_seconds: int = 30,
        return_default: str | None = None,
        *,
        masked: bool = False,
        fuzzy_accept: list[tuple[str, ...]] | None = None,
        validator=None,  # Callable[[str], bool]
        vi_mode: bool = True,
) -> str | None:
    """
    진행바(그래디언트) + 텍스트 영역 Gruvbox 스타일
    """

    from dataclasses import dataclass
    import inspect
    import sys
    import threading
    import time

    import colorama  # pip install colorama
    from prompt_toolkit import PromptSession  # pip install prompt_toolkit
    from prompt_toolkit.styles import Style

    colorama.just_fix_windows_console()

    # ──────────── Gruvbox 팔레트 ────────────────────────────
    @dataclass(frozen=True)
    class Gruvbox:
        bg: str = "\033[48;2;40;40;40m"
        fg: str = "\033[38;2;235;219;178m"
        reset: str = "\033[0m"
        red: str = "\033[38;2;251;73;52m"
        yellow = "\033[38;2;250;189;47m"
        green = "\033[38;2;184;187;38m"
        blue: str = "\033[38;2;131;165;152m"
        seg_in: str = ""
        seg_out: str = ""

    GB = Gruvbox()

    # ──────────── 선형 보간 util ─────────────────────────────
    def rgb_lerp(c1, c2, t: float) -> str:
        r = round(c1[0] + (c2[0] - c1[0]) * t)
        g = round(c1[1] + (c2[1] - c1[1]) * t)
        b = round(c1[2] + (c2[2] - c1[2]) * t)
        return f"\033[38;2;{r};{g};{b}m"

    bar_w = 30
    start = time.time()
    done = threading.Event()
    max_len = 0

    # ── 진행바 스레드 ───────────────────────────────────
    def draw_bar():
        nonlocal max_len
        while not done.is_set():
            remain = max(0, limit_seconds - int(time.time() - start))
            ratio = remain / limit_seconds

            # progress 색 (bar 전용)
            if ratio > .5:
                bar_color = rgb_lerp((250, 189, 47), (184, 187, 38), (ratio - .5) * 2)
            else:
                bar_color = rgb_lerp((251, 73, 52), (250, 189, 47), ratio * 2)

            filled = round(bar_w * (1 - ratio))
            bar = f"{bar_color}{'▰' * filled}{'▱' * (bar_w - filled)}{GB.reset}"

            # ⏳·타이머·프롬프트 → Gruvbox fg / bg 적용
            prefix = f"{GB.bg}{GB.blue} ⏳ {remain:02d}s {GB.reset}"
            prompt = f"{GB.fg}{working_str}{GB.reset}"

            msg = f"{prefix} {bar} {prompt}"
            pad = " " * max(0, max_len - len(msg))
            sys.stdout.write("\r" + msg + pad)
            sys.stdout.flush()
            max_len = max(max_len, len(msg))

            if remain == 0:
                break
            time.sleep(0.5)

    threading.Thread(target=draw_bar, daemon=True).start()

    # ── prompt_toolkit 세션 ────────────────────────────
    style = Style.from_dict({"prompt": "fg:#ebdbb2 bg:#282828 bold"})
    session = PromptSession(style=style, vi_mode=vi_mode)

    answer = None
    params = inspect.signature(session.prompt).parameters
    if "timeout" in params:  # 최신 prompt_toolkit
        try:
            answer = session.prompt('', is_password=masked, timeout=limit_seconds)
        except (KeyboardInterrupt, EOFError, TimeoutError):
            answer = None
    else:  # 구버전 호환
        holder = {"val": None}

        def _ask():
            try:
                holder["val"] = session.prompt('', is_password=masked)
            except (KeyboardInterrupt, EOFError):
                pass

        t = threading.Thread(target=_ask, daemon=True)
        t.start();
        t.join(limit_seconds)
        answer = holder["val"]

    done.set()
    sys.stdout.write("\r" + " " * max_len + "\r");
    sys.stdout.flush()

    if not answer:
        answer = return_default

    # fuzzy‑accept
    if fuzzy_accept and answer:
        low = answer.lower()
        for group in fuzzy_accept:
            if low in group:
                answer = group[0];
                break

    # validation
    if validator and answer and not validator(answer):
        return return_default

    return answer


def pk_input_v44_uv_theme(
        working_str: str,
        limit_seconds: int = 30,
        return_default: str | None = None,
        *,
        masked: bool = False,
        fuzzy_accept: list[tuple[str, ...]] | None = None,
        validator=None,
        vi_mode: bool = True,
) -> str | None:
    from dataclasses import dataclass
    import inspect
    import sys
    import threading
    import time

    from prompt_toolkit import PromptSession  # pip install prompt_toolkit
    from prompt_toolkit.styles import Style

    import colorama
    bar_w = 30
    start = time.time()
    done = threading.Event()
    max_len = 0

    colorama.just_fix_windows_console()

    # ──────────── UV 팔레트 ────────────────────────────────
    @dataclass(frozen=True)
    class UvTheme:
        bg: str = "\033[48;2;38;35;58m"  # #26233a
        fg: str = "\033[38;2;93;253;255m"  # 시안
        reset: str = "\033[0m"
        pink: str = "\033[38;2;255;72;196m"  # #ff48c4
        cyan: str = "\033[38;2;93;253;255m"  # #5dfdff
        seg_in: str = ""
        seg_out: str = ""

    UV = UvTheme()  # 참고 색: uv 로고 

    UV_PINK = (255, 72, 196)  # 시작
    UV_CYAN = (93, 253, 255)  # 50%
    UV_PURPLE = (154, 92, 255)  # 끝(딥퍼플 예시)
    UV_NEON_PUR = (154, 92, 255)  # 0.66 #9a5cff  (네온 보라)
    UV_DARK_PUR = (82, 0, 200)  # 1.00 #5200c8  (딥 퍼플)

    UV_PURPLE_FG = "\033[38;2;154;92;255m"  # 전경색
    UV_DARK_PUR_FG = "\033[38;2;82;0;200m"  # 전경색

    # ── 교체할 uv_gradient 함수 ───────────────────────
    def uv_gradient_3step(t: float) -> str:
        """
        0   → pink (#ff48c4)
        0.5 → cyan (#5dfdff)
        1   → purple-ish (#9a5cff)  ← 원하는 색으로 교체 가능
        """
        if t < 0.5:  # pink → cyan 구간
            ratio = t * 2  # 0→1
            c1, c2 = UV_PINK, UV_PURPLE
        else:  # cyan → purple 구간
            ratio = (t - .5) * 2
            c1, c2 = UV_PURPLE, UV_DARK_PUR

        r = round(c1[0] + (c2[0] - c1[0]) * ratio)
        g = round(c1[1] + (c2[1] - c1[1]) * ratio)
        b = round(c1[2] + (c2[2] - c1[2]) * ratio)
        return f"\033[38;2;{r};{g};{b}m"

    def uv_gradient_4step(t: float) -> str:
        """
        0   → pink  (#ff48c4)
        0.33→ cyan  (#5dfdff)
        0.66→ neon‑purple (#9a5cff)
        1   → dark‑purple (#5200c8)
        """
        if t < 1 / 3:
            ratio = t * 3  # 0‑0.33  pink→cyan
            c1, c2 = UV_PINK, UV_CYAN
        elif t < 2 / 3:
            ratio = (t - 1 / 3) * 3  # 0.33‑0.66 cyan→neon‑purp
            c1, c2 = UV_CYAN, UV_NEON_PUR
        else:
            ratio = (t - 2 / 3) * 3  # 0.66‑1   neon‑purp→dark‑purp
            c1, c2 = UV_NEON_PUR, UV_DARK_PUR

        r = round(c1[0] + (c2[0] - c1[0]) * ratio)
        g = round(c1[1] + (c2[1] - c1[1]) * ratio)
        b = round(c1[2] + (c2[2] - c1[2]) * ratio)
        return f"\033[38;2;{r};{g};{b}m"

    # ── 진행바 스레드 ───────────────────────────────────
    def draw_bar():
        nonlocal max_len
        while not done.is_set():
            remain = max(0, limit_seconds - int(time.time() - start))
            ratio = 1 - remain / limit_seconds  # 0→1 진행

            bar_color = uv_gradient_3step(ratio)
            filled = round(bar_w * ratio)
            bar = f"{bar_color}{'▰' * filled}{'▱' * (bar_w - filled)}{UV.fg}"

            prefix = f"{UV.bg}{UV.pink} ⏳ {remain:02d}s "
            # prompt = f"{UV.pink} {working_str}{UV.fg}"
            prompt = f"{UV_PURPLE_FG} {working_str}{UV.fg}"
            line = prefix + bar + prompt

            pad = " " * max(0, max_len - len(line))
            sys.stdout.write("\r" + line + pad + UV.reset)
            # sys.stdout.flush() # pk*
            max_len = max(max_len, len(line))

            if remain == 0:
                break
            time.sleep(0.5)

    threading.Thread(target=draw_bar, daemon=True).start()

    # ── prompt_toolkit 입력 ────────────────────────────
    style = Style.from_dict({"prompt": "fg:#5dfdff bg:#26233a bold"})
    session = PromptSession(style=style, vi_mode=vi_mode)

    answer = None
    if "timeout" in inspect.signature(session.prompt).parameters:
        try:
            answer = session.prompt('', is_password=masked, timeout=limit_seconds)
        except (KeyboardInterrupt, EOFError, TimeoutError):
            answer = None
    else:  # 구버전 호환
        holder = {"val": None}

        def _ask():
            try:
                holder["val"] = session.prompt('', is_password=masked)
            except (KeyboardInterrupt, EOFError):
                pass

        t = threading.Thread(target=_ask, daemon=True)
        t.start()
        t.join(limit_seconds)
        answer = holder["val"]

    done.set()
    sys.stdout.write("\r" + " " * max_len + "\r");
    sys.stdout.flush()

    if not answer:
        answer = return_default

    if fuzzy_accept and answer:
        low = answer.lower()
        for group in fuzzy_accept:
            if low in group:
                answer = group[0];
                break

    if validator and answer and not validator(answer):
        return return_default

    return answer


def pk_input(working_str, limit_seconds, return_default, get_input_validated=None):
    return pk_input_v44_uv_theme(working_str, limit_seconds, return_default, get_input_validated)


def get_nx_validated(nx):
    from pkg_py.pk_colorful_cli_util import pk_print
    nx = nx.strip()
    if any(char in nx for char in r'\/:*?"<>|'):
        pk_print("Char not allowed in f_n/d_n. Retry.", print_color='red')
        raise
    return nx


def get_no_blank_working_str_validated(working_str):
    from pkg_py.pk_colorful_cli_util import pk_print
    name = working_str.strip()
    if not name:
        pk_print("❌ blank, name not allowed. Please try again.", print_color='red')
        raise ValueError("Input is blank")
    return name


def get_pnx_validated(pnx):
    from pkg_py.pk_colorful_cli_util import pk_print
    import os
    pnx = pnx.strip()
    pnx = get_pnx_os_style(pnx)
    if not os.path.exists(pnx):
        pk_print(f"❌ 경로가 존재하지 않습니다: {pnx}", print_color='red')
        raise
    return pnx


def get_pk_input(message, answer_options):
    return get_pk_input_via_tab_v2(message, answer_options)


def get_pk_input_via_tab_v1(message, tab_completer_iterable):
    from prompt_toolkit import prompt
    from prompt_toolkit.completion import WordCompleter
    deduplicated_tab_completer_iterable = tab_completer_iterable
    deduplicated_tab_completer_iterable = [get_pnx_os_style(f) for f in deduplicated_tab_completer_iterable]
    deduplicated_tab_completer_iterable = list(set(deduplicated_tab_completer_iterable))
    deduplicated_tab_completer_iterable = get_list_sorted(working_list=deduplicated_tab_completer_iterable, mode_asc=1)
    completer = WordCompleter(deduplicated_tab_completer_iterable)
    pk_input = prompt(message, completer=completer)
    return pk_input


def get_pk_input_via_tab_v2(message, tab_completer_iterable):
    from prompt_toolkit import prompt
    from prompt_toolkit.completion import WordCompleter
    import inspect

    func_n = inspect.currentframe().f_code.co_name
    if message.strip() == "x":
        pk_speak(f"{func_n}() exited(intended)")

    seen = set()
    if is_os_wsl_linux():
        # from pkg_py.pk_core_constants import STAMP_TRY_GUIDE
        # from pkg_py.pk_colorful_cli_util import pk_print
        # cmd_to_run = None
        # cmd = None
        # if pk_arg_list is None:
        #     pk_arg_list = []
        # available_pk_python_program_pnx = get_available_pk_python_program_pnx(pk_idx)
        # cmd_to_run = 'uv run python'
        # cmd_to_run = 'python'
        # tmux_session = get_nx(available_pk_python_program_pnx).replace(".", "_")
        # ensure_tmux_pk_session_removed(tmux_session)

        # if os.environ.get("TMUX"):
        #     # 수직 분할: -v, 수평 분할: -h 로 바꿀 수 있음
        #     split_flag = "-v"
        #     # LTA 모드라면 끝에 sleep 추가
        #     sleep_cmd = "; sleep 99999" if LTA else ""
        #     cmd_to_os(cmd=(
        #         f"tmux split-window {split_flag} "
        #         f"'clear && {cmd_to_run} {available_pk_python_program_pnx}{sleep_cmd}'"
        #     ))
        #     return

        # tmux_session = get_nx(available_pk_python_program_pnx).replace(".", "_")
        # ensure_tmux_pk_session_removed(tmux_session)

        # cmd_to_os(cmd=(
        #     f"tmux new-session -s {tmux_session} -d "
        #     f"'clear && {cmd_to_run} {available_pk_python_program_pnx}'"
        # ))
        # cmd_to_os(cmd=(
        #     f"tmux split-window -v -t {tmux_session} "
        #     f"'clear && {cmd_to_run} {available_pk_python_program_pnx}'"
        # ))
        # cmd_to_os(cmd=f"tmux attach-session -t {tmux_session}")

        # deduped = cmd_to_os('fzf') + []
        deduped = []
    else:
        deduped = []

    # 1) get_pnx_os_style 적용 + 중복 제거 (원본 순서 유지)
    for item in tab_completer_iterable:
        styled = item
        if isinstance(item, str):
            if is_path_like(item):
                styled = get_pnx_os_style(item)
        if styled not in seen:
            seen.add(styled)
            deduped.append(styled)

    # 2) 필요하면 정렬
    # deduped = get_list_sorted(working_list=deduped, mode_asc=1)

    # 3) WordCompleter에 넘겨서 프롬프트 실행
    completer = WordCompleter(deduped)
    return prompt(message, completer=completer)


def get_pk_input_list_via_tab(message, tab_completer_nested_iterable):
    """
    tab_completer_nested_iterable: [
        ['.jpg',  '.jpeg', '.png',  '.webp', '.jfif'],
        ['mp4',   'mkv',   'avi']
    ]
    반환: 사용자가 선택한 하위 리스트 (sample: ['mp4','mkv','avi'])
    """
    # lazy import
    from prompt_toolkit import prompt
    from prompt_toolkit.completion import WordCompleter
    from prompt_toolkit.shortcuts import CompleteStyle

    # 1) 리스트 전체를 문자열로 표시할 후보 준비
    display_map = {str(lst): lst for lst in tab_completer_nested_iterable}
    candidates = list(display_map.keys())

    completer = WordCompleter(
        candidates,
        ignore_case=True,
        match_middle=True,
    )

    chosen = prompt(
        message,
        completer=completer,
        complete_while_typing=True,
        complete_style=CompleteStyle.COLUMN,
    ).strip()

    # 2) 선택한 문자열에 대응하는 실제 리스트 반환
    return display_map.get(chosen, [])


@pk_measure_seconds
def pk_ensure_f_list_organized_by_ngram(token_splitter_pattern, d_working):
    import os

    allowed_extension_tuple = get_tuple_from_set(get_extension_set_from_d(d_working))
    f_to_organize_list = [f for f in os.listdir(d_working) if f.endswith(allowed_extension_tuple)]
    if not f_to_organize_list:
        print("📁 대상 파일이 없습니다.")
        return

    min_support = int(get_pk_input(message='min_support=', answer_options=["2", "3", "4", "5"]))  # 3 추천
    max_n = int(get_pk_input(message='max_n=', answer_options=["2", "3", "4", "5", "6", "7", "8", "9", "10"]))  # 3 or 10  추천
    pk_organize_f_list_by_ngram(f_to_organize_list, d_working, token_splitter_pattern, min_support, max_n)


def get_union_set(set_a, set_b):
    """합집합 A ∪ B"""
    return set(set_a) | set(set_b)


def get_difference_set(set_a, set_b):
    """차집합 A - B (A에는 있고 B에는 없는)"""
    return set(set_a) - set(set_b)


def get_intersection_set(set_a, set_b):
    """교집합 A ∩ B"""
    return set(set_a) & set(set_b)


def get_symmetric_difference_set(set_a, set_b):
    """대칭차집합 A △ B (A 또는 B에만 있는 요소들)"""
    return set(set_a) ^ set(set_b)


def get_set_unioned(set_a, set_b):
    return get_union_set(set_a, set_b)


def get_list_unioned(list_a, list_b):
    return list_a + list_b


def get_set_differenced(set_a, set_b):
    return get_difference_set(set_a, set_b)


def get_list_differenced(list_a, list_b):
    set_b = set(list_b)
    return [item for item in list_a if item not in set_b]


def get_list_that_element_applyed_via_func(func, working_list):
    return [func(item) for item in working_list]


@pk_measure_seconds
def kill_self_pk_program(self_f):
    # suicide
    from pkg_py.pk_core_constants import D_PKG_PY
    f_list = [
        rf"{D_PKG_PY}/{get_nx(self_f)}",
    ]
    f_list = get_list_that_element_applyed_via_func(func=get_pnx_os_style, working_list=f_list)
    for f in f_list:
        pk_kill_process_by_window_title_seg(window_title_seg=get_nx(f))


@pk_measure_seconds
def pk_kill_pk_program_list():
    from pkg_py.pk_core_constants import D_PKG_PY

    f_list_a = get_pnx_list_from_d_working(d_working=D_PKG_PY, with_walking=0)
    f_list_a = get_list_that_element_applyed_via_func(func=get_pnx_os_style, working_list=f_list_a)
    f_list_b = [
        rf"{D_PKG_PY}\pk_core.py",
        rf"{D_PKG_PY}\pk_core_class.py",
        rf"{D_PKG_PY}\pk_core_constants.py"
        rf"{D_PKG_PY}\pk_kill_pk_program.py",
    ]
    f_list_b = get_list_that_element_applyed_via_func(func=get_pnx_os_style, working_list=f_list_b)
    f_list = get_list_differenced(list_a=f_list_a, list_b=f_list_b)
    for f in f_list:
        pk_kill_process_by_window_title_seg(window_title_seg=get_nx(f))
    if not LTA:
        kill_self_pk_program(self_f='pk_kill_pk_program.py')


def pk_lock_os():
    if is_os_windows():
        save_power_as_s3()
    elif is_os_wsl_linux():
        save_power_as_s3()
    else:
        cmd_to_os('echo TBD')


def pk_assist_to_lock_os_v1():
    from datetime import datetime
    last_cleared_hour = -1  # 아직 클리어된 적 없음을 의미

    while True:
        now = datetime.now()

        # 시간 단위가 바뀌었을 때만 콘솔 클리어
        if now.hour != last_cleared_hour:
            clear_console()
            last_cleared_hour = now.hour

        # 잠잘 시간
        if (now.hour == 0 and now.minute >= 12) or (0 < now.hour < 5) or (now.hour == 5 and now.minute <= 30):
            pk_lock_os()

        pk_sleep(milliseconds=10000)


def pk_assist_to_lock_os():
    from datetime import datetime, time

    def parse_time_ranges(text_list):
        """sample: ["12:00-13:00", "15:00-15:10"] -> [(time(12,0), time(13,0)), (time(15,0), time(15,10))]"""
        ranges = []
        for txt in text_list:
            try:
                start_str, end_str = txt.split("-")
                h1, m1 = map(int, start_str.strip().split(":"))
                h2, m2 = map(int, end_str.strip().split(":"))
                ranges.append((time(h1, m1), time(h2, m2)))
            except:
                continue
        return ranges

    def is_now_in_time_ranges(now_time, time_ranges):
        for start, end in time_ranges:
            if start <= now_time <= end:
                return True
        return False

    # 샘플 설정 시간
    sleep_time_ranges_text = ["00:12-05:30"]
    lunch_time_ranges_text = ["12:00-13:00"]
    break_time_ranges_text = ["15:00-15:15"]
    exercise_time_ranges_text = ["18:30-18:50"]

    # 파싱
    all_time_blocks = (
            parse_time_ranges(sleep_time_ranges_text)
            + parse_time_ranges(lunch_time_ranges_text)
            + parse_time_ranges(break_time_ranges_text)
            + parse_time_ranges(exercise_time_ranges_text)
    )

    last_cleared_hour = -1  # 아직 클리어된 적 없음을 의미

    while True:
        now = datetime.now()
        now_time = now.time()

        # 1 시간 마다 콘솔 클리어
        if now.hour != last_cleared_hour:
            clear_console()
            last_cleared_hour = now.hour

        # 시간 블럭에 해당하면 잠금
        if is_now_in_time_ranges(now_time, all_time_blocks):
            pk_lock_os()

        pk_sleep(milliseconds=10000)


def pk_assist_to_alert_time():
    from pkg_py.pk_colorful_cli_util import pk_print
    from datetime import datetime, time

    def parse_time_ranges(text_list):
        """sample: ["12:00-13:00", "15:00-15:10"] -> [(time(12,0), time(13,0)), (time(15,0), time(15,10))]"""
        ranges = []
        for txt in text_list:
            try:
                start_str, end_str = txt.split("-")
                h1, m1 = map(int, start_str.strip().split(":"))
                h2, m2 = map(int, end_str.strip().split(":"))
                ranges.append((time(h1, m1), time(h2, m2)))
            except:
                continue
        return ranges

    def is_now_in_time_range(now_time, time_range):
        start, end = time_range
        return start <= now_time <= end

    def alert(now_time):
        """알림 함수: 현재 시간을 출력하고, OS에 따라 알림 표시"""
        from pkg_py.pk_colorful_cli_util import pk_print
        pk_speak(f"현재 시간은 {now_time.hour}시 {now_time.minute}분입니다.")
        pk_print(f"현재 시간은 {now_time.hour}시 {now_time.minute}분입니다.", print_color='yellow')

    # 샘플 설정 시간
    sleep_time_ranges_text = ["00:12-05:30"]
    lunch_time_ranges_text = ["12:00-13:00"]
    break_time_ranges_text = ["15:00-15:15"]
    exercise_time_ranges_text = ["18:30-18:50"]

    # 파싱
    all_time_blocks = (
            parse_time_ranges(sleep_time_ranges_text)
            + parse_time_ranges(lunch_time_ranges_text)
            + parse_time_ranges(break_time_ranges_text)
            + parse_time_ranges(exercise_time_ranges_text)
    )

    alerted_blocks = set()  # 이미 알림을 한 시간 구간 저장
    last_cleared_hour = -1  # 아직 클리어된 적 없음을 의미

    while True:
        now = datetime.now()
        now_time = now.time()

        # 1시간마다 콘솔 클리어
        if now.hour != last_cleared_hour:
            clear_console()
            last_cleared_hour = now.hour
            alerted_blocks.clear()  # 새로운 시간 진입 시, 알림 상태 초기화
            pk_print(f"alerted_blocks=({alerted_blocks})", print_color='yellow')

        for idx, block in enumerate(all_time_blocks):
            if is_now_in_time_range(now_time, block):
                if idx not in alerted_blocks:
                    alert(now_time)
                    alerted_blocks.add(idx)
                break  # 현재 속한 구간 하나만 처리

        pk_sleep(milliseconds=10000)


def pk_oraganize_f_list_to_d_by_x(d_working, ext, d_dst):
    import os
    from pkg_py.pk_colorful_cli_util import pk_print

    if not os.path.exists(d_dst):
        os.makedirs(d_dst)  # 대상 디렉토리가 없으면 생성

    # 파일 이름별로 정리
    f_nx_list_dict = {}
    for f_nx in os.listdir(d_working):
        f_n, f_x = os.path.splitext(f_nx)
        if f_x == ext:
            if f_n in f_nx_list_dict:
                f_nx_list_dict[f_n].append(f_nx)
            else:
                f_nx_list_dict[f_n] = [f_nx]
        else:
            if f_n not in f_nx_list_dict:
                f_nx_list_dict[f_n] = []

    for f_n, files in f_nx_list_dict.items():
        for f_nx in files:
            f_src = os.path.join(d_working, f_nx)
            d_dst = os.path.join(d_dst, f_nx)
            pk_print(f"Moving: {f_src} -> {d_dst}", print_color='green')
            move_pnx(pnx=f_src, d_dst=d_dst, sequential_mode=1)


def pk_assist_to_ensure_f_list_organized_by_x():
    import os
    from pkg_py.pk_core_constants import D_WORKING
    while 1:
        d_working = get_pk_input(message='d_working=', answer_options=[os.getcwd(), D_WORKING, D_PROJECT, D_DOWNLOADS])
        # ext_set = {".webm"}
        ext_set = get_extension_set_from_d(d_working)
        for ext in ext_set:
            d_dst_n = f"f_organized_by_{ext}".replace('.', "")  # [OPTION]
            d_dst = os.path.join(d_working, d_dst_n)
            pk_oraganize_f_list_to_d_by_x(d_working=d_working, ext=ext, d_dst=d_dst)


def get_word_set_from_f_list(d_working):
    import os
    import re

    # 1) 디렉토리 내 파일만 추출
    filenames = [
        f for f in os.listdir(d_working)
        if os.path.isfile(os.path.join(d_working, f))
    ]

    # 2) 숫자 접두사가 있을 땐 (0,숫자), 없으면 (1,이름) 으로 키 생성
    def sort_key(name: str):
        m = re.match(r'^(\d+)', name)
        if m:
            return (0, int(m.group(1)))
        return (1, name.lower())

    # 3) 정렬
    filenames_sorted = sorted(filenames, key=sort_key)

    # 4) 토큰 추출 & set에 추가
    tokens = set()
    for fname in filenames_sorted:
        parts = re.split(r'[.\s]+', fname)
        for p in parts:
            if p:
                tokens.add(p)

    return tokens


def pk_assist_to_ensure_f_list_organized_by_nx_delimiter():
    from colorama import init as pk_colorama_init
    from pkg_py.pk_core_constants import D_DOWNLOADS, D_PROJECT, D_WORKING
    pk_colorama_init(autoreset=True)

    tab_completer_iterable = [D_WORKING, D_PROJECT, D_DOWNLOADS]
    while 1:
        d_working = get_pk_input(message='d_working=', answer_options=tab_completer_iterable)
        tab_completer_iterable.append(d_working)
        tab_completer_iterable = get_list_deduplicated(working_list=tab_completer_iterable)
        word_set = get_word_set_from_f_list(d_working=d_working)
        word_list = get_list_from_set(working_set=word_set)
        word_list = get_list_unioned(list_a=word_list, list_b=['seg', 'SEG'])
        word_list = get_list_sorted(working_list=word_list)
        nx_delimiter = get_pk_input(message='nx_delimiter=', answer_options=word_list)
        # for nx_delimiter in range(2000,2024):
        #     organize_f_list_by_nx_delimiter(nx_delimiter=str(nx_delimiter), d_working=d_working)
        pk_organize_f_list_by_nx_delimiter(nx_delimiter=nx_delimiter, d_working=d_working)


@pk_measure_seconds
def print_pk_ver():
    from pkg_py.pk_colorful_cli_util import pk_print
    if LTA:
        pk_print(f'''{'%%%FOO%%%' if LTA else ''}''')
    print('pk_ver.1.32.12')


@pk_measure_seconds
def guide_pk_error_mssage():
    from pkg_py.pk_colorful_cli_util import pk_print
    pk_print(f'''Not Prepared function :) {'%%%FOO%%%' if LTA else ''}''', print_color='green', mode_verbose=0)


def pk_replace_f_nx_list_from_old_str_to_new_str(d_working, old_str, new_str):
    import os
    from pkg_py.pk_colorful_cli_util import pk_print
    for f_nx in os.listdir(d_working):
        pnx_old = os.path.join(d_working, f_nx)
        if os.path.isfile(pnx_old) and old_str in f_nx:
            f_nx_new = f_nx.replace(old_str, new_str)
            f_nx_new = f_nx_new.strip()
            f_new = os.path.join(d_working, f_nx_new)
            os.rename(pnx_old, f_new)
            if f_nx_new:
                pk_print(f"Renamed: {f_nx} -> {f_nx_new}", print_color='green')
            else:
                pk_print(f"Renamed: {f_nx} -> {f_nx_new}", print_color='red')


def ensure_f_list_change_stable(f_list, limit_seconds, monitoring_interval_seconds=0.2):
    import os
    import time
    from pkg_py.pk_colorful_cli_util import pk_print

    f_list = [get_pnx_os_style(f) for f in f_list]

    def get_mtime_map(f_list):
        result = {}
        for f in f_list:
            try:
                if os.path.exists(f):
                    result[f] = os.path.getmtime(f)
                else:
                    pk_print(f"❌ 경로 없음: {f}", print_color='red')
            except Exception as e:
                pk_print(f"❌ getmtime 실패: {f} | {e}", print_color='red')
        # if LTA:
        #     pk_print(f"[DEBUG] get_mtime_map -> {result}")
        return result

    f_nx_list = [get_nx(f) for f in f_list]
    pk_print(f"⏳ {limit_seconds}초간 f_nx_list={f_nx_list} 변경 감시 시작...", print_color='white')
    baseline = get_mtime_map(f_list)
    start_time = time.time()

    while True:
        current = get_mtime_map(f_list)
        for f in f_list:
            if f in baseline and f in current and baseline[f] != current[f]:
                pk_print(f"f_list is not stable ({f})")
                return False
        if time.time() - start_time >= limit_seconds:
            pk_print(f"f_list is stable for ({limit_seconds})")
            return True

        pk_sleep(monitoring_interval_seconds)


def collect_f_list_recursive(d_working):
    import os
    results = []
    for dirpath, _, filenames in os.walk(d_working):
        for fname in filenames:
            full_path = os.path.join(dirpath, fname)  # ← 전체 경로 생성
            if is_f(full_path):  # ← 전체 경로를 넘김
                results.append(full_path)
    return results


def print_f_list_preview(file_list, num_preview=10):
    """수집될 파일 목록을 미리보기로 출력"""
    print(f"총 {len(file_list)}개 항목 중 앞{num_preview}개:")
    for path in file_list[:num_preview]:
        print("  ", path)
    if len(file_list) > num_preview:
        print("  ...")


def ensure_unique(dst_dir, name):
    """
    dst_dir에 name과 같은 파일이 이미 있으면
    (1), (2), ... suffix를 붙여 고유명으로 반환
    """
    import os

    base, ext = os.path.splitext(name)
    candidate = name
    n = 1
    while os.path.exists(os.path.join(dst_dir, candidate)):
        candidate = f"{base}({n}){ext}"
        n += 1
    return candidate


def collect_and_move(file_list, src_root):
    """file_list를 src_root+'_merged' 폴더로 이동, 중복 파일명에 (n) 붙임"""
    import os
    import shutil

    dst_root = f"{src_root.rstrip(os.sep)}_merged"
    os.makedirs(dst_root, exist_ok=True)

    for src_path in file_list:
        name = os.path.basename(src_path)
        unique_name = ensure_unique(dst_root, name)
        dst_path = os.path.join(dst_root, unique_name)
        shutil.move(src_path, dst_path)
        print(f"Moved: {src_path} -> {dst_path}")


def pk_ensure_f_list_scaned_and_collected():
    """메인 흐름: 스캔 후 이동"""
    import os
    import sys
    from pkg_py.pk_colorful_cli_util import print_red
    from pkg_py.pk_core_constants import D_DOWNLOADS, D_PROJECT, D_WORKING

    tab_completer = [D_WORKING, D_PROJECT, D_DOWNLOADS, rf"{D_DOWNLOADS}\[]\pk_ani"]

    # 명령 인자 우선
    if len(sys.argv) == 2:
        working_dir = sys.argv[1]
    else:
        working_dir = None

    while True:
        if not working_dir:
            working_dir = get_pk_input(message='d_working=', answer_options=tab_completer)
            tab_completer.append(working_dir)

        if not os.path.isdir(working_dir):
            print_red(f"Error: '{working_dir}' 는 유효한 디렉토리가 아닙니다.")
            sys.exit(1)

        f_list = collect_f_list_recursive(working_dir)
        total_before = len(f_list)
        if total_before == 0:
            pk_print("수집 대상이 없습니다.", print_color='green')
            pk_print(f'''"수집 대상이 없습니다." {'%%%FOO%%%' if LTA else ''}''', print_color='green')

            break

        print_f_list_preview(f_list)

        choice = get_pk_input(message='choice (o/x)=', answer_options=['o', 'x'])
        if choice.strip().lower() != 'o':
            print("수집 취소됨.")
            return

        # 이동 전 파일 수 확인
        print(f"이동 전 파일 개수: {total_before}개")
        collect_and_move(f_list, working_dir)
        # 이동 후 파일 수 확인
        dst_dir = f"{working_dir.rstrip(os.sep)}_merged"
        moved_count = len([name for name in os.listdir(dst_dir) if os.path.isfile(os.path.join(dst_dir, name))])
        print(f"이동 후 파일 개수: {moved_count}개")

        print(f"모든 항목을 '{working_dir}_merged'로 이동했습니다. (이동됨: {moved_count}/{total_before})")
        continue

        choice = get_pk_input(message='choice (o/x)=', answer_options=['o', 'x'])
        if choice.strip().lower() != 'o':
            print("수집 취소됨.")
            continue

        collect_and_move(f_list, working_dir)
        print(f"모든 항목을 '{working_dir}_merged'로 이동했습니다.")
        continue


def pk_delete_empty_d_list():
    import os
    from pkg_py.pk_core_constants import D_DOWNLOADS, D_PROJECT, D_WORKING
    def _delete_tree(root_path: str):
        """
        주어진 디렉토리(root_path)를 후위 순회로 삭제합니다.
        """
        # 먼저 하위 항목들 처리
        for entry in os.scandir(root_path):
            path = entry.path
            if entry.is_dir(follow_symlinks=False):
                # 서브디렉토리 재귀 삭제
                _delete_tree(path)
            else:
                # 파일 삭제
                os.remove(path)
        # 하위 항목까지 다 비워졌으면 자신(빈 디렉토리)도 삭제
        os.rmdir(root_path)

    tab_completer_iterable = [D_WORKING, D_PROJECT, D_DOWNLOADS]
    d_working = get_pk_input(
        message='d_working=',
        answer_options=tab_completer_iterable
    )

    if not os.path.isabs(d_working):
        raise ValueError(f"절대경로를 입력해야 합니다: {d_working!r}")
    if not os.path.isdir(d_working):
        return

    _delete_tree(d_working)


def cmd_to_os_with_splited_arg(cmd, capture_output=False, **kwargs):
    """cmd_to_os로 OS 명령 실행"""
    cmd_str = ' '.join(cmd) if isinstance(cmd, (list, tuple)) else str(cmd)
    print(f"> {cmd_str}")
    return cmd_to_os(cmd=cmd_str)


def get_wsl_distro_name(cmd):
    wsl_distro_name = []
    std_out_list = cmd_to_os(cmd=cmd, encoding='utf-16')
    for line_str in std_out_list:
        line_str = line_str.strip()
        if line_str.startswith("NAME"):
            continue
        if line_str.startswith("*"):
            line_str = line_str.replace("* ", "")
            line_str = line_str.strip()
        parts = line_str.split(' ')
        name = parts[0]
        line_str = line_str.strip()
        wsl_distro_name.append(name)
    return wsl_distro_name


@pk_measure_seconds
def ensure_pk_wsl_distro_installed():
    """
    1. PK_WSL_DISTRO_N이 이미 설치되어 있으면 건너뜀
    2. DEFAULT_DISTRO가 설치 안 됐으면 install
    3. DEFAULT_DISTRO export -> unregister -> import as PK_WSL_DISTRO_N
    4. 성공 시 tar 파일 삭제
    """
    from pathlib import Path

    from pkg_py.pk_core_constants import D_DOWNLOADS
    from pkg_py.pk_core_constants import PK_WSL_DISTRO_N
    from pkg_py.pk_colorful_cli_util import pk_print, print_red

    # 설정 기본값
    DEFAULT_DISTRO = "Ubuntu-24.04"
    # DEFAULT_DISTRO = "Ubuntu-18.04"
    pk_print(f"PK_WSL_DISTRO_N={PK_WSL_DISTRO_N}{' %%%FOO%%%' if LTA else ''}")
    pk_print(f"DEFAULT_DISTRO={DEFAULT_DISTRO}{' %%%FOO%%%' if LTA else ''}")

    wsl_distro_name_installed = get_wsl_distro_name(cmd="wsl -l -v")
    pk_print(f'''wsl_distro_name_installed={wsl_distro_name_installed} {'%%%FOO%%%' if LTA else ''}''')
    # # 1) 이미 PK_WSL_DISTRO_N 확인
    if PK_WSL_DISTRO_N or rf'* {PK_WSL_DISTRO_N}' == wsl_distro_name_installed:
        pk_print(f"'{PK_WSL_DISTRO_N}' 배포판이 이미 설치되어 있습니다. 설치를 건너뜁니다.")
        return True

    # 2) DEFAULT_DISTRO 설치 여부
    if DEFAULT_DISTRO not in wsl_distro_name_installed:
        wsl_distro_name_installable_from_online = get_wsl_distro_name(cmd="wsl --list --online")
        pk_print(f'''wsl_distro_name_installable_from_online={wsl_distro_name_installable_from_online} {'%%%FOO%%%' if LTA else ''}''')
        if DEFAULT_DISTRO not in wsl_distro_name_installable_from_online:
            print_red(f"'{DEFAULT_DISTRO}' 배포판을 online 목록에서 찾을 수 없습니다.")
            return False
        else:
            pk_print(f"'{DEFAULT_DISTRO}' 배포판을 online 목록에서 찾았습니다.")
        pk_print(f"'{DEFAULT_DISTRO}' 배포판을 설치합니다...")
        try:
            cmd_to_os_with_splited_arg(["wsl", "--install", "-d", DEFAULT_DISTRO])
        except Exception as e:
            print_red(f"설치 명령 실패: {e}")
            return False
    else:
        pk_print(f"'{DEFAULT_DISTRO}' 배포판이 이미 설치되어 있습니다.")

    # 3) export, unregister, import

    tar_path = Path.cwd() / f"{DEFAULT_DISTRO}.tar"  # 임시 export 파일 경로
    install_path = Path(D_DOWNLOADS) / PK_WSL_DISTRO_N  # import 설치 디렉토리
    try:
        pk_print(f"'{DEFAULT_DISTRO}' 배포판을 '{tar_path}'로 export합니다.")
        cmd_to_os_with_splited_arg(["wsl", "--export", DEFAULT_DISTRO, str(tar_path)])

        pk_print(f"'{DEFAULT_DISTRO}' 배포판을 unregister 합니다.")
        cmd_to_os_with_splited_arg(["wsl", "--unregister", DEFAULT_DISTRO])

        pk_print(f"'{tar_path}'를 '{install_path}'에 import하여 '{PK_WSL_DISTRO_N}'으로 등록합니다.")
        install_path.mkdir(parents=True, exist_ok=True)
        cmd_to_os_with_splited_arg(["wsl", "--import", PK_WSL_DISTRO_N, str(install_path), str(tar_path)])
    except Exception as e:
        print_red(f"export/import 중 오류: {e}")
        return False

    # 4) 등록 확인 및 tar 파일 삭제
    wsl_distro_name_installed_after = get_wsl_distro_name(cmd="wsl -l -v")
    pk_print(f'''wsl_distro_name_installed_after={wsl_distro_name_installed_after} {'%%%FOO%%%' if LTA else ''}''')
    if PK_WSL_DISTRO_N or rf'* {PK_WSL_DISTRO_N}' in wsl_distro_name_installed_after:
        pk_print(f"'{PK_WSL_DISTRO_N}' 배포판이 정상적으로 import되었습니다.")
        if tar_path.exists():
            pk_print(f"'{tar_path}' 파일을 삭제합니다.")
            tar_path.unlink()
        return True
    else:
        print_red("import 후에도 배포판을 확인할 수 없습니다.")
        return False


def get_historical_list(f) -> List[str]:
    # if not does_pnx_exist(f):
    #     ensure_pnx_made(pnx=f, mode="f")
    # if not os.path.isfile(f):
    #     return []
    with open(f, 'r', encoding='utf-8') as f:
        # 줄 끝 공백 제거하고, 빈 문자열(빈 줄)은 제외
        items = [line.strip() for line in f if line.strip()]
    return items


def get_list_from_int_a_to_int_b(int_a: int, int_b: int) -> list[int]:
    step = 1 if int_b >= int_a else -1
    return list(range(int_a, int_b + step, step))


# 아래는 테스트 코드

def command_exists(cmd: str) -> bool:
    import shutil
    return shutil.which(cmd) is not None


def pk_log_step(step_label: str):
    import functools
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            from pkg_py.pk_colorful_cli_util import pk_print
            pk_print(f"[{step_label}] Starting")
            result = func(*args, **kwargs)
            pk_print(f"[{step_label}] Completed")
            return result

        return wrapper

    return decorator


def get_pk_config(key: str, initial: str) -> str:
    import os
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_PKG_TOML
    path = os.path.join(D_PKG_TOML, f"pk_token_{key}.toml")
    os.makedirs(os.path.dirname(path), exist_ok=True)
    if not os.path.exists(path):
        with open(path, 'w', encoding='utf-8') as f:
            f.write(initial)
        pk_print(f"[Config] Initialized '{key}' with default '{initial}' in {path}")
        return initial
    with open(path, 'r', encoding='utf-8') as f:
        value = f.readline().strip() or initial
    pk_print(f"[Config] Loaded '{key}' = '{value}'")
    return value


@pk_log_step("Step 1: Load DB configuration")
def ensure_load_config():
    container = get_pk_config("db_container_name", "nyaa_mariadb")
    name = get_pk_config("db_name", "nyaa_db")
    pwd = get_pk_config("db_password", "example")
    port = int(get_pk_config("db_port", "3306"))
    return container, name, pwd, port


@pk_log_step("Step 2: Prepare data directory")
def ensure_prepare_data_dir(container: str):
    import os
    from pkg_py.pk_colorful_cli_util import pk_print
    data_dir = os.path.join(os.path.expanduser("~"), "Downloads", f"{container}_data")
    os.makedirs(data_dir, exist_ok=True)
    pk_print(f"Data directory ready: {data_dir}")
    return data_dir


@pk_log_step("Step 3: Ensure Docker environment")
def ensure_docker_env():
    import subprocess
    from pkg_py.pk_colorful_cli_util import pk_print
    if not command_exists('docker'):
        pk_print('Docker missing: installing...', print_color='yellow')
        subprocess.run(['sudo', 'apt-get', 'update'], check=True)
        subprocess.run(['sudo', 'apt-get', 'install', '-y', 'docker.io'], check=True)
    else:
        pk_print('Docker exists')
    # 데몬 예외처리
    try:
        subprocess.run(['docker', 'info'], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except subprocess.CalledProcessError:
        pk_print('Docker daemon not running. Attempting to start...', print_color='yellow')
        # 시스템에 따라 service 또는 systemctl (WSL Ubuntu22.04는 systemctl, 18.04는 service)
        import platform
        start_cmd = ['sudo', 'service', 'docker', 'start']
        try:
            subprocess.run(start_cmd, check=True)
        except Exception as e:
            try:
                subprocess.run(['sudo', 'systemctl', 'start', 'docker'], check=True)
            except Exception as e2:
                pk_print(f'Docker daemon failed to start: {e}\n{e2}', print_color='red')
                raise RuntimeError("Docker daemon could not be started!")
        # 재확인
        try:
            subprocess.run(['docker', 'info'], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            pk_print("Docker daemon started successfully.")
        except subprocess.CalledProcessError:
            pk_print("Docker daemon is still not running. Please check manually.", print_color="red")
            raise RuntimeError("Docker daemon is not running!")
    return ['docker']


@pk_log_step("Step 4: Launch MariaDB container")
def ensure_launch_container(docker_cmd: list, container: str, name: str, pwd: str, port: int, data_dir: str):
    import subprocess, time
    from pkg_py.pk_colorful_cli_util import pk_print
    mount_arg = f"{data_dir}:/var/lib/mysql"
    try:
        subprocess.run(docker_cmd + ['inspect', container], check=True, stdout=subprocess.DEVNULL)
        pk_print(f"Container '{container}' already running")
    except subprocess.CalledProcessError:
        pk_print(f"Creating container '{container}'...", print_color='yellow')
        try:
            subprocess.run([
                *docker_cmd, 'run', '-d',
                '--name', container,
                '-e', f"MYSQL_ROOT_PASSWORD={pwd}",
                '-e', f"MYSQL_DATABASE={name}",
                '-p', f"{port}:3306",
                '-v', mount_arg,
                'mariadb:10.6'
            ], check=True)
        except subprocess.CalledProcessError as e:
            pk_print(f"Failed to create MariaDB container: {e}", print_color='red')
            raise
        pk_print('Waiting 20s for DB initialization')
        time.sleep(20)


@pk_log_step("Step 5: Create table if not exists")
def ensure_create_table():
    from pkg_py.pk_colorful_cli_util import pk_print
    conn = get_db_conn()
    cur = conn.cursor()
    cur.execute(
        """
    CREATE TABLE IF NOT EXISTS nyaa_magnets (
      id INT AUTO_INCREMENT PRIMARY KEY,
      magnet TEXT UNIQUE,
      title VARCHAR(255),
      loaded TINYINT(1) DEFAULT 0,
      collected_at DATETIME DEFAULT CURRENT_TIMESTAMP
    ) ENGINE=InnoDB CHARSET=utf8mb4;
    """
    )
    conn.commit()
    cur.close()
    conn.close()
    pk_print("Table nyaa_magnets ready")


@pk_log_step("Initialize DB container flow")
def init_db_container():
    container, name, pwd, port = ensure_load_config()
    data_dir = ensure_prepare_data_dir(container)
    docker_cmd = ensure_docker_env()
    ensure_launch_container(docker_cmd, container, name, pwd, port, data_dir)
    ensure_create_table()
    from pkg_py.pk_colorful_cli_util import pk_print
    import socket, time
    host = get_pk_config("db_host", "127.0.0.1")
    port = int(get_pk_config("db_port", "3306"))
    for i in range(10):
        try:
            with socket.create_connection((host, port), timeout=5):
                pk_print(f"MariaDB reachable at {host}:{port}")
                break
        except Exception:
            pk_print(f"Waiting for MariaDB... ({i + 1}/10)", print_color='yellow')
            time.sleep(2)
    else:
        raise RuntimeError(f"MariaDB not reachable at {host}:{port}")


@pk_log_step("Step 6: Establish DB connection")
def get_db_conn():
    from mysql.connector import connect, Error
    from pkg_py.pk_colorful_cli_util import pk_print
    import time
    host = get_pk_config("db_host", "127.0.0.1")
    user = get_pk_config("db_user", "root")
    pwd = get_pk_config("db_password", "example")
    db = get_pk_config("db_name", "nyaa_db")
    port = int(get_pk_config("db_port", "3306"))
    for attempt in range(1, 6):
        try:
            pk_print(f"Connecting to DB (attempt {attempt})...")
            conn = connect(host=host, user=user, password=pwd, database=db, port=port, charset="utf8mb4")
            pk_print("DB connected")
            return conn
        except Error as e:
            pk_print(f"Connection failed: {e}", print_color="yellow")
            time.sleep(5)
    raise RuntimeError("Could not connect to MariaDB after several attempts")


@pk_log_step("Step 7: Save batch of magnets")
def save_magnets_batch(magnets):
    from pkg_py.pk_colorful_cli_util import pk_print
    from urllib.parse import urlparse, parse_qs, unquote
    pk_print(f"Saving {len(magnets)} magnets")
    conn = get_db_conn()
    cur = conn.cursor()
    data = [(m, parse_qs(urlparse(unquote(m)).query).get("dn", [""])[0]) for m in magnets]
    cur.executemany("INSERT IGNORE INTO nyaa_magnets(magnet,title) VALUES(%s,%s)", data)
    conn.commit()
    cur.close()
    conn.close()
    pk_print("Batch saved")


@pk_log_step("Step 8: Collect magnets from nyaa.si")
def collect_magnet_set_from_nyaa_si_p1(nyaa_si_supplier, search_keyword, driver=None):
    init_db_container()  # DB 컨테이너 & 테이블 자동 ensure
    import random, math
    from bs4 import BeautifulSoup
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from pkg_py.pk_colorful_cli_util import pk_print
    from urllib.parse import urlparse, parse_qs, unquote

    def get_db_conn():
        import mysql.connector
        host = get_pk_config("db_host", "127.0.0.1")
        user = get_pk_config("db_user", "root")
        pwd = get_pk_config("db_password", "example")
        db = get_pk_config("db_name", "nyaa_db")
        port = int(get_pk_config("db_port", "3306"))
        return mysql.connector.connect(
            host=host, user=user, password=pwd, database=db, port=port
        )

    # batch insert 함수
    def save_magnets_batch(magnets):
        pk_print(f"Saving {len(magnets)} magnets to MariaDB")
        conn = get_db_conn()
        cur = conn.cursor()
        # magnet 링크에서 title 파싱
        data = [(m, parse_qs(urlparse(unquote(m)).query).get("dn", [""])[0]) for m in magnets]
        cur.executemany(
            "INSERT IGNORE INTO nyaa_magnets(magnet,title) VALUES(%s,%s)", data
        )
        conn.commit()
        cur.close()
        conn.close()
        pk_print("Batch saved")

    pk_print("Starting crawl")
    driver = driver or get_driver_selenium(browser_debug_mode=False)
    base = f"https://nyaa.si/user/{nyaa_si_supplier}?f=0&c=0_0&q={get_str_encoded_url(search_keyword)}"
    driver.get(base)
    soup = BeautifulSoup(driver.page_source, "html.parser")
    total = get_total_cnt_of_f_torrent_list(soup.find("h3").text.strip())
    pages = math.ceil(total / 75) if total else get_page_number_last_of_nyaa_si_page(base, driver)
    start = 1
    end = 2
    batch = []
    for p in range(start, end + 1):
        try:
            driver.get(f"{base}&p={p}")
            WebDriverWait(driver, 10).until(lambda d: d.find_element(By.TAG_NAME, "body"))
            found = {a["href"] for a in BeautifulSoup(driver.page_source, "html.parser").find_all("a", href=True) if a["href"].startswith("magnet:")}
            pk_print(f"Page {p}: {len(found)} magnets")
            batch.extend(found)
            if len(batch) >= 2000:
                save_magnets_batch(batch)
                batch.clear()
            pk_sleep(milliseconds=random.randint(200, 333))
        except Exception as e:
            pk_print(f"Error page {p}: {e}", print_color="red")
    if batch:
        save_magnets_batch(batch)
    pk_print("Done collecting", print_color="green")
    return None


def get_pnx_from_fzf(pnx=None):
    import subprocess
    import sys
    try:
        if pnx is None:
            cmd = f"find {pnx} -type f | fzf",
        else:
            cmd = f"find . -type f | fzf",
        result = subprocess.run(
            cmd,
            shell=True,
            stdin=sys.stdin,
            stdout=subprocess.PIPE,
            stderr=sys.stderr,
            text=True
        )
        return result.stdout.strip() if result.returncode == 0 else None
    except Exception as e:
        print(f"[ERROR] fzf 실행 중 예외 발생: {e}")
        return None


def is_url(text: str) -> bool:
    from urllib.parse import urlparse
    try:
        result = urlparse(text)
        return result.scheme in ("http", "https") and result.netloc != ""
    except Exception:
        return False


def is_os_linux():
    # todo 명시적으로 업데이트 필요
    if is_os_wsl_linux():
        return True
    if not is_os_windows():
        return True


def ensure_os_path_added():
    # not tested this function 
    # this function is 종속적이다.
    import os, inspect
    from pkg_py.pk_core_constants import D_PROJECT
    # pkg_py 내부 함수들은 전역으로 사용 가능하다고 가정

    func_n = inspect.currentframe().f_code.co_name
    f_func_n_txt = rf'{D_PROJECT}\pkg_txt\{func_n}.txt'
    ensure_pnx_made(pnx=f_func_n_txt, mode="f")

    # 히스토리에서 이전 입력들 불러오기
    hist_file = rf'historical_{func_n}.txt'
    historical_list = get_historical_list(f=hist_file)

    # 사용자로부터 추가할 경로 입력
    os_path_to_add = get_pk_input(
        message='os_path_to_add=',
        answer_options=historical_list
    ).strip()

    # 실제 디렉터리가 존재할 때만 처리
    if does_pnx_exist(pnx=os_path_to_add, mode='d'):
        # 현재 PATH를 분할하고, 중복 없이 수집
        current_paths = os.environ.get('PATH', '').split(os.pathsep)
        unique_paths = []
        for p in current_paths:
            if p and p not in unique_paths and p != os_path_to_add:
                unique_paths.append(p)

        # 마지막에 새 경로 추가
        unique_paths.append(os_path_to_add)

        # OS별 구분자로 합쳐서 export
        new_path_str = os.pathsep.join(unique_paths)
        cmd_to_os(cmd=f'export PATH="{new_path_str}"')

    # 히스토리에 입력값을 맨 앞에 기록
    write_list_to_f(
        f=hist_file,
        working_list=[os_path_to_add] + historical_list,
        mode="w"
    )


def is_path_like(s: str) -> bool:
    import os
    import re
    if not isinstance(s, str):
        return False

    s = s.strip()

    # ❌ URL 은 제외
    if re.match(r'^(https?|ftp)://', s) or re.match(r'^(www\.|youtu\.be|drive\.google\.com)', s):
        return False

    # ✅ 절대 경로 (Windows, POSIX)
    if os.path.isabs(s):
        return True

    # ✅ 상대 경로라도 디렉토리 구분자 포함되면 (예: a/b, a\b)
    if '/' in s or '\\' in s:
        return True

    # ❌ 확장자만 있다고 해서 경로라고 단정하지 않음
    return False


def get_pk_list(origin_list, minus_list=None, plus_list=None, dedup=True):
    """
    origin_list에서 minus_list 항목들을 제거하고 plus_list 항목들을 추가합니다.

    Parameters:
        origin_list (list): 원본 리스트
        minus_list (list | None): 제거할 항목 리스트 (None이면 무시)
        plus_list (list | None): 추가할 항목 리스트 (None이면 무시)
        dedup (bool): True면 중복 없이, False면 순서 유지하며 중복 허용

    Returns:
        list: 최종 결과 리스트
    """
    # None 방지
    minus_list = minus_list or []
    plus_list = plus_list or []

    if dedup:
        return list((set(origin_list) - set(minus_list)) | set(plus_list))
    else:
        minus_set = set(minus_list)
        result = [x for x in origin_list if x not in minus_set]
        result.extend(plus_list)
        return result


def get_values_from_pk_db(db_id, pk_db, f_historical, pk_serial_filters=None):
    # TBD
    # paralel filter(priority) as another function

    value = pk_db.get(db_id=db_id)
    datas = value
    if datas is None:
        datas = []
    historical_lines = get_historical_list(f=f_historical)
    historical_lines = get_pk_list(origin_list=historical_lines, dedup=True)

    for historical_line in historical_lines:
        if pk_serial_filters is None:
            datas.append(historical_line)
        else:
            # serial filter
            if PkFilter.url_like in pk_serial_filters:
                if not is_url(historical_line):
                    continue
            # if PkFilter.url_like in pk_serial_filters:
            #     if not is_url(historical_line):
            #         continue
            datas.append(historical_line)

    return datas


def get_youtube_video_metadata(yt_dlp, url):
    ydl_extract_opts = {
        'quiet': True,
        'skip_download': True
    }
    with yt_dlp.YoutubeDL(ydl_extract_opts) as ydl:
        info = ydl.extract_info(url, download=False)
        title = info.get("title")
        clip_id = info.get("id")
        ext = info.get("ext", "mp4")
    return info, title, clip_id, ext


def download_youtube_videos(urls=None):
    import inspect
    import yt_dlp
    import os
    import traceback
    from pkg_py.pk_core_constants import D_PKG_TXT, D_WORKING, F_FFMPEG_EXE
    from pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_class import PkMents2025, PkStateFromDB

    func_n = inspect.currentframe().f_code.co_name
    f_func_txt = os.path.join(D_PKG_TXT, f"{func_n}.txt")
    pk_db = PkStateFromDB()
    ensure_pnx_made(f_func_txt, mode="f")

    extensions_allowed = {
        ".mp4", ".mkv", ".webm", ".mov", ".avi", ".flv", ".wmv", ".mpeg"
    }

    if is_os_windows():
        D_FFMPEG_LOCATION = get_pnx_os_style(get_p(F_FFMPEG_EXE))
    else:
        ensure_ubuntu_pkg_installed('ffmpeg')
        D_FFMPEG_LOCATION = get_pnx_ubuntu_pkg_installed('ffmpeg')

    if urls is None:
        open_pnx_by_ext(f_func_txt)
        ensure_window_to_front(window_title_seg=get_nx(f_func_txt))

        db_id = 'are_you_ready_to_download_urls?'
        pk_db.reset_value(db_id=db_id)
        pk_db.save_answer(
            question=f"{db_id}",
            options=[PkMents2025.YES, PkMents2025.NO],
            db_id=db_id
        )

        value = pk_db.get(db_id=db_id)
        if value != PkMents2025.YES:
            pk_print("🚫 사용자 요청으로 종료합니다.", print_color="yellow")
            return

        urls_raw = get_list_from_f(f_func_txt)
        urls = get_list_deduplicated([
            line.strip() for line in urls_raw if line.strip()
        ])

        if not urls:
            pk_print("❗ URL이 입력되지 않았습니다.", print_color="red")
            return

    for url in urls:
        url = url.strip()

        if url.startswith("#"):
            pk_print(f"주석 처리된 URL, 건너뜀: {url}", print_color="yellow")
            continue

        try:
            pk_print(f"메타데이터 수집 중... {url}")
            info, title, clip_id, ext = get_youtube_video_metadata(yt_dlp=yt_dlp, url=url)

            output_filename = f"{title} [{clip_id}].{ext}"
            f_output = os.path.join(D_WORKING, output_filename)

            f_pnx_downloaded = get_f_contained_feature_str(feature_str=output_filename, d_pnx=D_WORKING)
            if f_pnx_downloaded and f_pnx_downloaded.lower().endswith(tuple(extensions_allowed)):
                pk_print(f"download skip for {clip_id}({f_pnx_downloaded})", print_color="yellow")
                mark_url_as_done(f_func_txt, original_url=url)

                value = pk_db.get(db_id='download_option')
                if value == PkMents2025.play:
                    open_pnx_by_ext(pnx=f_pnx_downloaded)
                continue

            download_youtube_video_via_yt_dlp_v2(D_FFMPEG_LOCATION,D_WORKING,ext, url)

            # 병합된 최종 파일 존재 여부 확인
            f_pnx_downloaded = get_f_contained_feature_str(feature_str=output_filename, d_pnx=D_WORKING)
            if f_pnx_downloaded and f_pnx_downloaded.lower().endswith(tuple(extensions_allowed)):
                pk_print(f"download complete {clip_id}({f_pnx_downloaded})", print_color="green")
                mark_url_as_done(f_func_txt, original_url=url)

                value = pk_db.get(db_id='download_option')
                if value == PkMents2025.play:
                    pk_print(f'''f_pnx_downloaded={f_pnx_downloaded} {'%%%FOO%%%' if LTA else ''}''')
                    open_pnx_by_ext(pnx=f_pnx_downloaded)
            else:
                pk_print(f"❗ 병합된 최종 파일이 존재하지 않음: {f_output}", print_color="red")

        except Exception:
            pk_print(f"❌ 예외 발생: {url}\n{traceback.format_exc()}", print_color="red")

    pk_print("🎬 전체 다운로드 작업 완료!", print_color="green")


def mark_url_as_done(f, original_url):
    import os
    if not os.path.exists(f):
        return

    with open(f, 'r', encoding='utf-8') as r:
        lines = r.readlines()

    changed = False
    new_lines = []
    for line in lines:
        line_strip = line.strip()
        if line_strip == original_url and not line_strip.startswith("#"):
            new_lines.append(f"# {line_strip}\n")
            changed = True
        else:
            new_lines.append(line)

    if changed:
        with open(f, 'w', encoding='utf-8') as w:
            w.writelines(new_lines)
        ensure_window_to_front(window_title_seg=get_nx(f))


def download_youtube_video_via_yt_dlp_v2(D_FFMPEG_LOCATION,D_WORKING,ext, url):
    from pkg_py.pk_colorful_cli_util import pk_print
    from pkg_py.pk_core_constants import D_WORKING
    import yt_dlp
    import os

    ydl_opts = {
        'ffmpeg_location': D_FFMPEG_LOCATION,
        'format': 'bestvideo+bestaudio/best',
        'outtmpl': os.path.join(D_WORKING, '%(title)s [%(id)s].%(ext)s'),
        'quiet': False,
        'noplaylist': True,
        'geo_bypass': True,
        'skip_unavailable_fragments': True,
        'fragment_retries': 5,
        # 'allow_unplayable_formats': False, # code for dev(debugging)
        'force_generic_extractor': True,
        'merge_output_format': ext,
    }
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        pk_print(f"downloading via ydl...   ({url})", print_color="blue")
        ydl.download([url])
